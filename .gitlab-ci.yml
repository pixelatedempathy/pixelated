---
stages:
- validate
- build
- test
- deploy
qodana:
  stage: test
  image:
    name: jetbrains/qodana-js:2025.2
    entrypoint: [ "" ]
  variables:
    QODANA_TOKEN: $QODANA_TOKEN
    GIT_STRATEGY: fetch
    QODANA_OFFLINE_MODE: "true"
    QODANA_DISABLE_CLOUD: "true"
    JAVA_OPTS: "-Xmx4g -XX:+UseG1GC -XX:MaxGCPauseMillis=200"
  script:
  - qodana --save-report --results-dir=$CI_PROJECT_DIR/.qodana --cache-dir=/tmp/qodana-cache
  allow_failure: true
  timeout: 20m
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: "$CI_MERGE_REQUEST_ID"
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  BETTER_AUTH_SECRET: $BETTER_AUTH_SECRET
  CONTAINER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  CONTAINER_IMAGE_LATEST: $CI_REGISTRY_IMAGE:latest
  CONTAINER_IMAGE_LATEST_PREV: $CI_REGISTRY_IMAGE:previous
  CI_REPOSITORY_URL: git@gitlab.com:pixeldeck/pixelated.git
  CI_REGISTRY: https://registry.gitlab.com/
  CI_REGISTRY_IMAGE: registry.gitlab.com/pixeldeck/pixelated
  GKE_CLUSTER_NAME: ${GKE_CLUSTER_NAME:-pixelcluster}
  GKE_ZONE: ${GKE_ZONE:-us-east1}
  GKE_ENVIRONMENT_URL: ${GKE_ENVIRONMENT_URL:-http://35.243.226.27}
  KUBERNETES_MEMORY_REQUEST: 2Gi
  KUBERNETES_MEMORY_LIMIT: 4Gi
validate-runner:
  stage: validate
  image: docker:27.3.1
  services:
  - name: docker:27.3.1-dind
    alias: docker
    command:
    - "--tls=false"
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ''
  script:
  - set -e
  - echo "Validating GitLab runner capabilities..."
  - apk add --no-cache openssh-client git
  - |
    if ! command -v docker &> /dev/null; then
      echo "Docker not found or failed to install."
      exit 1
    fi
  - docker --version
  - docker info
  - echo "Docker is available and working"
  - echo "Runner:" $CI_RUNNER_DESCRIPTION
  - echo "Executor:" $CI_RUNNER_EXECUTOR
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"
  - if: "$CI_MERGE_REQUEST_ID"
build-frontend:
  stage: build
  image: docker:27.3.1
  services:
  - name: docker:27.3.1-dind
    alias: docker
    command:
    - "--tls=false"
    - "--experimental"
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_BUILDKIT: 1
    DOCKER_TLS_CERTDIR: ''
    NODE_ENV: production
    CI: 'true'
  before_script:
  - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script: |
    echo "ðŸ—ï¸ Building Pixelated Empathy frontend container..."
    ls -la
    test -f Dockerfile || (echo "âŒ Dockerfile not found in repository root"; exit 1)
    docker buildx create --use --name multiarch-builder || docker buildx use multiarch-builder

    export BUILD_SENTRY_RELEASE="${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}"
    docker buildx build \
      --load \
      --build-arg NODE_ENV=production \
      --build-arg CI=true \
      --build-arg SENTRY_DSN="$SENTRY_DSN" \
      --build-arg SENTRY_AUTH_TOKEN="$SENTRY_AUTH_TOKEN" \
      --build-arg SENTRY_RELEASE="$BUILD_SENTRY_RELEASE" \
      --build-arg PUBLIC_SENTRY_DSN="$PUBLIC_SENTRY_DSN" \
      --build-arg BETTER_AUTH_SECRET="$BETTER_AUTH_SECRET" \
      --cache-from type=registry,ref=$CI_REGISTRY_IMAGE:cache \
      --cache-to type=registry,ref=$CI_REGISTRY_IMAGE:cache,mode=max \
      -t $CONTAINER_IMAGE -t $CONTAINER_IMAGE_LATEST .

    echo "ðŸ“¤ Pushing container to GitLab Container Registry..."
    timeout 300 docker push $CONTAINER_IMAGE
    timeout 300 docker push $CONTAINER_IMAGE_LATEST
    echo "âœ… Frontend container pushed to GitLab Container Registry"
    echo "ðŸ“¦ Image SHA: $CONTAINER_IMAGE"
    echo "ðŸ·ï¸ Latest: $CONTAINER_IMAGE_LATEST"
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"
  - if: "$CI_MERGE_REQUEST_ID"
test-container:
  stage: test
  image: docker:27.3.1
  services:
  - name: docker:27.3.1-dind
    alias: docker
    command:
    - "--tls=false"
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ''
  before_script:
  - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
  - echo "Testing container health..."
  - docker pull $CONTAINER_IMAGE
  - |
    docker run -d --name test-container \
      -e BETTER_AUTH_SECRET="$BETTER_AUTH_SECRET" \
      $CONTAINER_IMAGE
  - sleep 30
  - docker logs test-container
  - |
    if docker exec test-container curl -f http://localhost:4321 > /dev/null 2>&1; then
      echo "âœ… Container health check passed"
    else
      echo "âŒ Container health check failed"
      docker logs test-container
      exit 1
    fi
  - docker stop test-container
  - docker rm test-container
  dependencies:
  - build-frontend
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"

sentry-token-check:
  stage: test
  image: alpine:latest
  script:
  - |
    if [ -z "$SENTRY_AUTH_TOKEN" ]; then
      echo "âš ï¸  SENTRY_AUTH_TOKEN is not set. Source map upload will be skipped. This check is non-blocking.";
      exit 0;
    else
      echo "âœ… SENTRY_AUTH_TOKEN is present.";
    fi
  allow_failure: true
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"

# Create Sentry release and upload source maps if token is present
sentry-release:
  stage: test
  image: node:24-bullseye
  before_script:
  - apt-get update && apt-get install -y curl git ca-certificates
  script:
  - |
    if [ -n "$SENTRY_AUTH_TOKEN" ]; then
      # Prefer Git tag for release name when available, else fall back to short SHA
      if [ -n "$CI_COMMIT_TAG" ]; then
        RELEASE="$CI_COMMIT_TAG"
      else
        RELEASE="$CI_COMMIT_SHORT_SHA"
      fi
      echo "Creating Sentry release: $RELEASE";
      curl -sL https://sentry.io/get-cli/ | bash;
      sentry-cli --version;
      sentry-cli releases new "$RELEASE" || true;
      sentry-cli releases files "$RELEASE" upload-sourcemaps ./dist --rewrite --strip-prefix ./ --strip-common-prefix || true;
      sentry-cli releases finalize "$RELEASE" || true;
    else
      echo "SENTRY_AUTH_TOKEN not set; skipping sentry-cli release/upload";
    fi
  dependencies:
  - build-frontend
  rules:
  # Run this job only when a Git tag is pushed (preferred release flow)
  - if: $CI_COMMIT_TAG
    when: on_success
  # Keep the job non-blocking for master branch (manual run if needed)
  - if: $CI_COMMIT_BRANCH == "master"
    when: manual
  allow_failure: true
deploy-vps:
  stage: deploy
  image: alpine:latest
  before_script:
  - apk add --no-cache openssh-client curl git
  - eval $(ssh-agent -s)
  - |
    if [ -z "$VPS_SSH_PRIVATE_KEY_B64" ]; then
      echo "âŒ VPS_SSH_PRIVATE_KEY_B64 environment variable is not set"
      exit 1
    fi

    echo "ðŸ”‘ Setting up SSH private key..."

    SSH_KEY_FILE=$(mktemp)
    trap "rm -f $SSH_KEY_FILE" EXIT

    printf '%s' "${VPS_SSH_PRIVATE_KEY_B64}" > "$SSH_KEY_FILE" || {
      echo "âŒ Failed to write SSH key"
      exit 1
    }

    if ! head -n 1 "$SSH_KEY_FILE" | grep -q "-----BEGIN"; then
      echo "âŒ Invalid SSH key format - missing BEGIN marker"
      echo "Key should start with: -----BEGIN RSA PRIVATE KEY----- or -----BEGIN OPENSSH PRIVATE KEY-----"
      exit 1
    fi

    chmod 600 "$SSH_KEY_FILE"
    if ! ssh-add "$SSH_KEY_FILE" 2>/dev/null; then
      echo "âŒ Failed to add SSH key to agent"
      exit 1
    fi

    echo "âœ… SSH key successfully added to agent"
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh
  - ssh-keyscan -H $VPS_HOST >> ~/.ssh/known_hosts
  script:
  - echo "Deploying to VPS..."
  - |
    ssh $VPS_USER@$VPS_HOST << 'EOF'
      set -e

      # Colors for remote output
      RED='\033[0;31m'
      GREEN='\033[0;32m'
      YELLOW='\033[1;33m'
      BLUE='\033[0;34m'
      NC='\033[0m'

      print_status() { echo -e "${GREEN}[VPS]${NC} $1"; }
      print_error() { echo -e "${RED}[VPS ERROR]${NC} $1"; }

      print_status "Starting GitLab container deployment..."

      # Install Docker if not present
      if ! command -v docker &> /dev/null; then
          print_status "Installing Docker..."
          curl -fsSL https://get.docker.com | sh
          systemctl start docker
          systemctl enable docker
      fi

      # Install Caddy if not present and domain is configured
      if [ -n "$VPS_DOMAIN" ] && ! command -v caddy &> /dev/null; then
          print_status "Installing Caddy..."
          apt-get update
          apt-get install -y debian-keyring debian-archive-keyring apt-transport-https
          curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
          curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
          apt-get update
          apt-get install -y caddy
          systemctl enable caddy
      fi

      # Login to GitLab Container Registry
      print_status "Logging into GitLab Container Registry..."
      echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY

      # Pull latest image from GitLab
      print_status "Pulling latest image from GitLab Container Registry..."
      docker pull $CONTAINER_IMAGE_LATEST

      # Stop existing container
      print_status "Stopping existing container..."
      docker stop pixelated-app 2>/dev/null || true
      docker rm pixelated-app 2>/dev/null || true

      # Set up environment variables for container
      PUBLIC_URL="http://$VPS_HOST:4321"
      CORS_ORIGINS="http://$VPS_HOST:4321,https://$VPS_HOST:4321"

      if [ -n "$VPS_DOMAIN" ]; then
          PUBLIC_URL="https://$VPS_DOMAIN"
          CORS_ORIGINS="$CORS_ORIGINS,http://$VPS_DOMAIN,https://$VPS_DOMAIN"
      fi

      # Run new container
      print_status "Starting new container from GitLab image..."
      docker run -d \
        --name pixelated-app \
        --restart unless-stopped \
        -p 4321:4321 \
        -e NODE_ENV=production \
        -e PORT=4321 \
        -e WEB_PORT=4321 \
        -e LOG_LEVEL=info \
        -e ENABLE_RATE_LIMITING=true \
        -e RATE_LIMIT_WINDOW=60 \
        -e RATE_LIMIT_MAX_REQUESTS=100 \
        -e ENABLE_HIPAA_COMPLIANCE=true \
        -e ENABLE_AUDIT_LOGGING=true \
        -e ENABLE_DATA_MASKING=true \
        -e ASTRO_TELEMETRY_DISABLED=1 \
        -e PUBLIC_URL="$PUBLIC_URL" \
        -e CORS_ORIGINS="$CORS_ORIGINS" \
        -e BETTER_AUTH_SECRET="$BETTER_AUTH_SECRET"
        $CONTAINER_IMAGE_LATEST

      # Wait for container to start
      sleep 15

      # Check container status
      if docker ps | grep -q pixelated-app; then
          print_status "âœ… Container is running"
          docker logs --tail 10 pixelated-app
      else
          print_error "âŒ Container failed to start"
          docker logs pixelated-app
          exit 1
      fi

      # Configure Caddy if domain is set
      if [[ -n "$VPS_DOMAIN" ]]; then
          print_status "Configuring Caddy for domain: $VPS_DOMAIN"
          cat > /etc/caddy/Caddyfile << 'CADDY_EOF'
      $VPS_DOMAIN {
          reverse_proxy localhost:4321

          # Enable compression
          encode gzip

          # Security headers
          header {
              # Enable HSTS
              Strict-Transport-Security max-age=31536000;
              # Prevent MIME sniffing
              X-Content-Type-Options nosniff
              # Prevent clickjacking
              X-Frame-Options DENY
              # XSS protection
              X-XSS-Protection "1; mode=block"
              # Referrer policy
              Referrer-Policy strict-origin-when-cross-origin
          }

          # Health check endpoint
          handle /api/health* {
              reverse_proxy localhost:4321
          }

          # Static assets with long cache
          handle /assets/* {
              reverse_proxy localhost:4321
              header Cache-Control "public, max-age=31536000, immutable"
          }

          # All other requests
          handle {
              reverse_proxy localhost:4321
          }
      }
      CADDY_EOF

          # Test and reload Caddy
          print_status "Testing Caddy configuration..."
          caddy validate --config /etc/caddy/Caddyfile

          print_status "Starting Caddy..."
          systemctl restart caddy
      fi

      print_status "âœ… VPS deployment completed!"

      # Show access URLs
      print_status "Application URLs:"
      print_status "  Direct: https://$VPS_HOST:4321"
      if [[ -n "$VPS_DOMAIN" ]]; then
          print_status "  Domain: https://$VPS_DOMAIN"
      fi
    EOF
  dependencies:
  - test-container
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
    when: manual
  - if: $CI_COMMIT_BRANCH == "main"
    when: manual
  environment:
    name: production
build-ai-backend:
  stage: build
  image: docker:27.3.1
  services:
  - name: docker:27.3.1-dind
    alias: docker
    command:
    - "--tls=false"
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ''
  before_script:
  - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script: |
    echo "Building AI backend components..."
    cd ai
    docker buildx create --use --name ai-builder || docker buildx use ai-builder

    docker buildx build \
      --load \
      --build-arg BETTER_AUTH_SECRET="$BETTER_AUTH_SECRET" \
      -t $CI_REGISTRY_IMAGE/ai:$CI_COMMIT_SHA -t $CI_REGISTRY_IMAGE/ai:latest .

    docker push $CI_REGISTRY_IMAGE/ai:$CI_COMMIT_SHA
    docker push $CI_REGISTRY_IMAGE/ai:latest
    echo "âœ… AI backend container pushed to GitLab Container Registry"
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
    changes:
    - ai/**/*
  - if: $CI_COMMIT_BRANCH == "main"
    changes:
    - ai/**/*
  allow_failure: true
security-scan:
  stage: test
  image: docker:27.3.1
  services:
  - name: docker:27.3.1-dind
    alias: docker
    command:
    - "--tls=false"
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ''
  before_script:
  - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
  - echo "Running security scan on container..."
  - docker pull $CONTAINER_IMAGE
  - |
    # Basic security checks
    echo "Checking for non-root user..."
    if docker run --rm $CONTAINER_IMAGE whoami | grep -v root; then
      echo "âœ… Container runs as non-root user"
    else
      echo "âš ï¸  Container may be running as root"
    fi

    echo "Checking exposed ports..."
    docker run --rm $CONTAINER_IMAGE netstat -tlnp 2>/dev/null || echo "netstat not available"

    echo "âœ… Security scan completed"
  dependencies:
  - build-frontend
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: true
rollback:
  stage: deploy
  image: alpine:latest
  before_script:
  - apk add --no-cache openssh-client
  - eval $(ssh-agent -s)
  - |
    # Validate SSH private key
    if [ -z "$VPS_SSH_PRIVATE_KEY_B64" ]; then
      echo "âŒ VPS_SSH_PRIVATE_KEY_B64 environment variable is not set"
      exit 1
    fi

    echo "ðŸ”‘ Setting up SSH private key..."

    # Create temporary file for the key
    SSH_KEY_FILE=$(mktemp)
    trap "rm -f $SSH_KEY_FILE" EXIT

    # Write the key to temp file
    printf '%s' "${VPS_SSH_PRIVATE_KEY_B64}" > "$SSH_KEY_FILE" || {
      echo "âŒ Failed to write SSH key"
      exit 1
    }

    # Validate the key format
    if ! head -n 1 "$SSH_KEY_FILE" | grep -q "-----BEGIN"; then
      echo "âŒ Invalid SSH key format - missing BEGIN marker"
      echo "Key should start with: -----BEGIN RSA PRIVATE KEY----- or -----BEGIN OPENSSH PRIVATE KEY-----"
      exit 1
    fi

    # Set correct permissions and add to ssh-agent
    chmod 600 "$SSH_KEY_FILE"
    if ! ssh-add "$SSH_KEY_FILE" 2>/dev/null; then
      echo "âŒ Failed to add SSH key to agent"
      exit 1
    fi

    echo "âœ… SSH key successfully added to agent"
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh
  - ssh-keyscan -H $VPS_HOST >> ~/.ssh/known_hosts
  script:
  - echo "Rolling back to previous container version..."
  - |
    ssh $VPS_USER@$VPS_HOST << 'EOF'
      echo "Performing rollback on VPS..."
      docker pull $CONTAINER_IMAGE_LATEST_PREV || echo "No previous image found"
      docker stop pixelated-app || true
      docker rm pixelated-app || true
      docker run -d --name pixelated-app --restart unless-stopped -p 4321:4321 $CONTAINER_IMAGE_LATEST_PREV
      echo "âœ… Rollback complete"
    EOF
  rules:
  - when: manual
  allow_failure: true
health-check:
  stage: deploy
  image: alpine:latest
  script:
  - apk add --no-cache curl
  - echo "Running post-deploy health check..."
  - |
    # If neither VPS_DOMAIN nor VPS_HOST is set, skip the health check to avoid DNS failures
    if [ -z "$VPS_DOMAIN" ] && [ -z "$VPS_HOST" ]; then
      echo "No VPS_DOMAIN or VPS_HOST configured - skipping health check"
      exit 0
    fi

    # Prefer VPS_DOMAIN, fall back to VPS_HOST
    TARGET=""
    if [ -n "$VPS_DOMAIN" ]; then
      TARGET="$VPS_DOMAIN"
    else
      TARGET="$VPS_HOST"
    fi

    # Try HTTPS first, then HTTP. Retry a few times to allow service to come up.
    MAX_RETRIES=6
    SLEEP_SECONDS=10
    PASSED=0

    for i in $(seq 1 $MAX_RETRIES); do
      echo "Health check attempt $i/$MAX_RETRIES..."
      if curl -fsS --connect-timeout 5 https://$TARGET/api/health >/dev/null 2>&1; then
        echo "Health check passed (HTTPS)";
        PASSED=1; break
      fi
      if curl -fsS --connect-timeout 5 http://$TARGET/api/health >/dev/null 2>&1; then
        echo "Health check passed (HTTP)";
        PASSED=1; break
      fi
      echo "Attempt $i failed, sleeping $SLEEP_SECONDS seconds before retry..."
      sleep $SLEEP_SECONDS
    done

    if [ "$PASSED" -eq 1 ]; then
      echo "Health check succeeded"
      exit 0
    else
      echo "Health check failed after $MAX_RETRIES attempts"
      # Non-blocking in CI: fail job but allow pipeline to continue
      exit 1
    fi
  dependencies:
  - deploy-vps
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: true
retain-logs:
  stage: test
  image: alpine:latest
  script:
  - mkdir -p artifacts
  - cp /var/log/* artifacts/ || true
  - echo "Logs retained for debugging"
  artifacts:
    paths:
    - artifacts/
    expire_in: 7 days
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"
deploy-staging:
  stage: deploy
  image: alpine:latest
  before_script:
  - apk add --no-cache openssh-client curl git
  - eval $(ssh-agent -s)
  - |
    # Decode and validate SSH private key
    if [ -z "$VPS_SSH_PRIVATE_KEY_B64" ]; then
      echo "âŒ VPS_SSH_PRIVATE_KEY_B64 environment variable is not set"
      exit 1
    fi

    echo "ðŸ”‘ Setting up SSH private key..."

    # Create temporary file for the key
    SSH_KEY_FILE=$(mktemp)
    trap "rm -f $SSH_KEY_FILE" EXIT

    # Write the key to temp file
    printf '%s' "${VPS_SSH_PRIVATE_KEY_B64}" > "$SSH_KEY_FILE" || {
      echo "âŒ Failed to write SSH key"
      exit 1
    }

    # Validate the key format
    if ! head -n 1 "$SSH_KEY_FILE" | grep -q "-----BEGIN"; then
      echo "âŒ Invalid SSH key format - missing BEGIN marker"
      echo "Key should start with: -----BEGIN RSA PRIVATE KEY----- or -----BEGIN OPENSSH PRIVATE KEY-----"
      exit 1
    fi

    # Set correct permissions and add to ssh-agent
    chmod 600 "$SSH_KEY_FILE"
    if ! ssh-add "$SSH_KEY_FILE" 2>/dev/null; then
      echo "âŒ Failed to add SSH key to agent"
      exit 1
    fi

    echo "âœ… SSH key successfully added to agent"
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh
  - ssh-keyscan -H $VPS_HOST >> ~/.ssh/known_hosts
  script:
  - echo "Deploying to staging VPS..."
  environment:
    name: staging
  rules:
  - if: $CI_COMMIT_BRANCH == "staging"
    when: manual
tag-image:
  stage: test
  image: docker:27.3.1
  services:
  - name: docker:27.3.1-dind
    alias: docker
    command:
    - "--tls=false"
    - "--experimental"
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_BUILDKIT: 1
    DOCKER_TLS_CERTDIR: ''
  before_script:
  - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script: |
    echo "Tagging image with branch and build number..."
    if docker pull $CONTAINER_IMAGE; then
      docker tag $CONTAINER_IMAGE $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME-$CI_PIPELINE_ID
      docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME-$CI_PIPELINE_ID
      echo "âœ… Image tagged and pushed: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME-$CI_PIPELINE_ID"
    else
      echo "âŒ Failed to pull image $CONTAINER_IMAGE"
      exit 1
    fi
  dependencies:
  - build-frontend
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"
trivy-scan:
  stage: test
  image:
    name: aquasec/trivy:latest
    entrypoint: [ "" ]
  script:
  - echo "Scanning container image for vulnerabilities..."
  - trivy image $CONTAINER_IMAGE
  dependencies:
  - build-frontend
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: true

cleanup:
  stage: deploy
  image: docker:27.3.1
  services:
  - name: docker:27.3.1-dind
    alias: docker
    command:
    - "--tls=false"
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ''
  before_script:
  - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
  - echo "Cleaning up old container images..."
  - docker image prune -af --filter "until=24h"
  - docker system prune -f --filter "until=24h"
  - echo "âœ… Old images and containers removed"
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
    when: manual
  allow_failure: true
deploy-gke:
  stage: deploy
  image: google/cloud-sdk:alpine
  before_script:
  - apk add --no-cache kubectl curl jq
  - |
    echo "Preparing GCP service account key for gcloud authentication..."

    # Prefer a JSON key provided directly or base64-encoded in CI variables.
    # CI should provide one of: GCP_SERVICE_ACCOUNT_KEY (raw JSON) or GCP_SERVICE_ACCOUNT_KEY_B64 (base64 encoded)
    if [ -n "$GCP_SERVICE_ACCOUNT_KEY" ]; then
      echo "$GCP_SERVICE_ACCOUNT_KEY" > /tmp/gcp-key.json
    elif [ -n "$GCP_SERVICE_ACCOUNT_KEY_B64" ]; then
      echo "$GCP_SERVICE_ACCOUNT_KEY_B64" | base64 -d > /tmp/gcp-key.json || {
        echo "âŒ Failed to decode GCP_SERVICE_ACCOUNT_KEY_B64"; exit 1;
      }
    else
      echo "âŒ Neither GCP_SERVICE_ACCOUNT_KEY nor GCP_SERVICE_ACCOUNT_KEY_B64 is set. Please configure one in CI variables.";
      exit 1;
    fi

    # Basic validation of the written key file
    if ! jq -e . /tmp/gcp-key.json >/dev/null 2>&1; then
      echo "âŒ /tmp/gcp-key.json does not contain valid JSON. Aborting.";
      cat /tmp/gcp-key.json || true
      exit 1;
    fi

    chmod 600 /tmp/gcp-key.json
    gcloud auth activate-service-account --key-file=/tmp/gcp-key.json || {
      echo "âŒ Failed to authenticate with gcloud using /tmp/gcp-key.json";
      gcloud --version || true
      ls -l /tmp/gcp-key.json || true
      exit 1;
    }
    gcloud config set project $GCP_PROJECT_ID
  - gcloud config set project $GCP_PROJECT_ID
  - gcloud container clusters get-credentials $GKE_CLUSTER_NAME --zone $GKE_ZONE
  script:
  - echo "Deploying to GKE cluster..."
  - |
    # Update deployment with new image
    kubectl patch deployment pixelated -p '{"spec":{"template":{"spec":{"containers":[{"name":"pixelated","image":"'$CONTAINER_IMAGE'"}]}}}}'

    # Wait for rollout
    kubectl rollout status deployment/pixelated --timeout=600s

    # Verify deployment
    kubectl get pods -l app=pixelated
    kubectl get services pixelated-service

    # Health check with retry
    echo "Running health check..."
    for i in {1..15}; do
      EXTERNAL_IP=$(kubectl get service pixelated-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
      if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "<pending>" ]; then
        if curl -f http://$EXTERNAL_IP/ --connect-timeout 10 --max-time 30; then
          echo "âœ… Health check passed - Service available at http://$EXTERNAL_IP"
          break
        fi
      fi
      echo "Attempt $i failed, retrying in 20s..."
      sleep 20
    done
  - echo "âœ… Deployed to GKE successfully"
  environment:
    name: production-gke
    url: $GKE_ENVIRONMENT_URL
  rules:
  - if: $CI_COMMIT_BRANCH == "master"
  - if: $CI_COMMIT_BRANCH == "main"
  dependencies:
  - build-frontend
include:
- remote: https://gitlab.com/gitlab-org/incubation-engineering/five-minute-production/library/-/raw/main/gcp/cloud-run.gitlab-ci.yml
