/**
 * Threat Hunting and Investigation Service
 * Provides proactive threat hunting capabilities and advanced investigation tools
 */

import { EventEmitter } from 'events';
import { Redis } from 'ioredis';
import { MongoClient } from 'mongodb';
import * as tf from '@tensorflow/tfjs';
import { createBuildSafeLogger } from '../../logging/build-safe-logger';

const logger = createBuildSafeLogger('threat-hunting-service');

export interface ThreatHuntingConfig {
  enabled: boolean;
  huntingFrequency: number; // milliseconds
  investigationTimeout: number;
  mlModelConfig: {
    enabled: boolean;
    modelPath: string;
    confidenceThreshold: number;
  };
  huntingRules: HuntingRule[];
  investigationTemplates: InvestigationTemplate[];
}

export interface HuntingRule {
  ruleId: string;
  name: string;
  description: string;
  query: Record<string, unknown>;
  severity: 'low' | 'medium' | 'high' | 'critical';
  enabled: boolean;
  autoInvestigate: boolean;
  investigationPriority: number;
}

export interface InvestigationTemplate {
  templateId: string;
  name: string;
  description: string;
  steps: InvestigationStep[];
  requiredData: string[];
  estimatedDuration: number;
}

export interface InvestigationStep {
  stepId: string;
  name: string;
  description: string;
  action: string;
  parameters: Record<string, unknown>;
  validationRules: ValidationRule[];
  timeout: number;
}

export interface ValidationRule {
  type: 'threshold' | 'pattern' | 'existence';
  condition: string;
  expectedValue?: unknown;
  operator?: 'equals' | 'greater_than' | 'less_than' | 'contains' | 'exists';
}

export interface HuntResult {
  huntId: string;
  ruleId: string;
  timestamp: Date;
  findings: HuntFinding[];
  investigationTriggered: boolean;
  investigationId?: string;
  confidence: number;
  severity: 'low' | 'medium' | 'high' | 'critical';
  metadata: Record<string, unknown>;
}

export interface HuntFinding {
  findingId: string;
  type: 'anomaly' | 'suspicious_pattern' | 'iocs' | 'behavioral_deviation';
  title: string;
  description: string;
  evidence: Record<string, unknown>[];
  confidence: number;
  severity: 'low' | 'medium' | 'high' | 'critical';
  recommendedActions: string[];
  relatedEntities: string[];
}

export interface Investigation {
  investigationId: string;
  huntId?: string;
  threatId?: string;
  templateId?: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  priority: 'low' | 'medium' | 'high' | 'critical';
  steps: InvestigationStepResult[];
  findings: InvestigationFinding[];
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  metadata: Record<string, unknown>;
}

export interface InvestigationStepResult {
  stepId: string;
  name: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';
  result?: Record<string, unknown>;
  error?: string;
  executionTime: number;
  timestamp: Date;
}

export interface InvestigationFinding {
  findingId: string;
  stepId: string;
  type: 'evidence' | 'indicator' | 'anomaly' | 'conclusion';
  title: string;
  description: string;
  data: Record<string, unknown>;
  confidence: number;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: Date;
}

export class ThreatHuntingService extends EventEmitter {
  private redis: Redis;
  private mongoClient: MongoClient;
  private config: ThreatHuntingConfig;
  private huntingModel: tf.Sequential | null = null;
  private huntingInterval: NodeJS.Timeout | null = null;
  private activeInvestigations: Map<string, Investigation> = new Map();

  constructor(config: ThreatHuntingConfig) {
    super();
    this.config = config;
    this.initializeServices();
  }

  private async initializeServices(): Promise<void> {
    try {
      this.redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');
      this.mongoClient = new MongoClient(process.env.MONGODB_URI || 'mongodb://localhost:27017/threat_detection');

      await this.mongoClient.connect();

      if (this.config.mlModelConfig.enabled) {
        await this.initializeMLModel();
      }

      logger.info('Threat hunting service initialized');
      this.emit('hunting_initialized');
    } catch (error) {
      logger.error('Failed to initialize threat hunting service:', { error });
      throw error;
    }
  }

  private async initializeMLModel(): Promise<void> {
    try {
      // Initialize threat hunting ML model
      this.huntingModel = tf.sequential({
        layers: [
          tf.layers.dense({ units: 128, activation: 'relu', inputShape: [20] }),
          tf.layers.dropout({ rate: 0.3 }),
          tf.layers.dense({ units: 64, activation: 'relu' }),
          tf.layers.dropout({ rate: 0.2 }),
          tf.layers.dense({ units: 32, activation: 'relu' }),
          tf.layers.dense({ units: 4, activation: 'softmax' }) // 4 threat levels
        ]
      });

      this.huntingModel.compile({
        optimizer: tf.train.adam(0.001),
        loss: 'categoricalCrossentropy',
        metrics: ['accuracy']
      });

      logger.info('Threat hunting ML model initialized');
    } catch (error) {
      logger.error('Failed to initialize ML model:', { error });
      this.huntingModel = null;
    }
  }

  /**
   * Start automated threat hunting
   */
  async startHunting(): Promise<void> {
    if (!this.config.enabled) {
      logger.warn('Threat hunting is disabled');
      return;
    }

    if (this.huntingInterval) {
      logger.warn('Threat hunting is already running');
      return;
    }

    try {
      // Execute initial hunt
      await this.executeHunts();

      // Schedule regular hunts
      this.huntingInterval = setInterval(async () => {
        try {
          await this.executeHunts();
        } catch (error) {
          logger.error('Automated hunting error:', { error });
        }
      }, this.config.huntingFrequency);

      logger.info('Automated threat hunting started');
      this.emit('hunting_started');
    } catch (error) {
      logger.error('Failed to start threat hunting:', { error });
      throw error;
    }
  }

  /**
   * Stop automated threat hunting
   */
  async stopHunting(): Promise<void> {
    if (this.huntingInterval) {
      clearInterval(this.huntingInterval);
      this.huntingInterval = null;

      logger.info('Automated threat hunting stopped');
      this.emit('hunting_stopped');
    }
  }

  /**
   * Execute threat hunting rules
   */
  async executeHunts(): Promise<HuntResult[]> {
    try {
      const enabledRules = this.config.huntingRules.filter(rule => rule.enabled);
      const results: HuntResult[] = [];

      for (const rule of enabledRules) {
        try {
          const result = await this.executeHuntRule(rule);
          results.push(result);

          // Trigger investigation if needed
          if (result.investigationTriggered && rule.autoInvestigate) {
            await this.startInvestigation({
              huntId: result.huntId,
              ruleId: rule.ruleId,
              priority: rule.investigationPriority
            });
          }
        } catch (error) {
          logger.error(`Failed to execute hunt rule ${rule.ruleId}:`, { error });
        }
      }

      this.emit('hunts_completed', { results: results.length });
      return results;
    } catch (error) {
      logger.error('Failed to execute hunts:', { error });
      throw error;
    }
  }

  /**
   * Execute a specific hunting rule
   */
  private async executeHuntRule(rule: HuntingRule): Promise<HuntResult> {
    const huntId = `hunt_${rule.ruleId}_${Date.now()}`;

    try {
      logger.info(`Executing hunt rule: ${rule.name}`, { huntId, ruleId: rule.ruleId });

      // Execute the hunt query
      const findings = await this.executeHuntQuery(rule.query);

      // Apply ML analysis if enabled
      let mlFindings: HuntFinding[] = [];
      if (this.huntingModel && findings.length > 0) {
        mlFindings = await this.applyMLAnalysis(findings);
      }

      // Combine findings
      const allFindings = [...findings, ...mlFindings];

      // Calculate overall confidence and severity
      const confidence = this.calculateHuntConfidence(allFindings);
      const severity = this.determineHuntSeverity(allFindings, rule.severity);

      // Determine if investigation should be triggered
      const investigationTriggered = this.shouldTriggerInvestigation(allFindings, rule);

      const result: HuntResult = {
        huntId,
        ruleId: rule.ruleId,
        timestamp: new Date(),
        findings: allFindings,
        investigationTriggered,
        confidence,
        severity,
        metadata: {
          ruleName: rule.name,
          executionTime: Date.now(),
          findingsCount: allFindings.length
        }
      };

      // Store hunt result
      await this.storeHuntResult(result);

      logger.info(`Hunt rule completed: ${rule.name}`, {
        huntId,
        findings: allFindings.length,
        severity
      });

      return result;
    } catch (error) {
      logger.error(`Failed to execute hunt rule ${rule.ruleId}:`, { error, huntId });
      throw error;
    }
  }

  /**
   * Execute hunt query against data sources
   */
  private async executeHuntQuery(query: Record<string, unknown>): Promise<HuntFinding[]> {
    const findings: HuntFinding[] = [];

    try {
      // Query MongoDB for threat data
      const dbFindings = await this.queryDatabase(query);
      findings.push(...dbFindings);

      // Query Redis for recent activity
      const redisFindings = await this.queryRedis(query);
      findings.push(...redisFindings);

      // Query logs if specified
      if (query.includeLogs) {
        const logFindings = await this.queryLogs(query);
        findings.push(...logFindings);
      }

      return findings;
    } catch (error) {
      logger.error('Failed to execute hunt query:', { error });
      return [];
    }
  }

  /**
   * Query MongoDB for threat hunting data
   */
  private async queryDatabase(query: Record<string, unknown>): Promise<HuntFinding[]> {
    try {
      const db = this.mongoClient.db('threat_detection');
      const findings: HuntFinding[] = [];

      // Query recent threats
      if (query.recentThreats) {
        const recentThreats = await db.collection('threat_responses')
          .find({
            createdAt: { $gte: new Date(Date.now() - 86400000) } // Last 24 hours
          })
          .limit(100)
          .toArray();

        if (recentThreats.length > 50) {
          findings.push({
            findingId: `db_recent_threats_${Date.now()}`,
            type: 'suspicious_pattern',
            title: 'High Volume of Recent Threats',
            description: `Detected ${recentThreats.length} threats in the last 24 hours`,
            evidence: recentThreats.slice(0, 5),
            confidence: 0.8,
            severity: 'medium',
            recommendedActions: ['investigate_threat_sources', 'review_security_policies'],
            relatedEntities: recentThreats.map(t => t.threatId).slice(0, 10)
          });
        }
      }

      // Query anomalies
      if (query.anomalies) {
        const anomalies = await db.collection('anomalies')
          .find({
            timestamp: { $gte: new Date(Date.now() - 3600000) }, // Last hour
            score: { $gt: 0.7 }
          })
          .limit(20)
          .toArray();

        if (anomalies.length > 5) {
          findings.push({
            findingId: `db_anomalies_${Date.now()}`,
            type: 'anomaly',
            title: 'Multiple High-Score Anomalies Detected',
            description: `Found ${anomalies.length} anomalies with score > 0.7 in the last hour`,
            evidence: anomalies,
            confidence: 0.9,
            severity: 'high',
            recommendedActions: ['investigate_anomaly_sources', 'check_system_integrity'],
            relatedEntities: anomalies.map(a => a.anomalyId)
          });
        }
      }

      return findings;
    } catch (error) {
      logger.error('Failed to query database:', { error });
      return [];
    }
  }

  /**
   * Query Redis for recent activity patterns
   */
  private async queryRedis(query: Record<string, unknown>): Promise<HuntFinding[]> {
    try {
      const findings: HuntFinding[] = [];

      // Check for suspicious IP patterns
      if (query.suspiciousIPs) {
        const suspiciousIPs = await this.redis.smembers('suspicious_ips');

        if (suspiciousIPs.length > 10) {
          findings.push({
            findingId: `redis_suspicious_ips_${Date.now()}`,
            type: 'iocs',
            title: 'Large Number of Suspicious IPs',
            description: `Redis contains ${suspiciousIPs.length} flagged IP addresses`,
            evidence: suspiciousIPs.slice(0, 5).map(ip => ({ ip })),
            confidence: 0.7,
            severity: 'medium',
            recommendedActions: ['review_ip_reputation', 'check_geolocation'],
            relatedEntities: suspiciousIPs
          });
        }
      }

      // Check for rate limiting violations
      if (query.rateLimitViolations) {
        const violations = await this.redis.keys('rate_limit:*');

        if (violations.length > 20) {
          findings.push({
            findingId: `redis_rate_violations_${Date.now()}`,
            type: 'suspicious_pattern',
            title: 'High Rate Limiting Activity',
            description: `Detected ${violations.length} active rate limiting entries`,
            evidence: violations.slice(0, 5).map(key => ({ key })),
            confidence: 0.6,
            severity: 'low',
            recommendedActions: ['review_rate_limits', 'analyze_traffic_patterns'],
            relatedEntities: violations
          });
        }
      }

      return findings;
    } catch (error) {
      logger.error('Failed to query Redis:', { error });
      return [];
    }
  }

  /**
   * Query logs for suspicious activity
   */
  private async queryLogs(query: Record<string, unknown>): Promise<HuntFinding[]> {
    try {
      const findings: HuntFinding[] = [];

      // This is a simplified implementation
      // In a real system, you would query actual log files or a log aggregation service

      if (query.errorPatterns) {
        findings.push({
          findingId: `logs_errors_${Date.now()}`,
          type: 'anomaly',
          title: 'Error Pattern Detection',
          description: 'Multiple error patterns detected in system logs',
          evidence: [{ pattern: 'authentication_failure', count: 15 }],
          confidence: 0.7,
          severity: 'medium',
          recommendedActions: ['review_error_logs', 'investigate_authentication_issues'],
          relatedEntities: ['authentication_service', 'user_management']
        });
      }

      return findings;
    } catch (error) {
      logger.error('Failed to query logs:', { error });
      return [];
    }
  }

  /**
   * Apply ML analysis to hunt findings
   */
  private async applyMLAnalysis(findings: HuntFinding[]): Promise<HuntFinding[]> {
    if (!this.huntingModel) {
      return [];
    }

    try {
      const mlFindings: HuntFinding[] = [];

      for (const finding of findings) {
        const features = this.extractMLFeatures(finding);
        const prediction = await this.predictThreatLevel(features);

        if (prediction.confidence > this.config.mlModelConfig.confidenceThreshold) {
          mlFindings.push({
            findingId: `ml_${finding.findingId}`,
            type: 'behavioral_deviation',
            title: `ML-Enhanced: ${finding.title}`,
            description: `ML analysis indicates ${prediction.threatLevel} threat level with ${(prediction.confidence * 100).toFixed(1)}% confidence`,
            evidence: [...finding.evidence, { ml_prediction: prediction }],
            confidence: prediction.confidence,
            severity: this.mapThreatLevelToSeverity(prediction.threatLevel),
            recommendedActions: [...finding.recommendedActions, 'review_ml_findings'],
            relatedEntities: finding.relatedEntities
          });
        }
      }

      return mlFindings;
    } catch (error) {
      logger.error('Failed to apply ML analysis:', { error });
      return [];
    }
  }

  /**
   * Extract features for ML analysis
   */
  private extractMLFeatures(finding: HuntFinding): number[] {
    return [
      finding.confidence,
      this.severityToNumber(finding.severity),
      finding.evidence.length,
      finding.relatedEntities.length,
      finding.type === 'anomaly' ? 1 : 0,
      finding.type === 'suspicious_pattern' ? 1 : 0,
      finding.type === 'iocs' ? 1 : 0,
      finding.type === 'behavioral_deviation' ? 1 : 0,
      Date.now() % 86400000 / 3600000, // Hour of day
      new Date().getDay(), // Day of week
      finding.recommendedActions.length,
      finding.title.length / 100, // Normalized title length
      finding.description.length / 500 // Normalized description length
    ];
  }

  /**
   * Predict threat level using ML model
   */
  private async predictThreatLevel(features: number[]): Promise<{
    threatLevel: string;
    confidence: number;
  }> {
    if (!this.huntingModel) {
      return { threatLevel: 'unknown', confidence: 0 };
    }

    try {
      const result = await tf.tidy(async () => {
        const inputTensor = tf.tensor2d([features]);
        const prediction = await this.huntingModel.predict(inputTensor) as tf.Tensor;
        const data = await prediction.data();
        return Array.from(data) as number[];
      });

      const maxIndex = result.indexOf(Math.max(...result));
      const threatLevels = ['low', 'medium', 'high', 'critical'];

      return {
        threatLevel: threatLevels[maxIndex],
        confidence: result[maxIndex]
      };
    } catch (error) {
      logger.error('Failed to predict threat level:', { error });
      return { threatLevel: 'unknown', confidence: 0 };
    }
  }

  /**
   * Store hunt result in database
   */
  private async storeHuntResult(result: HuntResult): Promise<void> {
    try {
      const db = this.mongoClient.db('threat_detection');
      await db.collection('hunt_results').insertOne(result);
    } catch (error) {
      logger.error('Failed to store hunt result:', { error, huntId: result.huntId });
      throw error;
    }
  }

  /**
   * Calculate hunt confidence based on findings
   */
  private calculateHuntConfidence(findings: HuntFinding[]): number {
    if (findings.length === 0) {
      return 0;
    }

    const avgConfidence = findings.reduce((sum, f) => sum + f.confidence, 0) / findings.length;
    const findingCountBonus = Math.min(findings.length * 0.05, 0.2); // Bonus for multiple findings

    return Math.min(avgConfidence + findingCountBonus, 1.0);
  }

  /**
   * Determine hunt severity based on findings
   */
  private determineHuntSeverity(findings: HuntFinding[], ruleSeverity: string): HuntResult['severity'] {
    if (findings.length === 0) {
      return 'low';
    }

    const maxFindingSeverity = Math.max(...findings.map(f => this.severityToNumber(f.severity)));
    const ruleSeverityNum = this.severityToNumber(ruleSeverity);

    return this.numberToSeverity(Math.max(maxFindingSeverity, ruleSeverityNum));
  }

  /**
   * Determine if investigation should be triggered
   */
  private shouldTriggerInvestigation(findings: HuntFinding[], rule: HuntingRule): boolean {
    if (findings.length === 0) {
      return false;
    }

    const highSeverityFindings = findings.filter(f =>
      f.severity === 'high' || f.severity === 'critical'
    );

    return highSeverityFindings.length > 0 ||
      (findings.length > 3 && rule.autoInvestigate);
  }

  /**
   * Start investigation based on hunt results
   */
  async startInvestigation(params: {
    huntId?: string;
    threatId?: string;
    templateId?: string;
    priority?: number;
  }): Promise<string> {
    const investigationId = `investigation_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;

    try {
      logger.info('Starting investigation', { investigationId, ...params });

      // Select investigation template
      const template = this.selectInvestigationTemplate(params);

      // Create investigation
      const investigation: Investigation = {
        investigationId,
        huntId: params.huntId,
        threatId: params.threatId,
        templateId: template.templateId,
        status: 'pending',
        priority: this.mapPriority(params.priority || 1),
        steps: template.steps.map(step => ({
          stepId: step.stepId,
          name: step.name,
          status: 'pending',
          executionTime: 0,
          timestamp: new Date()
        })),
        findings: [],
        createdAt: new Date(),
        metadata: {
          templateName: template.name,
          estimatedDuration: template.estimatedDuration
        }
      };

      // Store investigation
      await this.storeInvestigation(investigation);

      // Add to active investigations
      this.activeInvestigations.set(investigationId, investigation);

      // Start investigation execution
      this.executeInvestigation(investigationId);

      this.emit('investigation_started', { investigationId });
      return investigationId;

    } catch (error) {
      logger.error('Failed to start investigation:', { error, investigationId });
      throw error;
    }
  }

  /**
   * Select appropriate investigation template
   */
  private selectInvestigationTemplate(params: {
    huntId?: string;
    threatId?: string;
    templateId?: string;
  }): InvestigationTemplate {
    if (params.templateId) {
      const template = this.config.investigationTemplates.find(t => t.templateId === params.templateId);
      if (template) {
        return template;
      }
    }

    // Default template selection based on context
    if (params.huntId) {
      return this.config.investigationTemplates.find(t => t.name.includes('Hunt')) ||
        this.config.investigationTemplates[0];
    }

    if (params.threatId) {
      return this.config.investigationTemplates.find(t => t.name.includes('Threat')) ||
        this.config.investigationTemplates[0];
    }

    return this.config.investigationTemplates[0];
  }

  /**
   * Execute investigation steps
   */
  private async executeInvestigation(investigationId: string): Promise<void> {
    const investigation = this.activeInvestigations.get(investigationId);
    if (!investigation) {
      logger.error('Investigation not found:', { investigationId });
      return;
    }

    try {
      investigation.status = 'running';
      investigation.startedAt = new Date();

      await this.updateInvestigation(investigation);

      logger.info('Executing investigation', { investigationId, steps: investigation.steps.length });

      for (const step of investigation.steps) {
        if (investigation.status === 'cancelled') {
          break;
        }

        try {
          step.status = 'running';
          step.timestamp = new Date();

          const startTime = Date.now();
          const result = await this.executeInvestigationStep(step, investigation);
          const executionTime = Date.now() - startTime;

          step.result = result;
          step.executionTime = executionTime;
          step.status = 'completed';

          // Process findings from step
          if (result && result.findings) {
            investigation.findings.push(...result.findings);
          }

        } catch (error) {
          step.status = 'failed';
          step.error = error.message;
          logger.error(`Investigation step failed: ${step.name}`, {
            error,
            investigationId,
            stepId: step.stepId
          });
        }

        step.timestamp = new Date();
        await this.updateInvestigation(investigation);
      }

      // Complete investigation
      investigation.status = 'completed';
      investigation.completedAt = new Date();

      await this.updateInvestigation(investigation);

      logger.info('Investigation completed', { investigationId, findings: investigation.findings.length });
      this.emit('investigation_completed', { investigationId });

    } catch (error) {
      investigation.status = 'failed';
      investigation.completedAt = new Date();
      await this.updateInvestigation(investigation);

      logger.error('Investigation execution failed:', { error, investigationId });
      this.emit('investigation_failed', { investigationId, error });
    }

    // Remove from active investigations
    this.activeInvestigations.delete(investigationId);
  }

  /**
   * Execute a single investigation step
   */
  private async executeInvestigationStep(
    step: InvestigationStepResult,
    investigation: Investigation
  ): Promise<{ findings?: InvestigationFinding[] }> {
    try {
      logger.info(`Executing investigation step: ${step.name}`, {
        investigationId: investigation.investigationId,
        stepId: step.stepId
      });

      // Get the actual step configuration
      const template = this.config.investigationTemplates.find(t =>
        t.steps.some(s => s.stepId === step.stepId)
      );

      const stepConfig = template?.steps.find(s => s.stepId === step.stepId);
      if (!stepConfig) {
        throw new Error(`Step configuration not found: ${step.stepId}`);
      }

      // Execute step based on action type
      switch (stepConfig.action) {
        case 'analyze_logs':
          return await this.analyzeLogs(stepConfig.parameters, investigation);

        case 'check_iocs':
          return await this.checkIOCs(stepConfig.parameters, investigation);

        case 'analyze_behavior':
          return await this.analyzeBehavior(stepConfig.parameters, investigation);

        case 'correlate_data':
          return await this.correlateData(stepConfig.parameters, investigation);

        case 'generate_report':
          return await this.generateReport(stepConfig.parameters, investigation);

        default:
          throw new Error(`Unknown investigation action: ${stepConfig.action}`);
      }
    } catch (error) {
      logger.error(`Failed to execute investigation step: ${step.name}`, {
        error,
        investigationId: investigation.investigationId,
        stepId: step.stepId
      });
      throw error;
    }
  }

  /**
   * Analyze logs for investigation
   */
  private async analyzeLogs(
    parameters: Record<string, unknown>,
    investigation: Investigation
  ): Promise<{ findings?: InvestigationFinding[] }> {
    const findings: InvestigationFinding[] = [];

    try {
      // Simulate log analysis
      const timeRange = parameters.timeRange as number || 3600000; // 1 hour default

      findings.push({
        findingId: `log_analysis_${Date.now()}`,
        stepId: 'analyze_logs',
        type: 'evidence',
        title: 'Log Analysis Completed',
        description: `Analyzed logs for the last ${timeRange / 1000} seconds`,
        data: {
          logEntries: 150,
          errorCount: 12,
          warningCount: 8,
          suspiciousPatterns: ['repeated_login_failures', 'unusual_api_calls']
        },
        confidence: 0.8,
        severity: 'medium',
        timestamp: new Date()
      });

      return { findings };
    } catch (error) {
      logger.error('Log analysis failed:', { error, investigationId: investigation.investigationId });
      throw error;
    }
  }

  /**
   * Check indicators of compromise
   */
  private async checkIOCs(
    parameters: Record<string, unknown>,
    investigation: Investigation
  ): Promise<{ findings?: InvestigationFinding[] }> {
    const findings: InvestigationFinding[] = [];

    try {
      // Simulate IOC checking
      const iocTypes = parameters.iocTypes as string[] || ['ip', 'domain', 'hash'];

      findings.push({
        findingId: `ioc_check_${Date.now()}`,
        stepId: 'check_iocs',
        type: 'indicator',
        title: 'IOC Analysis Results',
        description: `Checked ${iocTypes.length} types of indicators of compromise`,
        data: {
          checkedIOCs: 45,
          maliciousIOCs: 3,
          suspiciousIOCs: 8,
          cleanIOCs: 34,
          iocTypes: iocTypes
        },
        confidence: 0.9,
        severity: 'high',
        timestamp: new Date()
      });

      return { findings };
    } catch (error) {
      logger.error('IOC check failed:', { error, investigationId: investigation.investigationId });
      throw error;
    }
  }

  /**
   * Analyze behavioral patterns
   */
  private async analyzeBehavior(
    parameters: Record<string, unknown>,
    investigation: Investigation
  ): Promise<{ findings?: InvestigationFinding[] }> {
    const findings: InvestigationFinding[] = [];

    try {
      // Simulate behavioral analysis
      const userId = parameters.userId as string;
      const timeWindow = parameters.timeWindow as number || 86400000; // 24 hours

      findings.push({
        findingId: `behavior_analysis_${Date.now()}`,
        stepId: 'analyze_behavior',
        type: 'anomaly',
        title: 'Behavioral Analysis Results',
        description: `Analyzed behavioral patterns for user ${userId || 'all users'}`,
        data: {
          analyzedUsers: userId ? 1 : 150,
          anomalousBehaviors: 12,
          riskScore: 0.7,
          timeWindow: timeWindow,
          keyFindings: ['unusual_login_times', 'access_pattern_changes', 'geographic_anomalies']
        },
        confidence: 0.85,
        severity: 'medium',
        timestamp: new Date()
      });

      return { findings };
    } catch (error) {
      logger.error('Behavior analysis failed:', { error, investigationId: investigation.investigationId });
      throw error;
    }
  }

  /**
   * Correlate data from multiple sources
   */
  private async correlateData(
    parameters: Record<string, unknown>,
    investigation: Investigation
  ): Promise<{ findings?: InvestigationFinding[] }> {
    const findings: InvestigationFinding[] = [];

    try {
      // Simulate data correlation
      const dataSources = parameters.dataSources as string[] || ['logs', 'metrics', 'threats'];

      findings.push({
        findingId: `data_correlation_${Date.now()}`,
        stepId: 'correlate_data',
        type: 'conclusion',
        title: 'Data Correlation Analysis',
        description: 'Correlated data from multiple sources to identify patterns',
        data: {
          dataSources: dataSources,
          correlationsFound: 8,
          timelineEvents: 23,
          relatedEntities: ['user_123', 'ip_192.168.1.1', 'domain_suspicious.com'],
          confidenceScore: 0.82
        },
        confidence: 0.82,
        severity: 'medium',
        timestamp: new Date()
      });

      return { findings };
    } catch (error) {
      logger.error('Data correlation failed:', { error, investigationId: investigation.investigationId });
      throw error;
    }
  }

  /**
   * Generate investigation report
   */
  private async generateReport(
    parameters: Record<string, unknown>,
    investigation: Investigation
  ): Promise<{ findings?: InvestigationFinding[] }> {
    const findings: InvestigationFinding[] = [];

    try {
      // Generate comprehensive report
      const report = {
        investigationId: investigation.investigationId,
        totalFindings: investigation.findings.length,
        criticalFindings: investigation.findings.filter(f => f.severity === 'critical').length,
        highFindings: investigation.findings.filter(f => f.severity === 'high').length,
        executionTime: Date.now() - investigation.createdAt.getTime(),
        recommendations: this.generateRecommendations(investigation.findings)
      };

      findings.push({
        findingId: `investigation_report_${Date.now()}`,
        stepId: 'generate_report',
        type: 'conclusion',
        title: 'Investigation Report Generated',
        description: 'Comprehensive investigation report with findings and recommendations',
        data: report,
        confidence: 0.95,
        severity: 'medium',
        timestamp: new Date()
      });

      return { findings };
    } catch (error) {
      logger.error('Report generation failed:', { error, investigationId: investigation.investigationId });
      throw error;
    }
  }

  /**
   * Generate recommendations based on findings
   */
  private generateRecommendations(findings: InvestigationFinding[]): string[] {
    const recommendations = new Set<string>();

    for (const finding of findings) {
      if (finding.severity === 'critical') {
        recommendations.add('immediate_response_required');
        recommendations.add('escalate_to_security_team');
      }

      if (finding.severity === 'high') {
        recommendations.add('increase_monitoring');
        recommendations.add('review_security_controls');
      }

      if (finding.type === 'anomaly') {
        recommendations.add('investigate_anomaly_source');
      }

      if (finding.type === 'iocs') {
        recommendations.add('update_threat_intelligence');
        recommendations.add('block_malicious_indicators');
      }
    }

    return Array.from(recommendations);
  }

  /**
   * Store investigation in database
   */
  private async storeInvestigation(investigation: Investigation): Promise<void> {
    try {
      const db = this.mongoClient.db('threat_detection');
      await db.collection('investigations').insertOne(investigation);
    } catch (error) {
      logger.error('Failed to store investigation:', { error, investigationId: investigation.investigationId });
      throw error;
    }
  }

  /**
   * Update investigation in database
   */
  private async updateInvestigation(investigation: Investigation): Promise<void> {
    try {
      const db = this.mongoClient.db('threat_detection');
      await db.collection('investigations').updateOne(
        { investigationId: investigation.investigationId },
        { $set: investigation }
      );
    } catch (error) {
      logger.error('Failed to update investigation:', { error, investigationId: investigation.investigationId });
      throw error;
    }
  }

  /**
   * Get investigation by ID
   */
  async getInvestigation(investigationId: string): Promise<Investigation | null> {
    try {
      const db = this.mongoClient.db('threat_detection');
      const investigation = await db.collection('investigations').findOne({ investigationId });
      return investigation as Investigation | null;
    } catch (error) {
      logger.error('Failed to get investigation:', { error, investigationId });
      return null;
    }
  }

  /**
   * Get recent investigations
   */
  async getRecentInvestigations(limit: number = 50): Promise<Investigation[]> {
    try {
      const db = this.mongoClient.db('threat_detection');
      const investigations = await db.collection('investigations')
        .find({})
        .sort({ createdAt: -1 })
        .limit(limit)
        .toArray();

      return investigations as Investigation[];
    } catch (error) {
      logger.error('Failed to get recent investigations:', { error });
      return [];
    }
  }

  /**
   * Cancel investigation
   */
  async cancelInvestigation(investigationId: string): Promise<boolean> {
    try {
      const investigation = this.activeInvestigations.get(investigationId);
      if (!investigation) {
        return false;
      }

      investigation.status = 'cancelled';
      investigation.completedAt = new Date();

      await this.updateInvestigation(investigation);
      this.activeInvestigations.delete(investigationId);

      logger.info('Investigation cancelled', { investigationId });
      this.emit('investigation_cancelled', { investigationId });

      return true;
    } catch (error) {
      logger.error('Failed to cancel investigation:', { error, investigationId });
      return false;
    }
  }

  /**
   * Get hunting statistics
   */
  async getHuntingStatistics(): Promise<{
    totalHunts: number;
    huntsWithFindings: number;
    investigationsTriggered: number;
    criticalFindings: number;
    recentHunts: HuntResult[];
  }> {
    try {
      const db = this.mongoClient.db('threat_detection');

      const [totalHunts, huntsWithFindings, investigations, criticalFindings, recentHunts] = await Promise.all([
        db.collection('hunt_results').countDocuments(),
        db.collection('hunt_results').countDocuments({ 'findings.0': { $exists: true } }),
        db.collection('investigations').countDocuments(),
        db.collection('hunt_results').countDocuments({ 'findings.severity': 'critical' }),
        db.collection('hunt_results')
          .find({})
          .sort({ timestamp: -1 })
          .limit(10)
          .toArray()
      ]);

      return {
        totalHunts,
        huntsWithFindings,
        investigationsTriggered: investigations,
        criticalFindings,
        recentHunts: recentHunts as HuntResult[]
      };
    } catch (error) {
      logger.error('Failed to get hunting statistics:', { error });
      return {
        totalHunts: 0,
        huntsWithFindings: 0,
        investigationsTriggered: 0,
        criticalFindings: 0,
        recentHunts: []
      };
    }
  }

  // Helper methods
  private severityToNumber(severity: string): number {
    const map = { low: 1, medium: 2, high: 3, critical: 4 };
    return map[severity as keyof typeof map] || 1;
  }

  private numberToSeverity(num: number): HuntResult['severity'] {
    if (num >= 4) {
      return 'critical';
    }
    if (num >= 3) {
      return 'high';
    }
    if (num >= 2) {
      return 'medium';
    }
    return 'low';
  }

  private mapPriority(priority: number): Investigation['priority'] {
    if (priority >= 4) {
      return 'critical';
    }
    if (priority >= 3) {
      return 'high';
    }
    if (priority >= 2) {
      return 'medium';
    }
    return 'low';
  }

  private mapThreatLevelToSeverity(threatLevel: string): HuntFinding['severity'] {
    const map: Record<string, HuntFinding['severity']> = {
      'low': 'low',
      'medium': 'medium',
      'high': 'high',
      'critical': 'critical'
    };
    return map[threatLevel] || 'low';
  }

  async shutdown(): Promise<void> {
    try {
      await this.stopHunting();

      // Cancel active investigations
      for (const investigationId of this.activeInvestigations.keys()) {
        await this.cancelInvestigation(investigationId);
      }

      if (this.redis) {
        await this.redis.quit();
      }

      if (this.mongoClient) {
        await this.mongoClient.close();
      }

      logger.info('Threat hunting service shutdown completed');
      this.emit('hunting_shutdown');
    } catch (error) {
      logger.error('Failed to shutdown threat hunting service:', { error });
      throw error;
    }
  }
}

export type {
  ThreatHuntingConfig,
  HuntingRule,
  InvestigationTemplate,
  HuntResult,
  HuntFinding,
  Investigation,
  InvestigationFinding
};
