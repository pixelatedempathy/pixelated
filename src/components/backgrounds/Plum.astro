---
/**
 * Plum Background Component - Antfu Style Branching Animation
 * Creates animated plum branches for background decoration
 * Inspired by: https://github.com/antfu/antfu.me
 */
---

<bg-plum
  class="z--1 fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden"
>
</bg-plum>

<script type="module">
import p5 from 'p5'

/** @typedef {import('p5')} P5Instance */

  class BgPlumElement extends HTMLElement {
    /** @type {P5Instance | null} */
    p5Instance = null

    constructor() {
      super()
      this.p5Instance = null
    }

    connectedCallback() {
  /**
   * @param {import('p5')} p
   */
  const sketch = (p) => {
        const BACKGROUND = 'transparent'
        const BRANCH_COLOR = [136, 136, 136, 64] // Subtle gray with transparency
        const LINE_WIDTH = 1.5
        const STEP = 6
        const BRANCH_CHANCE = 0.05
        const BRANCH_ANGLE = Math.PI / 6
        const MAX_DEPTH = 8
        const SPEED = 0.3

        const width = window.innerWidth
        const height = window.innerHeight

  /**
   * @type {Array<{x: number, y: number, angle: number, depth: number, length: number, growing: boolean, opacity: number}>}
   */
  let branches = []

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} angle
   * @param {number} [depth=0]
   */
  function addBranch(x, y, angle, depth = 0) {
          if (depth > MAX_DEPTH) return
          
          branches.push({
            x,
            y,
            angle,
            depth,
            length: 0,
            growing: true,
            opacity: Math.max(0.1, 1 - depth * 0.15)
          })
        }

        function initBranches() {
          branches = []
          // Start with a few main branches from edges
          addBranch(0, height * 0.3, 0)
          addBranch(width, height * 0.7, Math.PI)
          addBranch(width * 0.2, 0, Math.PI / 2)
          addBranch(width * 0.8, height, -Math.PI / 2)
        }

        p.setup = () => {
          p.createCanvas(width, height)
          p.background(BACKGROUND)
          p.frameRate(30)
          initBranches()
        }

        p.draw = () => {
          p.background(BACKGROUND)
          
          // Update and draw branches
          for (let i = branches.length - 1; i >= 0; i--) {
            const branch = branches[i]
            
            if (branch.growing) {
              branch.length += SPEED
              
              // Draw the branch
              p.stroke(BRANCH_COLOR[0], BRANCH_COLOR[1], BRANCH_COLOR[2], BRANCH_COLOR[3] * branch.opacity)
              p.strokeWeight(LINE_WIDTH * (1 - branch.depth * 0.1))
              
              const endX = branch.x + Math.cos(branch.angle) * branch.length
              const endY = branch.y + Math.sin(branch.angle) * branch.length
              
              p.line(branch.x, branch.y, endX, endY)
              
              // Check if branch should stop growing
              if (branch.length > 50 + Math.random() * 100 || 
                  endX < 0 || endX > width || endY < 0 || endY > height) {
                branch.growing = false
              }
              
              // Chance to create new branches
              if (branch.length > 20 && Math.random() < BRANCH_CHANCE) {
                const newX = branch.x + Math.cos(branch.angle) * branch.length * 0.7
                const newY = branch.y + Math.sin(branch.angle) * branch.length * 0.7
                
                // Create two new branches at angles
                addBranch(newX, newY, branch.angle + BRANCH_ANGLE + (Math.random() - 0.5) * 0.5, branch.depth + 1)
                addBranch(newX, newY, branch.angle - BRANCH_ANGLE + (Math.random() - 0.5) * 0.5, branch.depth + 1)
              }
            } else {
              // Draw static branch
              p.stroke(BRANCH_COLOR[0], BRANCH_COLOR[1], BRANCH_COLOR[2], BRANCH_COLOR[3] * branch.opacity * 0.8)
              p.strokeWeight(LINE_WIDTH * (1 - branch.depth * 0.1))
              
              const endX = branch.x + Math.cos(branch.angle) * branch.length
              const endY = branch.y + Math.sin(branch.angle) * branch.length
              
              p.line(branch.x, branch.y, endX, endY)
            }
          }
          
          // Occasionally add new branches
          if (Math.random() < 0.002) {
            const side = Math.floor(Math.random() * 4)
            switch (side) {
              case 0: // top
                addBranch(Math.random() * width, 0, Math.PI / 2 + (Math.random() - 0.5) * 0.5)
                break
              case 1: // right
                addBranch(width, Math.random() * height, Math.PI + (Math.random() - 0.5) * 0.5)
                break
              case 2: // bottom
                addBranch(Math.random() * width, height, -Math.PI / 2 + (Math.random() - 0.5) * 0.5)
                break
              case 3: // left
                addBranch(0, Math.random() * height, (Math.random() - 0.5) * 0.5)
                break
            }
          }
          
          // Clean up old branches
          if (branches.length > 200) {
            branches = branches.filter(branch => branch.growing || Math.random() > 0.01)
          }
        }
      }

      this.p5Instance = new p5(sketch, this)
    }

    // Clean up when element is removed
    disconnectedCallback() {
      if (this.p5Instance) {
        this.p5Instance.remove()
        this.p5Instance = null
      }
    }
  }

  customElements.define('bg-plum', BgPlumElement)
</script>


