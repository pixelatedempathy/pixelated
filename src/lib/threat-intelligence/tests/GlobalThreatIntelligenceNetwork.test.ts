/**
 * Tests for Global Threat Intelligence Network
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { GlobalThreatIntelligenceNetworkCore } from '../global/GlobalThreatIntelligenceNetwork';
import { createBuildSafeLogger } from '../../logging/build-safe-logger';

// Mock dependencies
vi.mock('../../logging/build-safe-logger', () => ({
  createBuildSafeLogger: vi.fn(() => ({
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn()
  }))
}));

vi.mock('ioredis', () => {
  return {
    Redis: vi.fn().mockImplementation(() => ({
      ping: vi.fn().mockResolvedValue('PONG'),
      setex: vi.fn().mockResolvedValue('OK'),
      get: vi.fn().mockResolvedValue(null),
      del: vi.fn().mockResolvedValue(1),
      publish: vi.fn().mockResolvedValue(1),
      quit: vi.fn().mockResolvedValue('OK')
    }))
  };
});

vi.mock('mongodb', () => {
  return {
    MongoClient: vi.fn().mockImplementation(() => ({
      connect: vi.fn().mockResolvedValue(undefined),
      db: vi.fn().mockReturnValue({
        collection: vi.fn().mockReturnValue({
          insertOne: vi.fn().mockResolvedValue({ insertedId: 'test-id' }),
          updateOne: vi.fn().mockResolvedValue({ modifiedCount: 1 }),
          findOne: vi.fn().mockResolvedValue(null),
          find: vi.fn().mockReturnValue({
            toArray: vi.fn().mockResolvedValue([]),
            sort: vi.fn().mockReturnThis(),
            limit: vi.fn().mockReturnThis()
          }),
          aggregate: vi.fn().mockReturnValue({
            toArray: vi.fn().mockResolvedValue([])
          })
        }),
        admin: vi.fn().mockReturnValue({
          ping: vi.fn().mockResolvedValue(true)
        })
      }),
      close: vi.fn().mockResolvedValue(undefined)
    }))
  };
});

describe('GlobalThreatIntelligenceNetworkCore', () => {
  let network: GlobalThreatIntelligenceNetworkCore;
  let mockConfig: any;

  beforeEach(() => {
    mockConfig = {
      networkId: 'test-network',
      networkName: 'Test Network',
      regions: ['us-east-1', 'eu-west-1'],
      primaryRegion: 'us-east-1',
      failoverRegions: ['eu-west-1'],
      syncInterval: 30000,
      healthCheckInterval: 60000,
      maxSyncRetries: 3,
      threatSharingEnabled: true,
      realTimeProcessing: true,
      encryptionEnabled: true,
      compressionEnabled: true
    };

    process.env.MONGODB_URI = 'mongodb://localhost:27017/test';
    process.env.REDIS_URL = 'redis://localhost:6379';
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('Initialization', () => {
    it('should initialize successfully with valid configuration', async () => {
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      
      await expect(network.initialize()).resolves.not.toThrow();
      
      const logger = createBuildSafeLogger('global-threat-intelligence-network');
      expect(logger.info).toHaveBeenCalledWith('Initializing Global Threat Intelligence Network');
      expect(logger.info).toHaveBeenCalledWith('Global Threat Intelligence Network initialized successfully');
    });

    it('should handle initialization errors gracefully', async () => {
      const Redis = vi.fn().mockImplementation(() => ({
        ping: vi.fn().mockRejectedValue(new Error('Redis connection failed'))
      }));
      
      vi.doMock('ioredis', () => ({ Redis }));
      
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      
      await expect(network.initialize()).rejects.toThrow('Redis connection failed');
    });
  });

  describe('Threat Processing', () => {
    beforeEach(async () => {
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      await network.initialize();
    });

    it('should process threat intelligence successfully', async () => {
      const threatData = {
        threatId: 'threat-123',
        threatType: 'malware',
        severity: 'high',
        confidence: 0.8,
        indicators: [
          {
            indicatorType: 'ip',
            value: '192.168.1.1',
            confidence: 0.9,
            firstSeen: new Date(),
            lastSeen: new Date()
          }
        ],
        firstSeen: new Date(),
        lastSeen: new Date(),
        regions: ['us-east-1'],
        attribution: {
          family: 'test-family',
          campaign: 'test-campaign',
          confidence: 0.7
        },
        metadata: {
          source: 'test-source',
          processed: true
        }
      };

      const result = await network.processThreatIntelligence(threatData);
      
      expect(result).toBeDefined();
      expect(result.threatId).toBe('threat-123');
      expect(result.status).toBe('processed');
    });

    it('should validate threat data before processing', async () => {
      const invalidThreat = {
        threatId: '',
        threatType: '',
        severity: 'invalid',
        confidence: 1.5, // Invalid confidence
        indicators: []
      };

      await expect(network.processThreatIntelligence(invalidThreat)).rejects.toThrow();
    });

    it('should handle duplicate threats', async () => {
      const threatData = {
        threatId: 'duplicate-threat',
        threatType: 'malware',
        severity: 'high',
        confidence: 0.8,
        indicators: [{
          indicatorType: 'ip',
          value: '10.0.0.1',
          confidence: 0.9,
          firstSeen: new Date(),
          lastSeen: new Date()
        }],
        firstSeen: new Date(),
        lastSeen: new Date(),
        regions: ['us-east-1']
      };

      // Process first threat
      await network.processThreatIntelligence(threatData);
      
      // Process duplicate
      const result = await network.processThreatIntelligence(threatData);
      
      expect(result.status).toBe('duplicate');
    });
  });

  describe('Cross-Region Synchronization', () => {
    beforeEach(async () => {
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      await network.initialize();
    });

    it('should synchronize threats across regions', async () => {
      const threatData = {
        threatId: 'sync-threat-123',
        threatType: 'c2',
        severity: 'critical',
        confidence: 0.9,
        indicators: [{
          indicatorType: 'domain',
          value: 'malicious.com',
          confidence: 0.95,
          firstSeen: new Date(),
          lastSeen: new Date()
        }],
        firstSeen: new Date(),
        lastSeen: new Date(),
        regions: ['us-east-1', 'eu-west-1']
      };

      const result = await network.synchronizeThreat(threatData);
      
      expect(result).toBeDefined();
      expect(result.syncStatus).toBe('completed');
      expect(result.regionsSynced).toContain('us-east-1');
      expect(result.regionsSynced).toContain('eu-west-1');
    });

    it('should handle synchronization failures gracefully', async () => {
      const threatData = {
        threatId: 'sync-fail-threat',
        threatType: 'malware',
        severity: 'high',
        confidence: 0.8,
        indicators: [{
          indicatorType: 'ip',
          value: '192.168.1.100',
          confidence: 0.85,
          firstSeen: new Date(),
          lastSeen: new Date()
        }],
        firstSeen: new Date(),
        lastSeen: new Date(),
        regions: ['invalid-region']
      };

      await expect(network.synchronizeThreat(threatData)).rejects.toThrow();
    });
  });

  describe('Threat Correlation', () => {
    beforeEach(async () => {
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      await network.initialize();
    });

    it('should correlate related threats', async () => {
      const threats = [
        {
          threatId: 'threat-1',
          threatType: 'malware',
          severity: 'high',
          confidence: 0.8,
          indicators: [{
            indicatorType: 'ip',
            value: '192.168.1.10',
            confidence: 0.9,
            firstSeen: new Date(),
            lastSeen: new Date()
          }],
          firstSeen: new Date(),
          lastSeen: new Date(),
          regions: ['us-east-1']
        },
        {
          threatId: 'threat-2',
          threatType: 'malware',
          severity: 'high',
          confidence: 0.85,
          indicators: [{
            indicatorType: 'ip',
            value: '192.168.1.10', // Same IP
            confidence: 0.9,
            firstSeen: new Date(),
            lastSeen: new Date()
          }],
          firstSeen: new Date(),
          lastSeen: new Date(),
          regions: ['eu-west-1']
        }
      ];

      const correlations = await network.correlateThreats(threats);
      
      expect(correlations).toBeDefined();
      expect(correlations.length).toBeGreaterThan(0);
      expect(correlations[0].correlationType).toBe('shared_indicators');
    });

    it('should handle empty threat arrays', async () => {
      const correlations = await network.correlateThreats([]);
      
      expect(correlations).toBeDefined();
      expect(correlations.length).toBe(0);
    });
  });

  describe('Health Monitoring', () => {
    beforeEach(async () => {
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      await network.initialize();
    });

    it('should return healthy status when all systems are operational', async () => {
      const healthStatus = await network.getHealthStatus();
      
      expect(healthStatus.healthy).toBe(true);
      expect(healthStatus.message).toContain('healthy');
      expect(healthStatus.activeRegions).toBeGreaterThan(0);
    });

    it('should monitor threat processing metrics', async () => {
      const metrics = await network.getThreatMetrics();
      
      expect(metrics).toBeDefined();
      expect(metrics.totalThreats).toBeGreaterThanOrEqual(0);
      expect(metrics.threatsBySeverity).toBeDefined();
      expect(metrics.threatsByType).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    beforeEach(async () => {
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      await network.initialize();
    });

    it('should handle database connection errors gracefully', async () => {
      // Simulate database error
      
      
      // This would need to be properly mocked in the actual implementation
      // For now, we test the error handling structure
      
      const threatData = {
        threatId: 'error-threat',
        threatType: 'malware',
        severity: 'high',
        confidence: 0.8,
        indicators: [{
          indicatorType: 'ip',
          value: '192.168.1.200',
          confidence: 0.9,
          firstSeen: new Date(),
          lastSeen: new Date()
        }],
        firstSeen: new Date(),
        lastSeen: new Date(),
        regions: ['us-east-1']
      };

      // The actual error handling would be tested with proper mocking
      expect(async () => {
        await network.processThreatIntelligence(threatData);
      }).toBeDefined();
    });

    it('should handle invalid threat data with proper validation', async () => {
      const invalidThreats = [
        { threatId: null, threatType: 'malware' }, // Missing threatId
        { threatId: 'test', threatType: '' }, // Empty threatType
        { threatId: 'test', threatType: 'malware', severity: 'invalid' }, // Invalid severity
        { threatId: 'test', threatType: 'malware', confidence: 1.5 }, // Invalid confidence
        { threatId: 'test', threatType: 'malware', indicators: [] } // No indicators
      ];

      for (const invalidThreat of invalidThreats) {
        await expect(network.processThreatIntelligence(invalidThreat)).rejects.toThrow();
      }
    });
  });

  describe('Performance', () => {
    beforeEach(async () => {
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      await network.initialize();
    });

    it('should handle high-volume threat processing', async () => {
      const threats = Array.from({ length: 100 }, (_, i) => ({
        threatId: `bulk-threat-${i}`,
        threatType: 'malware',
        severity: i % 2 === 0 ? 'high' : 'medium',
        confidence: 0.7 + (i % 3) * 0.1,
        indicators: [{
          indicatorType: 'ip',
          value: `192.168.1.${i}`,
          confidence: 0.8,
          firstSeen: new Date(),
          lastSeen: new Date()
        }],
        firstSeen: new Date(),
        lastSeen: new Date(),
        regions: ['us-east-1']
      }));

      const startTime = Date.now();
      
      const results = await Promise.all(
        threats.map(threat => network.processThreatIntelligence(threat))
      );
      
      const endTime = Date.now();
      const processingTime = endTime - startTime;
      
      expect(results).toHaveLength(100);
      expect(processingTime).toBeLessThan(30000); // Should process 100 threats in under 30 seconds
      
      const successfulResults = results.filter(r => r.status === 'processed');
      expect(successfulResults.length).toBeGreaterThan(0);
    });

    it('should implement proper caching for repeated queries', async () => {
      const threatId = 'cache-test-threat';
      

      // First query - should hit database
      const result1 = await network.getThreatById(threatId);
      
      // Second query - should hit cache
      const result2 = await network.getThreatById(threatId);
      
      // Both should return the same result (or null if not found)
      expect(result1).toEqual(result2);
    });
  });

  describe('Event Emission', () => {
    beforeEach(async () => {
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      await network.initialize();
    });

    it('should emit events for threat processing', async () => {
      const eventHandler = vi.fn();
      network.on('threat_processed', eventHandler);

      const threatData = {
        threatId: 'event-test-threat',
        threatType: 'malware',
        severity: 'high',
        confidence: 0.8,
        indicators: [{
          indicatorType: 'ip',
          value: '192.168.1.75',
          confidence: 0.9,
          firstSeen: new Date(),
          lastSeen: new Date()
        }],
        firstSeen: new Date(),
        lastSeen: new Date(),
        regions: ['us-east-1']
      };

      await network.processThreatIntelligence(threatData);
      
      expect(eventHandler).toHaveBeenCalledWith({
        threatId: 'event-test-threat',
        status: 'processed',
        region: 'us-east-1'
      });
    });

    it('should emit events for synchronization', async () => {
      const eventHandler = vi.fn();
      network.on('threat_synchronized', eventHandler);

      const threatData = {
        threatId: 'sync-event-threat',
        threatType: 'c2',
        severity: 'critical',
        confidence: 0.9,
        indicators: [{
          indicatorType: 'domain',
          value: 'bad-domain.com',
          confidence: 0.95,
          firstSeen: new Date(),
          lastSeen: new Date()
        }],
        firstSeen: new Date(),
        lastSeen: new Date(),
        regions: ['us-east-1', 'eu-west-1']
      };

      await network.synchronizeThreat(threatData);
      
      expect(eventHandler).toHaveBeenCalled();
    });
  });

  describe('Shutdown', () => {
    beforeEach(async () => {
      network = new GlobalThreatIntelligenceNetworkCore(mockConfig);
      await network.initialize();
    });

    it('should shutdown gracefully', async () => {
      await expect(network.shutdown()).resolves.not.toThrow();
      
      const logger = createBuildSafeLogger('global-threat-intelligence-network');
      expect(logger.info).toHaveBeenCalledWith('Shutting down Global Threat Intelligence Network');
      expect(logger.info).toHaveBeenCalledWith('Global Threat Intelligence Network shutdown completed');
    });

    it('should handle shutdown errors gracefully', async () => {
      // Mock a shutdown error
      
      
      // This would need proper mocking in the actual implementation
      // For now, we test the error handling structure
      
      expect(async () => {
        await network.shutdown();
      }).toBeDefined();
    });
  });
});