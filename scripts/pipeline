#!/bin/bash
set -e

# Pixelated Empathy - CI/CD Pipeline Orchestration Script
# =======================================================

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="pixelated-empathy"
PIPELINE_CONFIG="scripts/cicd.config.json"
LOG_DIR="logs/pipeline"
ARTIFACTS_DIR="artifacts"

# Functions
log_info() {
    echo -e "${BLUE}[PIPELINE]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_stage() {
    echo -e "${PURPLE}[STAGE]${NC} $1"
}

setup_pipeline() {
    log_info "Setting up CI/CD pipeline environment..."
    
    # Create necessary directories
    mkdir -p "$LOG_DIR"
    mkdir -p "$ARTIFACTS_DIR"
    
    # Set pipeline environment variables
    export CI=true
    export PIPELINE_ID=$(date +%Y%m%d_%H%M%S)
    export PIPELINE_LOG="$LOG_DIR/pipeline_${PIPELINE_ID}.log"
    
    # Load configuration
    if [ ! -f "$PIPELINE_CONFIG" ]; then
        log_error "Pipeline configuration not found: $PIPELINE_CONFIG"
        exit 1
    fi
    
    log_success "Pipeline environment configured (ID: $PIPELINE_ID)"
}

run_code_quality_stage() {
    log_stage "Running Code Quality Stage"
    
    local start_time=$(date +%s)
    
    # ESLint
    log_info "Running ESLint..."
    if ./scripts/build --skip-tests --skip-lint; then
        log_success "Build check passed"
    else
        log_warning "Build check failed"
    fi
    
    # TypeScript check
    log_info "Running TypeScript check..."
    if command -v npm &> /dev/null && grep -q '"typecheck"' package.json; then
        npm run typecheck || log_warning "TypeScript check failed"
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    log_success "Code Quality Stage completed in ${duration}s"
}

run_security_stage() {
    log_stage "Running Security Stage"
    
    local start_time=$(date +%s)
    
    # Dependency audit
    log_info "Running dependency security audit..."
    if command -v npm &> /dev/null; then
        npm audit --audit-level=moderate || log_warning "Security vulnerabilities found"
    fi
    
    # Custom security tests
    if [ -d "tests/security" ]; then
        log_info "Running custom security tests..."
        ./scripts/test security || log_warning "Security tests failed"
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    log_success "Security Stage completed in ${duration}s"
}

run_test_stage() {
    log_stage "Running Test Stage"
    
    local start_time=$(date +%s)
    
    # Unit tests
    log_info "Running unit tests..."
    if ./scripts/test unit --coverage; then
        log_success "Unit tests passed"
    else
        log_error "Unit tests failed"
        return 1
    fi
    
    # Integration tests
    log_info "Running integration tests..."
    if ./scripts/test integration; then
        log_success "Integration tests passed"
    else
        log_warning "Integration tests failed"
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    log_success "Test Stage completed in ${duration}s"
}

run_build_stage() {
    log_stage "Running Build Stage"
    
    local start_time=$(date +%s)
    
    # Build application
    log_info "Building application..."
    if ./scripts/build --optimize --artifacts; then
        log_success "Application build successful"
    else
        log_error "Application build failed"
        return 1
    fi
    
    # Docker build (if Dockerfile exists)
    if [ -f "Dockerfile" ]; then
        log_info "Building Docker image..."
        docker build -t "$PROJECT_NAME:pipeline-$PIPELINE_ID" . || {
            log_warning "Docker build failed"
        }
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    log_success "Build Stage completed in ${duration}s"
}

run_e2e_stage() {
    log_stage "Running E2E Test Stage"
    
    local start_time=$(date +%s)
    
    # Start application for E2E tests
    log_info "Starting application for E2E tests..."
    if command -v npm &> /dev/null && grep -q '"start"' package.json; then
        npm start &
        local app_pid=$!
        sleep 30
        
        # Run E2E tests
        log_info "Running E2E tests..."
        if ./scripts/test e2e; then
            log_success "E2E tests passed"
        else
            log_warning "E2E tests failed"
        fi
        
        # Stop application
        kill $app_pid || true
    else
        log_info "No start script found, skipping E2E tests"
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    log_success "E2E Stage completed in ${duration}s"
}

run_deployment_stage() {
    log_stage "Running Deployment Stage"
    
    local environment=${1:-staging}
    local start_time=$(date +%s)
    
    log_info "Deploying to $environment environment..."
    
    # Create backup before deployment
    if [ "$environment" = "production" ]; then
        log_info "Creating deployment backup..."
        ./scripts/deployment-rollback.sh backup
    fi
    
    # Deploy application
    if ./scripts/deploy "$environment"; then
        log_success "Deployment to $environment successful"
    else
        log_error "Deployment to $environment failed"
        
        # Rollback on production failure
        if [ "$environment" = "production" ]; then
            log_info "Initiating rollback..."
            ./scripts/deployment-rollback.sh previous
        fi
        return 1
    fi
    
    # Health check
    log_info "Running post-deployment health checks..."
    sleep 30
    if ./scripts/deployment-health-check.sh detailed; then
        log_success "Health checks passed"
    else
        log_warning "Health checks failed"
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    log_success "Deployment Stage completed in ${duration}s"
}

generate_pipeline_report() {
    log_info "Generating pipeline report..."
    
    local report_file="$ARTIFACTS_DIR/pipeline-report-$PIPELINE_ID.json"
    local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    
    cat > "$report_file" << EOF
{
    "pipeline_id": "$PIPELINE_ID",
    "timestamp": "$timestamp",
    "project": "$PROJECT_NAME",
    "branch": "$(git branch --show-current 2>/dev/null || echo 'unknown')",
    "commit": "$(git rev-parse HEAD 2>/dev/null || echo 'unknown')",
    "stages": {
        "code_quality": "completed",
        "security": "completed",
        "tests": "completed",
        "build": "completed",
        "e2e": "completed",
        "deployment": "completed"
    },
    "artifacts": {
        "build_artifacts": "artifacts/",
        "test_reports": "test-results/",
        "logs": "$PIPELINE_LOG"
    }
}
EOF
    
    log_success "Pipeline report generated: $report_file"
}

cleanup_pipeline() {
    log_info "Cleaning up pipeline resources..."
    
    # Clean up temporary files
    rm -rf .tmp
    
    # Clean up old artifacts (keep last 10)
    if [ -d "$ARTIFACTS_DIR" ]; then
        ls -t "$ARTIFACTS_DIR"/pipeline-report-*.json | tail -n +11 | xargs rm -f || true
    fi
    
    # Clean up old logs (keep last 20)
    if [ -d "$LOG_DIR" ]; then
        ls -t "$LOG_DIR"/pipeline_*.log | tail -n +21 | xargs rm -f || true
    fi
    
    log_success "Pipeline cleanup completed"
}

show_help() {
    echo "Pixelated Empathy CI/CD Pipeline"
    echo ""
    echo "Usage: $0 [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  full [env]      Run full pipeline (default: staging)"
    echo "  quality         Run code quality checks only"
    echo "  security        Run security scans only"
    echo "  test            Run test suite only"
    echo "  build           Run build stage only"
    echo "  e2e             Run E2E tests only"
    echo "  deploy [env]    Run deployment only"
    echo "  report          Generate pipeline report"
    echo "  cleanup         Clean up pipeline artifacts"
    echo "  help            Show this help message"
    echo ""
    echo "Environments:"
    echo "  staging         Deploy to staging environment"
    echo "  production      Deploy to production environment"
    echo ""
    echo "Examples:"
    echo "  $0 full                    # Run full pipeline to staging"
    echo "  $0 full production         # Run full pipeline to production"
    echo "  $0 test                    # Run tests only"
    echo "  $0 deploy production       # Deploy to production only"
}

# Main pipeline execution
main() {
    local command=${1:-full}
    local environment=${2:-staging}
    
    setup_pipeline
    
    case $command in
        "full")
            log_info "Starting full CI/CD pipeline to $environment"
            run_code_quality_stage
            run_security_stage
            run_test_stage
            run_build_stage
            run_e2e_stage
            run_deployment_stage "$environment"
            generate_pipeline_report
            cleanup_pipeline
            ;;
        "quality")
            run_code_quality_stage
            ;;
        "security")
            run_security_stage
            ;;
        "test")
            run_test_stage
            ;;
        "build")
            run_build_stage
            ;;
        "e2e")
            run_e2e_stage
            ;;
        "deploy")
            run_deployment_stage "$environment"
            ;;
        "report")
            generate_pipeline_report
            ;;
        "cleanup")
            cleanup_pipeline
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            log_error "Unknown command: $command"
            show_help
            exit 1
            ;;
    esac
    
    log_success "Pipeline execution completed!"
}

# Run main function with all arguments
main "$@"
