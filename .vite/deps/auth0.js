import {
  __export
} from "./chunk-PLDDJCW6.js";

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/index.mjs
var api_exports = {};
__export(api_exports, {
  ActionBindingRefTypeEnum: () => ActionBindingRefTypeEnum,
  ActionBindingTypeEnum: () => ActionBindingTypeEnum,
  ActionBuildStatusEnum: () => ActionBuildStatusEnum,
  ActionExecutionStatusEnum: () => ActionExecutionStatusEnum,
  ActionVersionBuildStatusEnum: () => ActionVersionBuildStatusEnum,
  AculContextEnum: () => AculContextEnum,
  AculMatchTypeEnum: () => AculMatchTypeEnum,
  AculRenderingModeEnum: () => AculRenderingModeEnum,
  AsyncApprovalNotificationsChannelsEnum: () => AsyncApprovalNotificationsChannelsEnum,
  AttackProtectionCaptchaProviderId: () => AttackProtectionCaptchaProviderId,
  AuthenticationMethodTypeEnum: () => AuthenticationMethodTypeEnum,
  AuthenticationTypeEnum: () => AuthenticationTypeEnum,
  BadRequestError: () => BadRequestError,
  BotDetectionChallengePolicyPasswordFlowEnum: () => BotDetectionChallengePolicyPasswordFlowEnum,
  BotDetectionChallengePolicyPasswordResetFlowEnum: () => BotDetectionChallengePolicyPasswordResetFlowEnum,
  BotDetectionChallengePolicyPasswordlessFlowEnum: () => BotDetectionChallengePolicyPasswordlessFlowEnum,
  BotDetectionLevelEnum: () => BotDetectionLevelEnum,
  BrandingThemeBordersButtonsStyleEnum: () => BrandingThemeBordersButtonsStyleEnum,
  BrandingThemeBordersInputsStyleEnum: () => BrandingThemeBordersInputsStyleEnum,
  BrandingThemeColorsCaptchaWidgetThemeEnum: () => BrandingThemeColorsCaptchaWidgetThemeEnum,
  BrandingThemeFontLinksStyleEnum: () => BrandingThemeFontLinksStyleEnum,
  BrandingThemePageBackgroundPageLayoutEnum: () => BrandingThemePageBackgroundPageLayoutEnum,
  BrandingThemeWidgetHeaderTextAlignmentEnum: () => BrandingThemeWidgetHeaderTextAlignmentEnum,
  BrandingThemeWidgetLogoPositionEnum: () => BrandingThemeWidgetLogoPositionEnum,
  BrandingThemeWidgetSocialButtonsLayoutEnum: () => BrandingThemeWidgetSocialButtonsLayoutEnum,
  BreachedPasswordDetectionAdminNotificationFrequencyEnum: () => BreachedPasswordDetectionAdminNotificationFrequencyEnum,
  BreachedPasswordDetectionMethodEnum: () => BreachedPasswordDetectionMethodEnum,
  BreachedPasswordDetectionPreChangePasswordShieldsEnum: () => BreachedPasswordDetectionPreChangePasswordShieldsEnum,
  BreachedPasswordDetectionPreUserRegistrationShieldsEnum: () => BreachedPasswordDetectionPreUserRegistrationShieldsEnum,
  BreachedPasswordDetectionShieldsEnum: () => BreachedPasswordDetectionShieldsEnum,
  ClientAppTypeEnum: () => ClientAppTypeEnum,
  ClientComplianceLevelEnum: () => ClientComplianceLevelEnum,
  ClientCredentialAlgorithmEnum: () => ClientCredentialAlgorithmEnum,
  ClientCredentialTypeEnum: () => ClientCredentialTypeEnum,
  ClientGrantOrganizationNullableUsageEnum: () => ClientGrantOrganizationNullableUsageEnum,
  ClientGrantOrganizationUsageEnum: () => ClientGrantOrganizationUsageEnum,
  ClientGrantSubjectTypeEnum: () => ClientGrantSubjectTypeEnum,
  ClientOidcBackchannelLogoutInitiatorsEnum: () => ClientOidcBackchannelLogoutInitiatorsEnum,
  ClientOidcBackchannelLogoutInitiatorsModeEnum: () => ClientOidcBackchannelLogoutInitiatorsModeEnum,
  ClientOrganizationDiscoveryEnum: () => ClientOrganizationDiscoveryEnum,
  ClientOrganizationRequireBehaviorEnum: () => ClientOrganizationRequireBehaviorEnum,
  ClientOrganizationRequireBehaviorPatchEnum: () => ClientOrganizationRequireBehaviorPatchEnum,
  ClientOrganizationUsageEnum: () => ClientOrganizationUsageEnum,
  ClientOrganizationUsagePatchEnum: () => ClientOrganizationUsagePatchEnum,
  ClientSessionTransferAllowedAuthenticationMethodsEnum: () => ClientSessionTransferAllowedAuthenticationMethodsEnum,
  ClientSessionTransferDeviceBindingEnum: () => ClientSessionTransferDeviceBindingEnum,
  ClientTokenEndpointAuthMethodEnum: () => ClientTokenEndpointAuthMethodEnum,
  ClientTokenEndpointAuthMethodOrNullEnum: () => ClientTokenEndpointAuthMethodOrNullEnum,
  ConflictError: () => ConflictError,
  ConnectionConnectionSettingsPkceEnum: () => ConnectionConnectionSettingsPkceEnum,
  ConnectionIdTokenSignedResponseAlgEnum: () => ConnectionIdTokenSignedResponseAlgEnum,
  ConnectionIdentifierPrecedenceEnum: () => ConnectionIdentifierPrecedenceEnum,
  ConnectionIdentityApiEnumAzureAd: () => ConnectionIdentityApiEnumAzureAd,
  ConnectionIdentityProviderEnum: () => ConnectionIdentityProviderEnum,
  ConnectionKeyUseEnum: () => ConnectionKeyUseEnum,
  ConnectionMappingModeEnumOidc: () => ConnectionMappingModeEnumOidc,
  ConnectionMappingModeEnumOkta: () => ConnectionMappingModeEnumOkta,
  ConnectionPasskeyChallengeUiEnum: () => ConnectionPasskeyChallengeUiEnum,
  ConnectionPasswordPolicyEnum: () => ConnectionPasswordPolicyEnum,
  ConnectionProfileOrganizationAssignMembershipOnLoginEnum: () => ConnectionProfileOrganizationAssignMembershipOnLoginEnum,
  ConnectionProfileOrganizationShowAsButtonEnum: () => ConnectionProfileOrganizationShowAsButtonEnum,
  ConnectionSetUserRootAttributesEnum: () => ConnectionSetUserRootAttributesEnum,
  ConnectionShouldTrustEmailVerifiedConnectionEnum: () => ConnectionShouldTrustEmailVerifiedConnectionEnum,
  ConnectionStrategyEnum: () => ConnectionStrategyEnum,
  ConnectionTokenEndpointAuthMethodEnum: () => ConnectionTokenEndpointAuthMethodEnum,
  ConnectionTokenEndpointAuthSigningAlgEnum: () => ConnectionTokenEndpointAuthSigningAlgEnum,
  ConnectionTypeEnumOidc: () => ConnectionTypeEnumOidc,
  ConnectionUpstreamAliasEnum: () => ConnectionUpstreamAliasEnum,
  ConnectionUseridAttributeEnumAzureAd: () => ConnectionUseridAttributeEnumAzureAd,
  ConnectionWaadProtocolEnumAzureAd: () => ConnectionWaadProtocolEnumAzureAd,
  ContentTooLargeError: () => ContentTooLargeError,
  CreateEncryptionKeyType: () => CreateEncryptionKeyType,
  CreatedAuthenticationMethodTypeEnum: () => CreatedAuthenticationMethodTypeEnum,
  CreatedUserAuthenticationMethodTypeEnum: () => CreatedUserAuthenticationMethodTypeEnum,
  CustomDomainCustomClientIpHeaderEnum: () => CustomDomainCustomClientIpHeaderEnum,
  CustomDomainProvisioningTypeEnum: () => CustomDomainProvisioningTypeEnum,
  CustomDomainStatusFilterEnum: () => CustomDomainStatusFilterEnum,
  CustomDomainTypeEnum: () => CustomDomainTypeEnum,
  CustomProviderDeliveryMethodEnum: () => CustomProviderDeliveryMethodEnum,
  CustomSigningKeyAlgorithmEnum: () => CustomSigningKeyAlgorithmEnum,
  CustomSigningKeyCurveEnum: () => CustomSigningKeyCurveEnum,
  CustomSigningKeyTypeEnum: () => CustomSigningKeyTypeEnum,
  DeviceCredentialTypeEnum: () => DeviceCredentialTypeEnum,
  DomainCertificateAuthorityEnum: () => DomainCertificateAuthorityEnum,
  DomainCertificateStatusEnum: () => DomainCertificateStatusEnum,
  DomainVerificationMethodNameEnum: () => DomainVerificationMethodNameEnum,
  DomainVerificationStatusEnum: () => DomainVerificationStatusEnum,
  EmailProviderNameEnum: () => EmailProviderNameEnum,
  EmailTemplateNameEnum: () => EmailTemplateNameEnum,
  EnabledFeaturesEnum: () => EnabledFeaturesEnum,
  EncryptionKeyState: () => EncryptionKeyState,
  EncryptionKeyType: () => EncryptionKeyType,
  EventStreamDeliveryEventTypeEnum: () => EventStreamDeliveryEventTypeEnum,
  EventStreamEventBridgeAwsRegionEnum: () => EventStreamEventBridgeAwsRegionEnum,
  EventStreamEventTypeEnum: () => EventStreamEventTypeEnum,
  EventStreamStatusEnum: () => EventStreamStatusEnum,
  EventStreamTestEventTypeEnum: () => EventStreamTestEventTypeEnum,
  FlowActionAuth0SendRequestParams: () => FlowActionAuth0SendRequestParams,
  FlowActionFlowDelayFlowParams: () => FlowActionFlowDelayFlowParams,
  FlowActionHttpSendRequestParams: () => FlowActionHttpSendRequestParams,
  FlowActionSalesforceSearchLeadsParams: () => FlowActionSalesforceSearchLeadsParams,
  FlowActionSlackPostMessageParamsAttachment: () => FlowActionSlackPostMessageParamsAttachment,
  FlowActionWhatsappSendMessageParams: () => FlowActionWhatsappSendMessageParams,
  FlowActionZapierTriggerWebhookParams: () => FlowActionZapierTriggerWebhookParams,
  FlowsVaultConnectioSetupJwtAlgorithmEnum: () => FlowsVaultConnectioSetupJwtAlgorithmEnum,
  ForbiddenError: () => ForbiddenError,
  FormBlockImageConfigPositionEnum: () => FormBlockImageConfigPositionEnum,
  FormBlockResendButtonConfigTextAlignmentEnum: () => FormBlockResendButtonConfigTextAlignmentEnum,
  FormFieldDateConfigFormatEnum: () => FormFieldDateConfigFormatEnum,
  FormFieldFileConfigCategoryEnum: () => FormFieldFileConfigCategoryEnum,
  FormFieldFileConfigStorageTypeEnum: () => FormFieldFileConfigStorageTypeEnum,
  FormFieldPasswordConfigHashEnum: () => FormFieldPasswordConfigHashEnum,
  FormFieldPaymentConfigChargeOneOffCurrencyEnum: () => FormFieldPaymentConfigChargeOneOffCurrencyEnum,
  FormsRequestParametersHydrateEnum: () => FormsRequestParametersHydrateEnum,
  GetBruteForceSettingsResponseContent: () => GetBruteForceSettingsResponseContent,
  GetFlowRequestParametersHydrateEnum: () => GetFlowRequestParametersHydrateEnum,
  GuardianEnrollmentFactorEnum: () => GuardianEnrollmentFactorEnum,
  GuardianEnrollmentStatus: () => GuardianEnrollmentStatus,
  GuardianFactorNameEnum: () => GuardianFactorNameEnum,
  GuardianFactorPhoneFactorMessageTypeEnum: () => GuardianFactorPhoneFactorMessageTypeEnum,
  GuardianFactorsProviderPushNotificationProviderDataEnum: () => GuardianFactorsProviderPushNotificationProviderDataEnum,
  GuardianFactorsProviderSmsProviderEnum: () => GuardianFactorsProviderSmsProviderEnum,
  HookTriggerIdEnum: () => HookTriggerIdEnum,
  IdentityProviderEnum: () => IdentityProviderEnum,
  IntegrationFeatureTypeEnum: () => IntegrationFeatureTypeEnum,
  IntegrationRequiredParamTypeEnum: () => IntegrationRequiredParamTypeEnum,
  InternalServerError: () => InternalServerError,
  JobFileFormatEnum: () => JobFileFormatEnum,
  LogStreamDatadogRegionEnum: () => LogStreamDatadogRegionEnum,
  LogStreamEventBridgeSinkRegionEnum: () => LogStreamEventBridgeSinkRegionEnum,
  LogStreamEventGridRegionEnum: () => LogStreamEventGridRegionEnum,
  LogStreamFilterGroupNameEnum: () => LogStreamFilterGroupNameEnum,
  LogStreamHttpContentFormatEnum: () => LogStreamHttpContentFormatEnum,
  LogStreamMixpanelRegionEnum: () => LogStreamMixpanelRegionEnum,
  LogStreamPiiLogFieldsEnum: () => LogStreamPiiLogFieldsEnum,
  LogStreamPiiMethodEnum: () => LogStreamPiiMethodEnum,
  LogStreamStatusEnum: () => LogStreamStatusEnum,
  MfaPolicyEnum: () => MfaPolicyEnum,
  NetworkAclRuleScopeEnum: () => NetworkAclRuleScopeEnum,
  NotFoundError: () => NotFoundError,
  OauthScope: () => OauthScope,
  OrganizationDiscoveryDomainStatus: () => OrganizationDiscoveryDomainStatus,
  OrganizationUsageEnum: () => OrganizationUsageEnum,
  PartialGroupsEnum: () => PartialGroupsEnum,
  PaymentRequiredError: () => PaymentRequiredError,
  PhoneProviderDeliveryMethodEnum: () => PhoneProviderDeliveryMethodEnum,
  PhoneProviderNameEnum: () => PhoneProviderNameEnum,
  PhoneTemplateNotificationTypeEnum: () => PhoneTemplateNotificationTypeEnum,
  PreferredAuthenticationMethodEnum: () => PreferredAuthenticationMethodEnum,
  PromptGroupNameEnum: () => PromptGroupNameEnum,
  PromptLanguageEnum: () => PromptLanguageEnum,
  PublicKeyCredentialAlgorithmEnum: () => PublicKeyCredentialAlgorithmEnum,
  RefreshTokenExpirationTypeEnum: () => RefreshTokenExpirationTypeEnum,
  RefreshTokenRotationTypeEnum: () => RefreshTokenRotationTypeEnum,
  ResourceServerProofOfPossessionMechanismEnum: () => ResourceServerProofOfPossessionMechanismEnum,
  ResourceServerSubjectTypeAuthorizationClientPolicyEnum: () => ResourceServerSubjectTypeAuthorizationClientPolicyEnum,
  ResourceServerSubjectTypeAuthorizationUserPolicyEnum: () => ResourceServerSubjectTypeAuthorizationUserPolicyEnum,
  ResourceServerTokenDialectResponseEnum: () => ResourceServerTokenDialectResponseEnum,
  ResourceServerTokenDialectSchemaEnum: () => ResourceServerTokenDialectSchemaEnum,
  ResourceServerTokenEncryptionAlgorithmEnum: () => ResourceServerTokenEncryptionAlgorithmEnum,
  RotateConnectionKeysSigningAlgEnum: () => RotateConnectionKeysSigningAlgEnum,
  ScreenGroupNameEnum: () => ScreenGroupNameEnum,
  SearchEngineVersionsEnum: () => SearchEngineVersionsEnum,
  SelfServiceProfileAllowedStrategyEnum: () => SelfServiceProfileAllowedStrategyEnum,
  SelfServiceProfileSsoTicketDomainVerificationEnum: () => SelfServiceProfileSsoTicketDomainVerificationEnum,
  SelfServiceProfileSsoTicketIdpInitiatedClientProtocolEnum: () => SelfServiceProfileSsoTicketIdpInitiatedClientProtocolEnum,
  SelfServiceProfileSsoTicketProvisioningScopeEnum: () => SelfServiceProfileSsoTicketProvisioningScopeEnum,
  ServiceUnavailableError: () => ServiceUnavailableError,
  SessionCookieMetadataModeEnum: () => SessionCookieMetadataModeEnum,
  SessionCookieModeEnum: () => SessionCookieModeEnum,
  SigningAlgorithmEnum: () => SigningAlgorithmEnum,
  SignupStatusEnum: () => SignupStatusEnum,
  SupportedLocales: () => SupportedLocales,
  SuspiciousIpThrottlingShieldsEnum: () => SuspiciousIpThrottlingShieldsEnum,
  TenantSettingsDeviceFlowCharset: () => TenantSettingsDeviceFlowCharset,
  TenantSettingsResourceParameterProfile: () => TenantSettingsResourceParameterProfile,
  TooManyRequestsError: () => TooManyRequestsError,
  TwilioProviderDeliveryMethodEnum: () => TwilioProviderDeliveryMethodEnum,
  UnauthorizedError: () => UnauthorizedError,
  UniversalLoginExperienceEnum: () => UniversalLoginExperienceEnum,
  UpdateBruteForceSettingsRequestContent: () => UpdateBruteForceSettingsRequestContent,
  UpdateBruteForceSettingsResponseContent: () => UpdateBruteForceSettingsResponseContent,
  UpdateTenantSettingsRequestContent: () => UpdateTenantSettingsRequestContent,
  UserAttributeProfileUserIdOidcStrategyOverrideMapping: () => UserAttributeProfileUserIdOidcStrategyOverrideMapping,
  UserAuthenticationMethodPropertiesEnum: () => UserAuthenticationMethodPropertiesEnum,
  UserEnrollmentAuthMethodEnum: () => UserEnrollmentAuthMethodEnum,
  UserEnrollmentStatusEnum: () => UserEnrollmentStatusEnum,
  UserIdentityProviderEnum: () => UserIdentityProviderEnum,
  UserMultifactorProviderEnum: () => UserMultifactorProviderEnum,
  VerificationMethodEnum: () => VerificationMethodEnum,
  actions: () => actions_exports,
  anomaly: () => anomaly_exports,
  attackProtection: () => attackProtection_exports,
  branding: () => branding_exports,
  clientGrants: () => clientGrants_exports,
  clients: () => clients_exports,
  connectionProfiles: () => connectionProfiles_exports,
  connections: () => connections_exports2,
  customDomains: () => customDomains_exports,
  deviceCredentials: () => deviceCredentials_exports,
  emailTemplates: () => emailTemplates_exports,
  emails: () => emails_exports,
  eventStreams: () => eventStreams_exports,
  flows: () => flows_exports,
  forms: () => forms_exports,
  guardian: () => guardian_exports,
  hooks: () => hooks_exports,
  jobs: () => jobs_exports,
  keys: () => keys_exports2,
  logStreams: () => logStreams_exports,
  logs: () => logs_exports,
  networkAcls: () => networkAcls_exports,
  organizations: () => organizations_exports2,
  prompts: () => prompts_exports,
  refreshTokens: () => refreshTokens_exports,
  resourceServers: () => resourceServers_exports,
  riskAssessments: () => riskAssessments_exports,
  roles: () => roles_exports2,
  rules: () => rules_exports,
  rulesConfigs: () => rulesConfigs_exports,
  selfServiceProfiles: () => selfServiceProfiles_exports,
  sessions: () => sessions_exports,
  stats: () => stats_exports,
  supplementalSignals: () => supplementalSignals_exports,
  tenants: () => tenants_exports,
  tickets: () => tickets_exports,
  tokenExchangeProfiles: () => tokenExchangeProfiles_exports,
  userAttributeProfiles: () => userAttributeProfiles_exports,
  userBlocks: () => userBlocks_exports,
  userGrants: () => userGrants_exports,
  users: () => users_exports3,
  verifiableCredentials: () => verifiableCredentials_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/json.mjs
var toJson = (value, replacer, space) => {
  return JSON.stringify(value, replacer, space);
};
function fromJson(text, reviver) {
  return JSON.parse(text, reviver);
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/errors/ManagementError.mjs
var ManagementError = class extends Error {
  constructor({ message: message2, statusCode, body, rawResponse }) {
    super(buildMessage({ message: message2, statusCode, body }));
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.body = body;
    this.rawResponse = rawResponse;
  }
};
function buildMessage({ message: message2, statusCode, body }) {
  let lines = [];
  if (message2 != null) {
    lines.push(message2);
  }
  if (statusCode != null) {
    lines.push(`Status code: ${statusCode.toString()}`);
  }
  if (body != null) {
    lines.push(`Body: ${toJson(body, void 0, 2)}`);
  }
  return lines.join("\n");
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/errors/ManagementTimeoutError.mjs
var ManagementTimeoutError = class extends Error {
  constructor(message2) {
    super(message2);
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/BadRequestError.mjs
var BadRequestError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "BadRequestError",
      statusCode: 400,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/ConflictError.mjs
var ConflictError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "ConflictError",
      statusCode: 409,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/ContentTooLargeError.mjs
var ContentTooLargeError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "ContentTooLargeError",
      statusCode: 413,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/ForbiddenError.mjs
var ForbiddenError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "ForbiddenError",
      statusCode: 403,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/InternalServerError.mjs
var InternalServerError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "InternalServerError",
      statusCode: 500,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/NotFoundError.mjs
var NotFoundError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "NotFoundError",
      statusCode: 404,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/PaymentRequiredError.mjs
var PaymentRequiredError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "PaymentRequiredError",
      statusCode: 402,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/ServiceUnavailableError.mjs
var ServiceUnavailableError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "ServiceUnavailableError",
      statusCode: 503,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/TooManyRequestsError.mjs
var TooManyRequestsError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "TooManyRequestsError",
      statusCode: 429,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/errors/UnauthorizedError.mjs
var UnauthorizedError = class extends ManagementError {
  constructor(body, rawResponse) {
    super({
      message: "UnauthorizedError",
      statusCode: 401,
      body,
      rawResponse
    });
    Object.setPrototypeOf(this, new.target.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = this.constructor.name;
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/requests/requests.mjs
var UpdateBruteForceSettingsRequestContent;
(function(UpdateBruteForceSettingsRequestContent2) {
  let Shields;
  (function(Shields2) {
    Shields2.Item = {
      Block: "block",
      UserNotification: "user_notification"
    };
  })(Shields = UpdateBruteForceSettingsRequestContent2.Shields || (UpdateBruteForceSettingsRequestContent2.Shields = {}));
  UpdateBruteForceSettingsRequestContent2.Mode = {
    CountPerIdentifierAndIp: "count_per_identifier_and_ip",
    CountPerIdentifier: "count_per_identifier"
  };
})(UpdateBruteForceSettingsRequestContent || (UpdateBruteForceSettingsRequestContent = {}));
var UpdateTenantSettingsRequestContent;
(function(UpdateTenantSettingsRequestContent2) {
  let EnabledLocales;
  (function(EnabledLocales2) {
    EnabledLocales2.Item = {
      Am: "am",
      Ar: "ar",
      ArEg: "ar-EG",
      ArSa: "ar-SA",
      Az: "az",
      Bg: "bg",
      Bn: "bn",
      Bs: "bs",
      CaEs: "ca-ES",
      Cnr: "cnr",
      Cs: "cs",
      Cy: "cy",
      Da: "da",
      De: "de",
      El: "el",
      En: "en",
      EnCa: "en-CA",
      Es: "es",
      Es419: "es-419",
      EsAr: "es-AR",
      EsMx: "es-MX",
      Et: "et",
      EuEs: "eu-ES",
      Fa: "fa",
      Fi: "fi",
      Fr: "fr",
      FrCa: "fr-CA",
      FrFr: "fr-FR",
      GlEs: "gl-ES",
      Gu: "gu",
      He: "he",
      Hi: "hi",
      Hr: "hr",
      Hu: "hu",
      Hy: "hy",
      Id: "id",
      Is: "is",
      It: "it",
      Ja: "ja",
      Ka: "ka",
      Kk: "kk",
      Kn: "kn",
      Ko: "ko",
      Lt: "lt",
      Lv: "lv",
      Mk: "mk",
      Ml: "ml",
      Mn: "mn",
      Mr: "mr",
      Ms: "ms",
      My: "my",
      Nb: "nb",
      Nl: "nl",
      Nn: "nn",
      No: "no",
      Pa: "pa",
      Pl: "pl",
      Pt: "pt",
      PtBr: "pt-BR",
      PtPt: "pt-PT",
      Ro: "ro",
      Ru: "ru",
      Sk: "sk",
      Sl: "sl",
      So: "so",
      Sq: "sq",
      Sr: "sr",
      Sv: "sv",
      Sw: "sw",
      Ta: "ta",
      Te: "te",
      Th: "th",
      Tl: "tl",
      Tr: "tr",
      Uk: "uk",
      Ur: "ur",
      Vi: "vi",
      Zgh: "zgh",
      ZhCn: "zh-CN",
      ZhHk: "zh-HK",
      ZhTw: "zh-TW"
    };
  })(EnabledLocales = UpdateTenantSettingsRequestContent2.EnabledLocales || (UpdateTenantSettingsRequestContent2.EnabledLocales = {}));
})(UpdateTenantSettingsRequestContent || (UpdateTenantSettingsRequestContent = {}));

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/index.mjs
var actions_exports = {};
__export(actions_exports, {
  executions: () => executions_exports,
  triggers: () => triggers_exports,
  versions: () => versions_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/resources/executions/index.mjs
var executions_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/resources/triggers/index.mjs
var triggers_exports = {};
__export(triggers_exports, {
  bindings: () => bindings_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/resources/triggers/resources/bindings/index.mjs
var bindings_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/resources/versions/index.mjs
var versions_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/anomaly/index.mjs
var anomaly_exports = {};
__export(anomaly_exports, {
  blocks: () => blocks_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/anomaly/resources/blocks/index.mjs
var blocks_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/index.mjs
var attackProtection_exports = {};
__export(attackProtection_exports, {
  botDetection: () => botDetection_exports,
  breachedPasswordDetection: () => breachedPasswordDetection_exports,
  bruteForceProtection: () => bruteForceProtection_exports,
  captcha: () => captcha_exports,
  suspiciousIpThrottling: () => suspiciousIpThrottling_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/botDetection/index.mjs
var botDetection_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/breachedPasswordDetection/index.mjs
var breachedPasswordDetection_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/bruteForceProtection/index.mjs
var bruteForceProtection_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/captcha/index.mjs
var captcha_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/suspiciousIpThrottling/index.mjs
var suspiciousIpThrottling_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/index.mjs
var branding_exports = {};
__export(branding_exports, {
  phone: () => phone_exports,
  templates: () => templates_exports2,
  themes: () => themes_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/phone/index.mjs
var phone_exports = {};
__export(phone_exports, {
  providers: () => providers_exports,
  templates: () => templates_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/phone/resources/providers/index.mjs
var providers_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/phone/resources/templates/index.mjs
var templates_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/templates/index.mjs
var templates_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/themes/index.mjs
var themes_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clientGrants/index.mjs
var clientGrants_exports = {};
__export(clientGrants_exports, {
  organizations: () => organizations_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clientGrants/resources/organizations/index.mjs
var organizations_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clients/index.mjs
var clients_exports = {};
__export(clients_exports, {
  connections: () => connections_exports,
  credentials: () => credentials_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clients/resources/connections/index.mjs
var connections_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clients/resources/credentials/index.mjs
var credentials_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connectionProfiles/index.mjs
var connectionProfiles_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/index.mjs
var connections_exports2 = {};
__export(connections_exports2, {
  clients: () => clients_exports2,
  directoryProvisioning: () => directoryProvisioning_exports,
  keys: () => keys_exports,
  scimConfiguration: () => scimConfiguration_exports,
  users: () => users_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/clients/index.mjs
var clients_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/directoryProvisioning/index.mjs
var directoryProvisioning_exports = {};
__export(directoryProvisioning_exports, {
  synchronizations: () => synchronizations_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/directoryProvisioning/resources/synchronizations/index.mjs
var synchronizations_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/keys/index.mjs
var keys_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/scimConfiguration/index.mjs
var scimConfiguration_exports = {};
__export(scimConfiguration_exports, {
  tokens: () => tokens_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/scimConfiguration/resources/tokens/index.mjs
var tokens_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/users/index.mjs
var users_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/customDomains/index.mjs
var customDomains_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/deviceCredentials/index.mjs
var deviceCredentials_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/emails/index.mjs
var emails_exports = {};
__export(emails_exports, {
  provider: () => provider_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/emails/resources/provider/index.mjs
var provider_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/emailTemplates/index.mjs
var emailTemplates_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/eventStreams/index.mjs
var eventStreams_exports = {};
__export(eventStreams_exports, {
  deliveries: () => deliveries_exports,
  redeliveries: () => redeliveries_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/eventStreams/resources/deliveries/index.mjs
var deliveries_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/eventStreams/resources/redeliveries/index.mjs
var redeliveries_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/flows/index.mjs
var flows_exports = {};
__export(flows_exports, {
  executions: () => executions_exports2,
  vault: () => vault_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/flows/resources/executions/index.mjs
var executions_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/flows/resources/vault/index.mjs
var vault_exports = {};
__export(vault_exports, {
  connections: () => connections_exports3
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/flows/resources/vault/resources/connections/index.mjs
var connections_exports3 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/forms/index.mjs
var forms_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/index.mjs
var guardian_exports = {};
__export(guardian_exports, {
  enrollments: () => enrollments_exports,
  factors: () => factors_exports,
  policies: () => policies_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/enrollments/index.mjs
var enrollments_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/index.mjs
var factors_exports = {};
__export(factors_exports, {
  duo: () => duo_exports,
  phone: () => phone_exports2,
  pushNotification: () => pushNotification_exports,
  sms: () => sms_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/duo/index.mjs
var duo_exports = {};
__export(duo_exports, {
  settings: () => settings_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/duo/resources/settings/index.mjs
var settings_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/phone/index.mjs
var phone_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/pushNotification/index.mjs
var pushNotification_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/sms/index.mjs
var sms_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/policies/index.mjs
var policies_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/hooks/index.mjs
var hooks_exports = {};
__export(hooks_exports, {
  secrets: () => secrets_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/hooks/resources/secrets/index.mjs
var secrets_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/index.mjs
var jobs_exports = {};
__export(jobs_exports, {
  errors: () => errors_exports2,
  usersExports: () => usersExports_exports,
  usersImports: () => usersImports_exports,
  verificationEmail: () => verificationEmail_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/resources/errors/index.mjs
var errors_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/resources/usersExports/index.mjs
var usersExports_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/resources/usersImports/index.mjs
var usersImports_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/resources/verificationEmail/index.mjs
var verificationEmail_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/keys/index.mjs
var keys_exports2 = {};
__export(keys_exports2, {
  customSigning: () => customSigning_exports,
  encryption: () => encryption_exports,
  signing: () => signing_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/keys/resources/customSigning/index.mjs
var customSigning_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/keys/resources/encryption/index.mjs
var encryption_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/keys/resources/signing/index.mjs
var signing_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/logs/index.mjs
var logs_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/logStreams/index.mjs
var logStreams_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/networkAcls/index.mjs
var networkAcls_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/index.mjs
var organizations_exports2 = {};
__export(organizations_exports2, {
  clientGrants: () => clientGrants_exports2,
  discoveryDomains: () => discoveryDomains_exports,
  enabledConnections: () => enabledConnections_exports,
  invitations: () => invitations_exports,
  members: () => members_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/clientGrants/index.mjs
var clientGrants_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/discoveryDomains/index.mjs
var discoveryDomains_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/enabledConnections/index.mjs
var enabledConnections_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/invitations/index.mjs
var invitations_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/members/index.mjs
var members_exports = {};
__export(members_exports, {
  roles: () => roles_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/members/resources/roles/index.mjs
var roles_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/prompts/index.mjs
var prompts_exports = {};
__export(prompts_exports, {
  customText: () => customText_exports,
  partials: () => partials_exports,
  rendering: () => rendering_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/prompts/resources/customText/index.mjs
var customText_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/prompts/resources/partials/index.mjs
var partials_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/prompts/resources/rendering/index.mjs
var rendering_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/refreshTokens/index.mjs
var refreshTokens_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/resourceServers/index.mjs
var resourceServers_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/riskAssessments/index.mjs
var riskAssessments_exports = {};
__export(riskAssessments_exports, {
  settings: () => settings_exports2
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/riskAssessments/resources/settings/index.mjs
var settings_exports2 = {};
__export(settings_exports2, {
  newDevice: () => newDevice_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/riskAssessments/resources/settings/resources/newDevice/index.mjs
var newDevice_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/roles/index.mjs
var roles_exports2 = {};
__export(roles_exports2, {
  permissions: () => permissions_exports,
  users: () => users_exports2
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/roles/resources/permissions/index.mjs
var permissions_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/roles/resources/users/index.mjs
var users_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/rules/index.mjs
var rules_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/rulesConfigs/index.mjs
var rulesConfigs_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/selfServiceProfiles/index.mjs
var selfServiceProfiles_exports = {};
__export(selfServiceProfiles_exports, {
  customText: () => customText_exports2,
  ssoTicket: () => ssoTicket_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/selfServiceProfiles/resources/customText/index.mjs
var customText_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/selfServiceProfiles/resources/ssoTicket/index.mjs
var ssoTicket_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/sessions/index.mjs
var sessions_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/stats/index.mjs
var stats_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/supplementalSignals/index.mjs
var supplementalSignals_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/tenants/index.mjs
var tenants_exports = {};
__export(tenants_exports, {
  settings: () => settings_exports3
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/tenants/resources/settings/index.mjs
var settings_exports3 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/tickets/index.mjs
var tickets_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/tokenExchangeProfiles/index.mjs
var tokenExchangeProfiles_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/userAttributeProfiles/index.mjs
var userAttributeProfiles_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/userBlocks/index.mjs
var userBlocks_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/userGrants/index.mjs
var userGrants_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/index.mjs
var users_exports3 = {};
__export(users_exports3, {
  authenticationMethods: () => authenticationMethods_exports,
  authenticators: () => authenticators_exports,
  connectedAccounts: () => connectedAccounts_exports,
  enrollments: () => enrollments_exports2,
  federatedConnectionsTokensets: () => federatedConnectionsTokensets_exports,
  identities: () => identities_exports,
  logs: () => logs_exports2,
  multifactor: () => multifactor_exports,
  organizations: () => organizations_exports3,
  permissions: () => permissions_exports2,
  refreshToken: () => refreshToken_exports,
  riskAssessments: () => riskAssessments_exports2,
  roles: () => roles_exports3,
  sessions: () => sessions_exports2
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/authenticationMethods/index.mjs
var authenticationMethods_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/authenticators/index.mjs
var authenticators_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/connectedAccounts/index.mjs
var connectedAccounts_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/enrollments/index.mjs
var enrollments_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/federatedConnectionsTokensets/index.mjs
var federatedConnectionsTokensets_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/identities/index.mjs
var identities_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/logs/index.mjs
var logs_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/multifactor/index.mjs
var multifactor_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/organizations/index.mjs
var organizations_exports3 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/permissions/index.mjs
var permissions_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/refreshToken/index.mjs
var refreshToken_exports = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/riskAssessments/index.mjs
var riskAssessments_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/roles/index.mjs
var roles_exports3 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/sessions/index.mjs
var sessions_exports2 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/verifiableCredentials/index.mjs
var verifiableCredentials_exports = {};
__export(verifiableCredentials_exports, {
  verification: () => verification_exports
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/verifiableCredentials/resources/verification/index.mjs
var verification_exports = {};
__export(verification_exports, {
  templates: () => templates_exports3
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/verifiableCredentials/resources/verification/resources/templates/index.mjs
var templates_exports3 = {};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/types/types.mjs
var OauthScope = {
  /**
   * Read Actions */
  ReadActions: "read:actions",
  /**
   * Create Actions */
  CreateActions: "create:actions",
  /**
   * Delete Actions */
  DeleteActions: "delete:actions",
  /**
   * Update Actions */
  UpdateActions: "update:actions",
  /**
   * Read Anomaly Blocks */
  ReadAnomalyBlocks: "read:anomaly_blocks",
  /**
   * Delete Anomaly Blocks */
  DeleteAnomalyBlocks: "delete:anomaly_blocks",
  /**
   * Read Shields */
  ReadShields: "read:shields",
  /**
   * Create Shields */
  CreateShields: "create:shields",
  /**
   * Update Shields */
  UpdateShields: "update:shields",
  /**
   * Read Attack Protection */
  ReadAttackProtection: "read:attack_protection",
  /**
   * Update Attack Protection */
  UpdateAttackProtection: "update:attack_protection",
  /**
   * Read Branding */
  ReadBranding: "read:branding",
  /**
   * Update Branding */
  UpdateBranding: "update:branding",
  /**
   * Read Phone Providers */
  ReadPhoneProviders: "read:phone_providers",
  /**
   * Create Phone Providers */
  CreatePhoneProviders: "create:phone_providers",
  /**
   * Update Phone Providers */
  UpdatePhoneProviders: "update:phone_providers",
  /**
   * Delete Phone Providers */
  DeletePhoneProviders: "delete:phone_providers",
  /**
   * Read Phone Templates */
  ReadPhoneTemplates: "read:phone_templates",
  /**
   * Create Phone Templates */
  CreatePhoneTemplates: "create:phone_templates",
  /**
   * Update Phone Templates */
  UpdatePhoneTemplates: "update:phone_templates",
  /**
   * Delete Phone Templates */
  DeletePhoneTemplates: "delete:phone_templates",
  /**
   * Delete Branding */
  DeleteBranding: "delete:branding",
  /**
   * Read Client Grants */
  ReadClientGrants: "read:client_grants",
  /**
   * Create Client Grants */
  CreateClientGrants: "create:client_grants",
  /**
   * Update Client Grants */
  UpdateClientGrants: "update:client_grants",
  /**
   * Delete Client Grants */
  DeleteClientGrants: "delete:client_grants",
  /**
   * Read Organization Client Grants */
  ReadOrganizationClientGrants: "read:organization_client_grants",
  /**
   * Read Clients */
  ReadClients: "read:clients",
  /**
   * Read Client Keys */
  ReadClientKeys: "read:client_keys",
  /**
   * Read Client Credentials */
  ReadClientCredentials: "read:client_credentials",
  /**
   * Read Client Summary */
  ReadClientSummary: "read:client_summary",
  /**
   * Create Clients */
  CreateClients: "create:clients",
  /**
   * Create Client Credentials */
  CreateClientCredentials: "create:client_credentials",
  /**
   * Update Client Credentials */
  UpdateClientCredentials: "update:client_credentials",
  /**
   * Delete Client Credentials */
  DeleteClientCredentials: "delete:client_credentials",
  /**
   * Update Clients */
  UpdateClients: "update:clients",
  /**
   * Update Client Keys */
  UpdateClientKeys: "update:client_keys",
  /**
   * Update Client Token Vault Privileged Access */
  UpdateClientTokenVaultPrivilegedAccess: "update:client_token_vault_privileged_access",
  /**
   * Delete Clients */
  DeleteClients: "delete:clients",
  /**
   * Read Connections */
  ReadConnections: "read:connections",
  /**
   * Read Connection Profiles */
  ReadConnectionProfiles: "read:connection_profiles",
  /**
   * Create Connection Profiles */
  CreateConnectionProfiles: "create:connection_profiles",
  /**
   * Update Connection Profiles */
  UpdateConnectionProfiles: "update:connection_profiles",
  /**
   * Delete Connection Profiles */
  DeleteConnectionProfiles: "delete:connection_profiles",
  /**
   * Create Connections */
  CreateConnections: "create:connections",
  /**
   * Update Connections */
  UpdateConnections: "update:connections",
  /**
   * Delete Connections */
  DeleteConnections: "delete:connections",
  /**
   * Read Directory Provisionings */
  ReadDirectoryProvisionings: "read:directory_provisionings",
  /**
   * Create Directory Provisionings */
  CreateDirectoryProvisionings: "create:directory_provisionings",
  /**
   * Update Directory Provisionings */
  UpdateDirectoryProvisionings: "update:directory_provisionings",
  /**
   * Delete Directory Provisionings */
  DeleteDirectoryProvisionings: "delete:directory_provisionings",
  /**
   * Read Users */
  ReadUsers: "read:users",
  /**
   * Read Connections Keys */
  ReadConnectionsKeys: "read:connections_keys",
  /**
   * Create Connections Keys */
  CreateConnectionsKeys: "create:connections_keys",
  /**
   * Update Connections Keys */
  UpdateConnectionsKeys: "update:connections_keys",
  /**
   * Read Scim Config */
  ReadScimConfig: "read:scim_config",
  /**
   * Create Scim Config */
  CreateScimConfig: "create:scim_config",
  /**
   * Update Scim Config */
  UpdateScimConfig: "update:scim_config",
  /**
   * Delete Scim Config */
  DeleteScimConfig: "delete:scim_config",
  /**
   * Read Scim Token */
  ReadScimToken: "read:scim_token",
  /**
   * Create Scim Token */
  CreateScimToken: "create:scim_token",
  /**
   * Delete Scim Token */
  DeleteScimToken: "delete:scim_token",
  /**
   * Delete Users */
  DeleteUsers: "delete:users",
  /**
   * Read Custom Domains */
  ReadCustomDomains: "read:custom_domains",
  /**
   * Create Custom Domains */
  CreateCustomDomains: "create:custom_domains",
  /**
   * Update Custom Domains */
  UpdateCustomDomains: "update:custom_domains",
  /**
   * Delete Custom Domains */
  DeleteCustomDomains: "delete:custom_domains",
  /**
   * Read Device Credentials */
  ReadDeviceCredentials: "read:device_credentials",
  /**
   * Create Current User Device Credentials */
  CreateCurrentUserDeviceCredentials: "create:current_user_device_credentials",
  /**
   * Delete Device Credentials */
  DeleteDeviceCredentials: "delete:device_credentials",
  /**
   * Delete Current User Device Credentials */
  DeleteCurrentUserDeviceCredentials: "delete:current_user_device_credentials",
  /**
   * Update Device Codes */
  UpdateDeviceCodes: "update:device_codes",
  /**
   * Read Device Codes */
  ReadDeviceCodes: "read:device_codes",
  /**
   * Create Test Email Dispatch */
  CreateTestEmailDispatch: "create:test_email_dispatch",
  /**
   * Create Email Templates */
  CreateEmailTemplates: "create:email_templates",
  /**
   * Read Email Templates */
  ReadEmailTemplates: "read:email_templates",
  /**
   * Update Email Templates */
  UpdateEmailTemplates: "update:email_templates",
  /**
   * Read Email Provider */
  ReadEmailProvider: "read:email_provider",
  /**
   * Create Email Provider */
  CreateEmailProvider: "create:email_provider",
  /**
   * Update Email Provider */
  UpdateEmailProvider: "update:email_provider",
  /**
   * Delete Email Provider */
  DeleteEmailProvider: "delete:email_provider",
  /**
   * Read Entitlements */
  ReadEntitlements: "read:entitlements",
  /**
   * Read Event Streams */
  ReadEventStreams: "read:event_streams",
  /**
   * Create Event Streams */
  CreateEventStreams: "create:event_streams",
  /**
   * Update Event Streams */
  UpdateEventStreams: "update:event_streams",
  /**
   * Delete Event Streams */
  DeleteEventStreams: "delete:event_streams",
  /**
   * Read Event Deliveries */
  ReadEventDeliveries: "read:event_deliveries",
  /**
   * Update Event Deliveries */
  UpdateEventDeliveries: "update:event_deliveries",
  /**
   * Read Events */
  ReadEvents: "read:events",
  /**
   * Read Extensions */
  ReadExtensions: "read:extensions",
  /**
   * Read Flows */
  ReadFlows: "read:flows",
  /**
   * Create Flows */
  CreateFlows: "create:flows",
  /**
   * Read Flows Vault Connections */
  ReadFlowsVaultConnections: "read:flows_vault_connections",
  /**
   * Create Flows Vault Connections */
  CreateFlowsVaultConnections: "create:flows_vault_connections",
  /**
   * Update Flows Vault Connections */
  UpdateFlowsVaultConnections: "update:flows_vault_connections",
  /**
   * Delete Flows Vault Connections */
  DeleteFlowsVaultConnections: "delete:flows_vault_connections",
  /**
   * Read Flows Executions */
  ReadFlowsExecutions: "read:flows_executions",
  /**
   * Delete Flows Executions */
  DeleteFlowsExecutions: "delete:flows_executions",
  /**
   * Update Flows */
  UpdateFlows: "update:flows",
  /**
   * Delete Flows */
  DeleteFlows: "delete:flows",
  /**
   * Read Forms */
  ReadForms: "read:forms",
  /**
   * Create Forms */
  CreateForms: "create:forms",
  /**
   * Update Forms */
  UpdateForms: "update:forms",
  /**
   * Delete Forms */
  DeleteForms: "delete:forms",
  /**
   * Read Grants */
  ReadGrants: "read:grants",
  /**
   * Delete Grants */
  DeleteGrants: "delete:grants",
  /**
   * Read Groups */
  ReadGroups: "read:groups",
  /**
   * Read Group Members */
  ReadGroupMembers: "read:group_members",
  /**
   * Create Guardian Enrollment Tickets */
  CreateGuardianEnrollmentTickets: "create:guardian_enrollment_tickets",
  /**
   * Read Guardian Enrollments */
  ReadGuardianEnrollments: "read:guardian_enrollments",
  /**
   * Delete Guardian Enrollments */
  DeleteGuardianEnrollments: "delete:guardian_enrollments",
  /**
   * Read Guardian Factors */
  ReadGuardianFactors: "read:guardian_factors",
  /**
   * Update Guardian Factors */
  UpdateGuardianFactors: "update:guardian_factors",
  /**
   * Read Mfa Policies */
  ReadMfaPolicies: "read:mfa_policies",
  /**
   * Update Mfa Policies */
  UpdateMfaPolicies: "update:mfa_policies",
  /**
   * Read Hooks */
  ReadHooks: "read:hooks",
  /**
   * Create Hooks */
  CreateHooks: "create:hooks",
  /**
   * Update Hooks */
  UpdateHooks: "update:hooks",
  /**
   * Delete Hooks */
  DeleteHooks: "delete:hooks",
  /**
   * Read Insights */
  ReadInsights: "read:insights",
  /**
   * Read Stats */
  ReadStats: "read:stats",
  /**
   * Read Integrations */
  ReadIntegrations: "read:integrations",
  /**
   * Create Integrations */
  CreateIntegrations: "create:integrations",
  /**
   * Update Integrations */
  UpdateIntegrations: "update:integrations",
  /**
   * Delete Integrations */
  DeleteIntegrations: "delete:integrations",
  /**
   * Create Users */
  CreateUsers: "create:users",
  /**
   * Update Users */
  UpdateUsers: "update:users",
  /**
   * Read Custom Signing Keys */
  ReadCustomSigningKeys: "read:custom_signing_keys",
  /**
   * Create Custom Signing Keys */
  CreateCustomSigningKeys: "create:custom_signing_keys",
  /**
   * Update Custom Signing Keys */
  UpdateCustomSigningKeys: "update:custom_signing_keys",
  /**
   * Delete Custom Signing Keys */
  DeleteCustomSigningKeys: "delete:custom_signing_keys",
  /**
   * Read Encryption Keys */
  ReadEncryptionKeys: "read:encryption_keys",
  /**
   * Create Encryption Keys */
  CreateEncryptionKeys: "create:encryption_keys",
  /**
   * Update Encryption Keys */
  UpdateEncryptionKeys: "update:encryption_keys",
  /**
   * Delete Encryption Keys */
  DeleteEncryptionKeys: "delete:encryption_keys",
  /**
   * Read Signing Keys */
  ReadSigningKeys: "read:signing_keys",
  /**
   * Create Signing Keys */
  CreateSigningKeys: "create:signing_keys",
  /**
   * Update Signing Keys */
  UpdateSigningKeys: "update:signing_keys",
  /**
   * Read Log Streams */
  ReadLogStreams: "read:log_streams",
  /**
   * Create Log Streams */
  CreateLogStreams: "create:log_streams",
  /**
   * Update Log Streams */
  UpdateLogStreams: "update:log_streams",
  /**
   * Delete Log Streams */
  DeleteLogStreams: "delete:log_streams",
  /**
   * Read Logs */
  ReadLogs: "read:logs",
  /**
   * Read Logs Users */
  ReadLogsUsers: "read:logs_users",
  /**
   * Read Tenant Settings */
  ReadTenantSettings: "read:tenant_settings",
  /**
   * Update Tenant Settings */
  UpdateTenantSettings: "update:tenant_settings",
  /**
   * Read Network Acls */
  ReadNetworkAcls: "read:network_acls",
  /**
   * Create Network Acls */
  CreateNetworkAcls: "create:network_acls",
  /**
   * Update Network Acls */
  UpdateNetworkAcls: "update:network_acls",
  /**
   * Delete Network Acls */
  DeleteNetworkAcls: "delete:network_acls",
  /**
   * Read Organizations */
  ReadOrganizations: "read:organizations",
  /**
   * Read Organizations Summary */
  ReadOrganizationsSummary: "read:organizations_summary",
  /**
   * Create Organizations */
  CreateOrganizations: "create:organizations",
  /**
   * Create Organization Connections */
  CreateOrganizationConnections: "create:organization_connections",
  /**
   * Update Organizations */
  UpdateOrganizations: "update:organizations",
  /**
   * Delete Organizations */
  DeleteOrganizations: "delete:organizations",
  /**
   * Create Organization Client Grants */
  CreateOrganizationClientGrants: "create:organization_client_grants",
  /**
   * Delete Organization Client Grants */
  DeleteOrganizationClientGrants: "delete:organization_client_grants",
  /**
   * Read Organization Connections */
  ReadOrganizationConnections: "read:organization_connections",
  /**
   * Update Organization Connections */
  UpdateOrganizationConnections: "update:organization_connections",
  /**
   * Delete Organization Connections */
  DeleteOrganizationConnections: "delete:organization_connections",
  /**
   * Read Organization Discovery Domains */
  ReadOrganizationDiscoveryDomains: "read:organization_discovery_domains",
  /**
   * Create Organization Discovery Domains */
  CreateOrganizationDiscoveryDomains: "create:organization_discovery_domains",
  /**
   * Update Organization Discovery Domains */
  UpdateOrganizationDiscoveryDomains: "update:organization_discovery_domains",
  /**
   * Delete Organization Discovery Domains */
  DeleteOrganizationDiscoveryDomains: "delete:organization_discovery_domains",
  /**
   * Read Organization Invitations */
  ReadOrganizationInvitations: "read:organization_invitations",
  /**
   * Create Organization Invitations */
  CreateOrganizationInvitations: "create:organization_invitations",
  /**
   * Delete Organization Invitations */
  DeleteOrganizationInvitations: "delete:organization_invitations",
  /**
   * Read Organization Members */
  ReadOrganizationMembers: "read:organization_members",
  /**
   * Create Organization Members */
  CreateOrganizationMembers: "create:organization_members",
  /**
   * Delete Organization Members */
  DeleteOrganizationMembers: "delete:organization_members",
  /**
   * Read Organization Member Roles */
  ReadOrganizationMemberRoles: "read:organization_member_roles",
  /**
   * Create Organization Member Roles */
  CreateOrganizationMemberRoles: "create:organization_member_roles",
  /**
   * Delete Organization Member Roles */
  DeleteOrganizationMemberRoles: "delete:organization_member_roles",
  /**
   * Read Prompts */
  ReadPrompts: "read:prompts",
  /**
   * Update Prompts */
  UpdatePrompts: "update:prompts",
  /**
   * Read Resource Servers */
  ReadResourceServers: "read:resource_servers",
  /**
   * Update Resource Servers */
  UpdateResourceServers: "update:resource_servers",
  /**
   * Read Refresh Tokens */
  ReadRefreshTokens: "read:refresh_tokens",
  /**
   * Delete Refresh Tokens */
  DeleteRefreshTokens: "delete:refresh_tokens",
  /**
   * Create Resource Servers */
  CreateResourceServers: "create:resource_servers",
  /**
   * Delete Resource Servers */
  DeleteResourceServers: "delete:resource_servers",
  /**
   * Read Roles */
  ReadRoles: "read:roles",
  /**
   * Create Roles */
  CreateRoles: "create:roles",
  /**
   * Update Roles */
  UpdateRoles: "update:roles",
  /**
   * Delete Roles */
  DeleteRoles: "delete:roles",
  /**
   * Read Role Members */
  ReadRoleMembers: "read:role_members",
  /**
   * Create Role Members */
  CreateRoleMembers: "create:role_members",
  /**
   * Read Rules */
  ReadRules: "read:rules",
  /**
   * Create Rules */
  CreateRules: "create:rules",
  /**
   * Update Rules */
  UpdateRules: "update:rules",
  /**
   * Read Rules Configs */
  ReadRulesConfigs: "read:rules_configs",
  /**
   * Update Rules Configs */
  UpdateRulesConfigs: "update:rules_configs",
  /**
   * Delete Rules Configs */
  DeleteRulesConfigs: "delete:rules_configs",
  /**
   * Delete Rules */
  DeleteRules: "delete:rules",
  /**
   * Read Security Metrics */
  ReadSecurityMetrics: "read:security_metrics",
  /**
   * Read Self Service Profiles */
  ReadSelfServiceProfiles: "read:self_service_profiles",
  /**
   * Create Self Service Profiles */
  CreateSelfServiceProfiles: "create:self_service_profiles",
  /**
   * Update Self Service Profiles */
  UpdateSelfServiceProfiles: "update:self_service_profiles",
  /**
   * Delete Self Service Profiles */
  DeleteSelfServiceProfiles: "delete:self_service_profiles",
  /**
   * Read Self Service Profile Custom Texts */
  ReadSelfServiceProfileCustomTexts: "read:self_service_profile_custom_texts",
  /**
   * Update Self Service Profile Custom Texts */
  UpdateSelfServiceProfileCustomTexts: "update:self_service_profile_custom_texts",
  /**
   * Create Sso Access Tickets */
  CreateSsoAccessTickets: "create:sso_access_tickets",
  /**
   * Delete Sso Access Tickets */
  DeleteSsoAccessTickets: "delete:sso_access_tickets",
  /**
   * Read Sessions */
  ReadSessions: "read:sessions",
  /**
   * Update Sessions */
  UpdateSessions: "update:sessions",
  /**
   * Delete Sessions */
  DeleteSessions: "delete:sessions",
  /**
   * Delete Tenants */
  DeleteTenants: "delete:tenants",
  /**
   * Run Checks */
  RunChecks: "run:checks",
  /**
   * Read Checks */
  ReadChecks: "read:checks",
  /**
   * Read Tenant Feature Flags */
  ReadTenantFeatureFlags: "read:tenant_feature_flags",
  /**
   * Read Tenant Invitations */
  ReadTenantInvitations: "read:tenant_invitations",
  /**
   * Create Tenant Invitations */
  CreateTenantInvitations: "create:tenant_invitations",
  /**
   * Update Tenant Invitations */
  UpdateTenantInvitations: "update:tenant_invitations",
  /**
   * Delete Tenant Invitations */
  DeleteTenantInvitations: "delete:tenant_invitations",
  /**
   * Read Tenant Members */
  ReadTenantMembers: "read:tenant_members",
  /**
   * Update Tenant Members */
  UpdateTenantMembers: "update:tenant_members",
  /**
   * Delete Tenant Members */
  DeleteTenantMembers: "delete:tenant_members",
  /**
   * Read Owners */
  ReadOwners: "read:owners",
  /**
   * Delete Owners */
  DeleteOwners: "delete:owners",
  /**
   * Create User Tickets */
  CreateUserTickets: "create:user_tickets",
  /**
   * Read Token Exchange Profiles */
  ReadTokenExchangeProfiles: "read:token_exchange_profiles",
  /**
   * Create Token Exchange Profiles */
  CreateTokenExchangeProfiles: "create:token_exchange_profiles",
  /**
   * Update Token Exchange Profiles */
  UpdateTokenExchangeProfiles: "update:token_exchange_profiles",
  /**
   * Delete Token Exchange Profiles */
  DeleteTokenExchangeProfiles: "delete:token_exchange_profiles",
  /**
   * Read Entity Counts */
  ReadEntityCounts: "read:entity_counts",
  /**
   * Read User Attribute Profiles */
  ReadUserAttributeProfiles: "read:user_attribute_profiles",
  /**
   * Create User Attribute Profiles */
  CreateUserAttributeProfiles: "create:user_attribute_profiles",
  /**
   * Update User Attribute Profiles */
  UpdateUserAttributeProfiles: "update:user_attribute_profiles",
  /**
   * Delete User Attribute Profiles */
  DeleteUserAttributeProfiles: "delete:user_attribute_profiles",
  /**
   * Read User Idp Tokens */
  ReadUserIdpTokens: "read:user_idp_tokens",
  /**
   * Read Current User */
  ReadCurrentUser: "read:current_user",
  /**
   * Update Users App Metadata */
  UpdateUsersAppMetadata: "update:users_app_metadata",
  /**
   * Update Current User Metadata */
  UpdateCurrentUserMetadata: "update:current_user_metadata",
  /**
   * Delete Current User */
  DeleteCurrentUser: "delete:current_user",
  /**
   * Read User Application Passwords */
  ReadUserApplicationPasswords: "read:user_application_passwords",
  /**
   * Create User Application Passwords */
  CreateUserApplicationPasswords: "create:user_application_passwords",
  /**
   * Delete User Application Passwords */
  DeleteUserApplicationPasswords: "delete:user_application_passwords",
  /**
   * Read Authentication Methods */
  ReadAuthenticationMethods: "read:authentication_methods",
  /**
   * Update Authentication Methods */
  UpdateAuthenticationMethods: "update:authentication_methods",
  /**
   * Create Authentication Methods */
  CreateAuthenticationMethods: "create:authentication_methods",
  /**
   * Delete Authentication Methods */
  DeleteAuthenticationMethods: "delete:authentication_methods",
  /**
   * Read Federated Connections Tokens */
  ReadFederatedConnectionsTokens: "read:federated_connections_tokens",
  /**
   * Delete Federated Connections Tokens */
  DeleteFederatedConnectionsTokens: "delete:federated_connections_tokens",
  /**
   * Update Current User Identities */
  UpdateCurrentUserIdentities: "update:current_user_identities",
  /**
   * Delete Role Members */
  DeleteRoleMembers: "delete:role_members",
  /**
   * Read Vdcs Templates */
  ReadVdcsTemplates: "read:vdcs_templates",
  /**
   * Create Vdcs Templates */
  CreateVdcsTemplates: "create:vdcs_templates",
  /**
   * Update Vdcs Templates */
  UpdateVdcsTemplates: "update:vdcs_templates",
  /**
   * Delete Vdcs Templates */
  DeleteVdcsTemplates: "delete:vdcs_templates"
};
var ActionBindingRefTypeEnum = {
  BindingId: "binding_id",
  ActionId: "action_id",
  ActionName: "action_name"
};
var ActionBindingTypeEnum = {
  TriggerBound: "trigger-bound",
  EntityBound: "entity-bound"
};
var ActionBuildStatusEnum = {
  Pending: "pending",
  Building: "building",
  Packaged: "packaged",
  Built: "built",
  Retrying: "retrying",
  Failed: "failed"
};
var ActionExecutionStatusEnum = {
  Unspecified: "unspecified",
  Pending: "pending",
  Final: "final",
  Partial: "partial",
  Canceled: "canceled",
  Suspended: "suspended"
};
var ActionVersionBuildStatusEnum = {
  Pending: "pending",
  Building: "building",
  Packaged: "packaged",
  Built: "built",
  Retrying: "retrying",
  Failed: "failed"
};
var AculContextEnum = {
  BrandingSettings: "branding.settings",
  BrandingThemesDefault: "branding.themes.default",
  ClientLogoUri: "client.logo_uri",
  ClientDescription: "client.description",
  OrganizationDisplayName: "organization.display_name",
  OrganizationBranding: "organization.branding",
  ScreenTexts: "screen.texts",
  TenantName: "tenant.name",
  TenantFriendlyName: "tenant.friendly_name",
  TenantLogoUrl: "tenant.logo_url",
  TenantEnabledLocales: "tenant.enabled_locales",
  UntrustedDataSubmittedFormData: "untrusted_data.submitted_form_data",
  UntrustedDataAuthorizationParamsLoginHint: "untrusted_data.authorization_params.login_hint",
  UntrustedDataAuthorizationParamsScreenHint: "untrusted_data.authorization_params.screen_hint",
  UntrustedDataAuthorizationParamsUiLocales: "untrusted_data.authorization_params.ui_locales",
  UserOrganizations: "user.organizations",
  TransactionCustomDomainDomain: "transaction.custom_domain.domain"
};
var AculMatchTypeEnum = {
  IncludesAny: "includes_any",
  ExcludesAny: "excludes_any"
};
var AculRenderingModeEnum = {
  Advanced: "advanced",
  Standard: "standard"
};
var AsyncApprovalNotificationsChannelsEnum = {
  GuardianPush: "guardian-push",
  Email: "email"
};
var AttackProtectionCaptchaProviderId = {
  Arkose: "arkose",
  AuthChallenge: "auth_challenge",
  FriendlyCaptcha: "friendly_captcha",
  Hcaptcha: "hcaptcha",
  RecaptchaV2: "recaptcha_v2",
  RecaptchaEnterprise: "recaptcha_enterprise",
  SimpleCaptcha: "simple_captcha"
};
var AuthenticationMethodTypeEnum = {
  RecoveryCode: "recovery-code",
  Totp: "totp",
  Push: "push",
  Phone: "phone",
  Email: "email",
  EmailVerification: "email-verification",
  WebauthnRoaming: "webauthn-roaming",
  WebauthnPlatform: "webauthn-platform",
  Guardian: "guardian",
  Passkey: "passkey",
  Password: "password"
};
var AuthenticationTypeEnum = {
  Phone: "phone",
  Email: "email",
  Totp: "totp"
};
var BotDetectionChallengePolicyPasswordFlowEnum = {
  Never: "never",
  WhenRisky: "when_risky",
  Always: "always"
};
var BotDetectionChallengePolicyPasswordResetFlowEnum = {
  Never: "never",
  WhenRisky: "when_risky",
  Always: "always"
};
var BotDetectionChallengePolicyPasswordlessFlowEnum = {
  Never: "never",
  WhenRisky: "when_risky",
  Always: "always"
};
var BotDetectionLevelEnum = {
  Low: "low",
  Medium: "medium",
  High: "high"
};
var BrandingThemeBordersButtonsStyleEnum = {
  Pill: "pill",
  Rounded: "rounded",
  Sharp: "sharp"
};
var BrandingThemeBordersInputsStyleEnum = {
  Pill: "pill",
  Rounded: "rounded",
  Sharp: "sharp"
};
var BrandingThemeColorsCaptchaWidgetThemeEnum = {
  Auto: "auto",
  Dark: "dark",
  Light: "light"
};
var BrandingThemeFontLinksStyleEnum = {
  Normal: "normal",
  Underlined: "underlined"
};
var BrandingThemePageBackgroundPageLayoutEnum = {
  Center: "center",
  Left: "left",
  Right: "right"
};
var BrandingThemeWidgetHeaderTextAlignmentEnum = {
  Center: "center",
  Left: "left",
  Right: "right"
};
var BrandingThemeWidgetLogoPositionEnum = {
  Center: "center",
  Left: "left",
  None: "none",
  Right: "right"
};
var BrandingThemeWidgetSocialButtonsLayoutEnum = {
  Bottom: "bottom",
  Top: "top"
};
var BreachedPasswordDetectionAdminNotificationFrequencyEnum = {
  Immediately: "immediately",
  Daily: "daily",
  Weekly: "weekly",
  Monthly: "monthly"
};
var BreachedPasswordDetectionMethodEnum = {
  Standard: "standard",
  Enhanced: "enhanced"
};
var BreachedPasswordDetectionPreChangePasswordShieldsEnum = {
  Block: "block",
  AdminNotification: "admin_notification"
};
var BreachedPasswordDetectionPreUserRegistrationShieldsEnum = {
  Block: "block",
  AdminNotification: "admin_notification"
};
var BreachedPasswordDetectionShieldsEnum = {
  Block: "block",
  UserNotification: "user_notification",
  AdminNotification: "admin_notification"
};
var ClientAppTypeEnum = {
  Native: "native",
  Spa: "spa",
  RegularWeb: "regular_web",
  NonInteractive: "non_interactive",
  ResourceServer: "resource_server",
  ExpressConfiguration: "express_configuration",
  Rms: "rms",
  Box: "box",
  Cloudbees: "cloudbees",
  Concur: "concur",
  Dropbox: "dropbox",
  Mscrm: "mscrm",
  Echosign: "echosign",
  Egnyte: "egnyte",
  Newrelic: "newrelic",
  Office365: "office365",
  Salesforce: "salesforce",
  Sentry: "sentry",
  Sharepoint: "sharepoint",
  Slack: "slack",
  Springcm: "springcm",
  Zendesk: "zendesk",
  Zoom: "zoom",
  SsoIntegration: "sso_integration",
  Oag: "oag"
};
var ClientComplianceLevelEnum = {
  None: "none",
  Fapi1AdvPkjPar: "fapi1_adv_pkj_par",
  Fapi1AdvMtlsPar: "fapi1_adv_mtls_par",
  Fapi2SpPkjMtls: "fapi2_sp_pkj_mtls",
  Fapi2SpMtlsMtls: "fapi2_sp_mtls_mtls"
};
var ClientCredentialAlgorithmEnum = {
  Rs256: "RS256",
  Rs384: "RS384",
  Ps256: "PS256"
};
var ClientCredentialTypeEnum = {
  PublicKey: "public_key",
  CertSubjectDn: "cert_subject_dn",
  X509Cert: "x509_cert"
};
var ClientGrantOrganizationNullableUsageEnum = {
  Deny: "deny",
  Allow: "allow",
  Require: "require"
};
var ClientGrantOrganizationUsageEnum = {
  Deny: "deny",
  Allow: "allow",
  Require: "require"
};
var ClientGrantSubjectTypeEnum = {
  Client: "client",
  User: "user"
};
var ClientOidcBackchannelLogoutInitiatorsEnum = {
  RpLogout: "rp-logout",
  IdpLogout: "idp-logout",
  PasswordChanged: "password-changed",
  SessionExpired: "session-expired",
  SessionRevoked: "session-revoked",
  AccountDeleted: "account-deleted",
  EmailIdentifierChanged: "email-identifier-changed",
  MfaPhoneUnenrolled: "mfa-phone-unenrolled",
  AccountDeactivated: "account-deactivated"
};
var ClientOidcBackchannelLogoutInitiatorsModeEnum = {
  Custom: "custom",
  All: "all"
};
var ClientOrganizationDiscoveryEnum = {
  Email: "email",
  OrganizationName: "organization_name"
};
var ClientOrganizationRequireBehaviorEnum = {
  NoPrompt: "no_prompt",
  PreLoginPrompt: "pre_login_prompt",
  PostLoginPrompt: "post_login_prompt"
};
var ClientOrganizationRequireBehaviorPatchEnum = {
  NoPrompt: "no_prompt",
  PreLoginPrompt: "pre_login_prompt",
  PostLoginPrompt: "post_login_prompt"
};
var ClientOrganizationUsageEnum = {
  Deny: "deny",
  Allow: "allow",
  Require: "require"
};
var ClientOrganizationUsagePatchEnum = {
  Deny: "deny",
  Allow: "allow",
  Require: "require"
};
var ClientSessionTransferAllowedAuthenticationMethodsEnum = {
  Cookie: "cookie",
  Query: "query"
};
var ClientSessionTransferDeviceBindingEnum = {
  Ip: "ip",
  Asn: "asn",
  None: "none"
};
var ClientTokenEndpointAuthMethodEnum = {
  None: "none",
  ClientSecretPost: "client_secret_post",
  ClientSecretBasic: "client_secret_basic"
};
var ClientTokenEndpointAuthMethodOrNullEnum = {
  None: "none",
  ClientSecretPost: "client_secret_post",
  ClientSecretBasic: "client_secret_basic"
};
var ConnectionConnectionSettingsPkceEnum = {
  Auto: "auto",
  S256: "S256",
  Plain: "plain",
  Disabled: "disabled"
};
var ConnectionIdTokenSignedResponseAlgEnum = {
  Rs256: "RS256",
  Rs512: "RS512",
  Ps256: "PS256",
  Es256: "ES256"
};
var ConnectionIdentifierPrecedenceEnum = {
  Email: "email",
  PhoneNumber: "phone_number",
  Username: "username"
};
var ConnectionIdentityApiEnumAzureAd = {
  MicrosoftIdentityPlatformV20: "microsoft-identity-platform-v2.0",
  AzureActiveDirectoryV10: "azure-active-directory-v1.0"
};
var ConnectionIdentityProviderEnum = {
  Ad: "ad",
  Adfs: "adfs",
  Amazon: "amazon",
  Apple: "apple",
  Dropbox: "dropbox",
  Bitbucket: "bitbucket",
  Aol: "aol",
  Auth0Oidc: "auth0-oidc",
  Auth0: "auth0",
  Baidu: "baidu",
  Bitly: "bitly",
  Box: "box",
  Custom: "custom",
  Daccount: "daccount",
  Dwolla: "dwolla",
  Email: "email",
  EvernoteSandbox: "evernote-sandbox",
  Evernote: "evernote",
  Exact: "exact",
  Facebook: "facebook",
  Fitbit: "fitbit",
  Flickr: "flickr",
  Github: "github",
  GoogleApps: "google-apps",
  GoogleOauth2: "google-oauth2",
  Instagram: "instagram",
  Ip: "ip",
  Line: "line",
  Linkedin: "linkedin",
  Miicard: "miicard",
  Oauth1: "oauth1",
  Oauth2: "oauth2",
  Office365: "office365",
  Oidc: "oidc",
  Okta: "okta",
  Paypal: "paypal",
  PaypalSandbox: "paypal-sandbox",
  Pingfederate: "pingfederate",
  Planningcenter: "planningcenter",
  Renren: "renren",
  SalesforceCommunity: "salesforce-community",
  SalesforceSandbox: "salesforce-sandbox",
  Salesforce: "salesforce",
  Samlp: "samlp",
  Sharepoint: "sharepoint",
  Shopify: "shopify",
  Shop: "shop",
  Sms: "sms",
  Soundcloud: "soundcloud",
  ThecitySandbox: "thecity-sandbox",
  Thecity: "thecity",
  Thirtysevensignals: "thirtysevensignals",
  Twitter: "twitter",
  Untappd: "untappd",
  Vkontakte: "vkontakte",
  Waad: "waad",
  Weibo: "weibo",
  Windowslive: "windowslive",
  Wordpress: "wordpress",
  Yahoo: "yahoo",
  Yammer: "yammer",
  Yandex: "yandex"
};
var ConnectionKeyUseEnum = {
  Encryption: "encryption",
  Signing: "signing"
};
var ConnectionMappingModeEnumOidc = {
  BindAll: "bind_all",
  UseMap: "use_map"
};
var ConnectionMappingModeEnumOkta = {
  BasicProfile: "basic_profile",
  UseMap: "use_map"
};
var ConnectionPasskeyChallengeUiEnum = {
  Both: "both",
  Autofill: "autofill",
  Button: "button"
};
var ConnectionPasswordPolicyEnum = {
  None: "none",
  Low: "low",
  Fair: "fair",
  Good: "good",
  Excellent: "excellent"
};
var ConnectionProfileOrganizationAssignMembershipOnLoginEnum = {
  None: "none",
  Optional: "optional",
  Required: "required"
};
var ConnectionProfileOrganizationShowAsButtonEnum = {
  None: "none",
  Optional: "optional",
  Required: "required"
};
var ConnectionSetUserRootAttributesEnum = {
  OnEachLogin: "on_each_login",
  OnFirstLogin: "on_first_login",
  NeverOnLogin: "never_on_login"
};
var ConnectionShouldTrustEmailVerifiedConnectionEnum = {
  NeverSetEmailsAsVerified: "never_set_emails_as_verified",
  AlwaysSetEmailsAsVerified: "always_set_emails_as_verified"
};
var ConnectionStrategyEnum = {
  Ad: "ad",
  Adfs: "adfs",
  Amazon: "amazon",
  Apple: "apple",
  Dropbox: "dropbox",
  Bitbucket: "bitbucket",
  Aol: "aol",
  Auth0Oidc: "auth0-oidc",
  Auth0: "auth0",
  Baidu: "baidu",
  Bitly: "bitly",
  Box: "box",
  Custom: "custom",
  Daccount: "daccount",
  Dwolla: "dwolla",
  Email: "email",
  EvernoteSandbox: "evernote-sandbox",
  Evernote: "evernote",
  Exact: "exact",
  Facebook: "facebook",
  Fitbit: "fitbit",
  Flickr: "flickr",
  Github: "github",
  GoogleApps: "google-apps",
  GoogleOauth2: "google-oauth2",
  Instagram: "instagram",
  Ip: "ip",
  Line: "line",
  Linkedin: "linkedin",
  Miicard: "miicard",
  Oauth1: "oauth1",
  Oauth2: "oauth2",
  Office365: "office365",
  Oidc: "oidc",
  Okta: "okta",
  Paypal: "paypal",
  PaypalSandbox: "paypal-sandbox",
  Pingfederate: "pingfederate",
  Planningcenter: "planningcenter",
  Renren: "renren",
  SalesforceCommunity: "salesforce-community",
  SalesforceSandbox: "salesforce-sandbox",
  Salesforce: "salesforce",
  Samlp: "samlp",
  Sharepoint: "sharepoint",
  Shopify: "shopify",
  Shop: "shop",
  Sms: "sms",
  Soundcloud: "soundcloud",
  ThecitySandbox: "thecity-sandbox",
  Thecity: "thecity",
  Thirtysevensignals: "thirtysevensignals",
  Twitter: "twitter",
  Untappd: "untappd",
  Vkontakte: "vkontakte",
  Waad: "waad",
  Weibo: "weibo",
  Windowslive: "windowslive",
  Wordpress: "wordpress",
  Yahoo: "yahoo",
  Yammer: "yammer",
  Yandex: "yandex",
  Auth0Adldap: "auth0-adldap"
};
var ConnectionTokenEndpointAuthMethodEnum = {
  ClientSecretPost: "client_secret_post",
  PrivateKeyJwt: "private_key_jwt"
};
var ConnectionTokenEndpointAuthSigningAlgEnum = {
  Es256: "ES256",
  Ps256: "PS256",
  Rs256: "RS256",
  Rs512: "RS512"
};
var ConnectionTypeEnumOidc = {
  BackChannel: "back_channel",
  FrontChannel: "front_channel"
};
var ConnectionUpstreamAliasEnum = {
  AcrValues: "acr_values",
  Audience: "audience",
  ClientId: "client_id",
  Display: "display",
  IdTokenHint: "id_token_hint",
  LoginHint: "login_hint",
  MaxAge: "max_age",
  Prompt: "prompt",
  Resource: "resource",
  ResponseMode: "response_mode",
  ResponseType: "response_type",
  UiLocales: "ui_locales"
};
var ConnectionUseridAttributeEnumAzureAd = {
  Oid: "oid",
  Sub: "sub"
};
var ConnectionWaadProtocolEnumAzureAd = {
  WsFederation: "ws-federation",
  OpenidConnect: "openid-connect"
};
var CreateEncryptionKeyType = {
  CustomerProvidedRootKey: "customer-provided-root-key",
  TenantEncryptionKey: "tenant-encryption-key"
};
var CreatedAuthenticationMethodTypeEnum = {
  Phone: "phone",
  Email: "email",
  Totp: "totp",
  WebauthnRoaming: "webauthn-roaming"
};
var CreatedUserAuthenticationMethodTypeEnum = {
  Phone: "phone",
  Email: "email",
  Totp: "totp",
  WebauthnRoaming: "webauthn-roaming",
  Passkey: "passkey"
};
var CustomDomainCustomClientIpHeaderEnum = {
  TrueClientIp: "true-client-ip",
  CfConnectingIp: "cf-connecting-ip",
  XForwardedFor: "x-forwarded-for",
  XAzureClientip: "x-azure-clientip",
  Empty: ""
};
var CustomDomainProvisioningTypeEnum = {
  Auth0ManagedCerts: "auth0_managed_certs",
  SelfManagedCerts: "self_managed_certs"
};
var CustomDomainStatusFilterEnum = {
  PendingVerification: "pending_verification",
  Ready: "ready",
  Failed: "failed"
};
var CustomDomainTypeEnum = {
  Auth0ManagedCerts: "auth0_managed_certs",
  SelfManagedCerts: "self_managed_certs"
};
var CustomProviderDeliveryMethodEnum = {
  Text: "text",
  Voice: "voice"
};
var CustomSigningKeyAlgorithmEnum = {
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512"
};
var CustomSigningKeyCurveEnum = {
  P256: "P-256",
  P384: "P-384",
  P521: "P-521"
};
var CustomSigningKeyTypeEnum = {
  Ec: "EC",
  Rsa: "RSA"
};
var DeviceCredentialTypeEnum = {
  PublicKey: "public_key",
  RefreshToken: "refresh_token",
  RotatingRefreshToken: "rotating_refresh_token"
};
var DomainCertificateAuthorityEnum = {
  Letsencrypt: "letsencrypt",
  Googletrust: "googletrust"
};
var DomainCertificateStatusEnum = {
  Provisioning: "provisioning",
  ProvisioningFailed: "provisioning_failed",
  Provisioned: "provisioned",
  RenewingFailed: "renewing_failed"
};
var DomainVerificationMethodNameEnum = {
  Cname: "cname",
  Txt: "txt"
};
var DomainVerificationStatusEnum = {
  Verified: "verified",
  Pending: "pending",
  Failed: "failed"
};
var EmailProviderNameEnum = {
  Mailgun: "mailgun",
  Mandrill: "mandrill",
  Sendgrid: "sendgrid",
  Ses: "ses",
  Sparkpost: "sparkpost",
  Smtp: "smtp",
  AzureCs: "azure_cs",
  Ms365: "ms365",
  Custom: "custom"
};
var EmailTemplateNameEnum = {
  VerifyEmail: "verify_email",
  VerifyEmailByCode: "verify_email_by_code",
  ResetEmail: "reset_email",
  ResetEmailByCode: "reset_email_by_code",
  WelcomeEmail: "welcome_email",
  BlockedAccount: "blocked_account",
  StolenCredentials: "stolen_credentials",
  EnrollmentEmail: "enrollment_email",
  MfaOobCode: "mfa_oob_code",
  UserInvitation: "user_invitation",
  ChangePassword: "change_password",
  PasswordReset: "password_reset",
  AsyncApproval: "async_approval"
};
var EnabledFeaturesEnum = {
  Scim: "scim",
  UniversalLogout: "universal_logout"
};
var EncryptionKeyState = {
  PreActivation: "pre-activation",
  Active: "active",
  Deactivated: "deactivated",
  Destroyed: "destroyed"
};
var EncryptionKeyType = {
  CustomerProvidedRootKey: "customer-provided-root-key",
  EnvironmentRootKey: "environment-root-key",
  TenantMasterKey: "tenant-master-key",
  TenantEncryptionKey: "tenant-encryption-key"
};
var EventStreamDeliveryEventTypeEnum = {
  UserCreated: "user.created",
  UserDeleted: "user.deleted",
  UserUpdated: "user.updated",
  OrganizationCreated: "organization.created",
  OrganizationUpdated: "organization.updated",
  OrganizationDeleted: "organization.deleted",
  OrganizationMemberAdded: "organization.member.added",
  OrganizationMemberDeleted: "organization.member.deleted",
  OrganizationMemberRoleAssigned: "organization.member.role.assigned",
  OrganizationMemberRoleDeleted: "organization.member.role.deleted",
  OrganizationConnectionAdded: "organization.connection.added",
  OrganizationConnectionUpdated: "organization.connection.updated",
  OrganizationConnectionRemoved: "organization.connection.removed",
  GroupCreated: "group.created",
  GroupUpdated: "group.updated",
  GroupDeleted: "group.deleted",
  GroupMemberAdded: "group.member.added",
  GroupMemberDeleted: "group.member.deleted"
};
var EventStreamEventBridgeAwsRegionEnum = {
  AfSouth1: "af-south-1",
  ApEast1: "ap-east-1",
  ApEast2: "ap-east-2",
  ApNortheast1: "ap-northeast-1",
  ApNortheast2: "ap-northeast-2",
  ApNortheast3: "ap-northeast-3",
  ApSouth1: "ap-south-1",
  ApSouth2: "ap-south-2",
  ApSoutheast1: "ap-southeast-1",
  ApSoutheast2: "ap-southeast-2",
  ApSoutheast3: "ap-southeast-3",
  ApSoutheast4: "ap-southeast-4",
  ApSoutheast5: "ap-southeast-5",
  ApSoutheast6: "ap-southeast-6",
  ApSoutheast7: "ap-southeast-7",
  CaCentral1: "ca-central-1",
  CaWest1: "ca-west-1",
  EuCentral1: "eu-central-1",
  EuCentral2: "eu-central-2",
  EuNorth1: "eu-north-1",
  EuSouth1: "eu-south-1",
  EuSouth2: "eu-south-2",
  EuWest1: "eu-west-1",
  EuWest2: "eu-west-2",
  EuWest3: "eu-west-3",
  IlCentral1: "il-central-1",
  MeCentral1: "me-central-1",
  MeSouth1: "me-south-1",
  MxCentral1: "mx-central-1",
  SaEast1: "sa-east-1",
  UsGovEast1: "us-gov-east-1",
  UsGovWest1: "us-gov-west-1",
  UsEast1: "us-east-1",
  UsEast2: "us-east-2",
  UsWest1: "us-west-1",
  UsWest2: "us-west-2"
};
var EventStreamEventTypeEnum = {
  UserCreated: "user.created",
  UserDeleted: "user.deleted",
  UserUpdated: "user.updated",
  OrganizationCreated: "organization.created",
  OrganizationUpdated: "organization.updated",
  OrganizationDeleted: "organization.deleted",
  OrganizationMemberAdded: "organization.member.added",
  OrganizationMemberDeleted: "organization.member.deleted",
  OrganizationMemberRoleAssigned: "organization.member.role.assigned",
  OrganizationMemberRoleDeleted: "organization.member.role.deleted",
  OrganizationConnectionAdded: "organization.connection.added",
  OrganizationConnectionUpdated: "organization.connection.updated",
  OrganizationConnectionRemoved: "organization.connection.removed",
  GroupCreated: "group.created",
  GroupUpdated: "group.updated",
  GroupDeleted: "group.deleted",
  GroupMemberAdded: "group.member.added",
  GroupMemberDeleted: "group.member.deleted"
};
var EventStreamStatusEnum = {
  Enabled: "enabled",
  Disabled: "disabled"
};
var EventStreamTestEventTypeEnum = {
  UserCreated: "user.created",
  UserDeleted: "user.deleted",
  UserUpdated: "user.updated",
  OrganizationCreated: "organization.created",
  OrganizationUpdated: "organization.updated",
  OrganizationDeleted: "organization.deleted",
  OrganizationMemberAdded: "organization.member.added",
  OrganizationMemberDeleted: "organization.member.deleted",
  OrganizationMemberRoleAssigned: "organization.member.role.assigned",
  OrganizationMemberRoleDeleted: "organization.member.role.deleted",
  OrganizationConnectionAdded: "organization.connection.added",
  OrganizationConnectionUpdated: "organization.connection.updated",
  OrganizationConnectionRemoved: "organization.connection.removed",
  GroupCreated: "group.created",
  GroupUpdated: "group.updated",
  GroupDeleted: "group.deleted",
  GroupMemberAdded: "group.member.added",
  GroupMemberDeleted: "group.member.deleted"
};
var FlowActionAuth0SendRequestParams;
(function(FlowActionAuth0SendRequestParams2) {
  FlowActionAuth0SendRequestParams2.Method = {
    Get: "GET",
    Post: "POST",
    Put: "PUT",
    Patch: "PATCH",
    Delete: "DELETE"
  };
})(FlowActionAuth0SendRequestParams || (FlowActionAuth0SendRequestParams = {}));
var FlowActionFlowDelayFlowParams;
(function(FlowActionFlowDelayFlowParams2) {
  FlowActionFlowDelayFlowParams2.Units = {
    Seconds: "SECONDS",
    Minutes: "MINUTES",
    Hours: "HOURS",
    Days: "DAYS"
  };
})(FlowActionFlowDelayFlowParams || (FlowActionFlowDelayFlowParams = {}));
var FlowActionHttpSendRequestParams;
(function(FlowActionHttpSendRequestParams2) {
  FlowActionHttpSendRequestParams2.Method = {
    Get: "GET",
    Post: "POST",
    Put: "PUT",
    Patch: "PATCH",
    Delete: "DELETE"
  };
  FlowActionHttpSendRequestParams2.ContentType = {
    Json: "JSON",
    Form: "FORM",
    Xml: "XML"
  };
})(FlowActionHttpSendRequestParams || (FlowActionHttpSendRequestParams = {}));
var FlowActionSalesforceSearchLeadsParams;
(function(FlowActionSalesforceSearchLeadsParams2) {
  FlowActionSalesforceSearchLeadsParams2.SearchField = {
    Email: "email",
    Name: "name",
    Phone: "phone",
    All: "all"
  };
})(FlowActionSalesforceSearchLeadsParams || (FlowActionSalesforceSearchLeadsParams = {}));
var FlowActionSlackPostMessageParamsAttachment;
(function(FlowActionSlackPostMessageParamsAttachment2) {
  FlowActionSlackPostMessageParamsAttachment2.Color = {
    Good: "GOOD",
    Warning: "WARNING",
    Danger: "DANGER"
  };
})(FlowActionSlackPostMessageParamsAttachment || (FlowActionSlackPostMessageParamsAttachment = {}));
var FlowActionWhatsappSendMessageParams;
(function(FlowActionWhatsappSendMessageParams2) {
  FlowActionWhatsappSendMessageParams2.Type = {
    Audio: "AUDIO",
    Contacts: "CONTACTS",
    Document: "DOCUMENT",
    Image: "IMAGE",
    Interactive: "INTERACTIVE",
    Location: "LOCATION",
    Sticker: "STICKER",
    Template: "TEMPLATE",
    Text: "TEXT"
  };
})(FlowActionWhatsappSendMessageParams || (FlowActionWhatsappSendMessageParams = {}));
var FlowActionZapierTriggerWebhookParams;
(function(FlowActionZapierTriggerWebhookParams2) {
  FlowActionZapierTriggerWebhookParams2.Method = {
    Get: "GET",
    Post: "POST",
    Put: "PUT"
  };
})(FlowActionZapierTriggerWebhookParams || (FlowActionZapierTriggerWebhookParams = {}));
var FlowsVaultConnectioSetupJwtAlgorithmEnum = {
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512"
};
var FormBlockImageConfigPositionEnum = {
  Left: "LEFT",
  Center: "CENTER",
  Right: "RIGHT"
};
var FormBlockResendButtonConfigTextAlignmentEnum = {
  Left: "LEFT",
  Center: "CENTER",
  Right: "RIGHT"
};
var FormFieldDateConfigFormatEnum = {
  Date: "DATE",
  Time: "TIME"
};
var FormFieldFileConfigCategoryEnum = {
  Audio: "AUDIO",
  Video: "VIDEO",
  Image: "IMAGE",
  Document: "DOCUMENT",
  Archive: "ARCHIVE"
};
var FormFieldFileConfigStorageTypeEnum = {
  Managed: "MANAGED",
  Custom: "CUSTOM"
};
var FormFieldPasswordConfigHashEnum = {
  None: "NONE",
  Md5: "MD5",
  Sha1: "SHA1",
  Sha256: "SHA256",
  Sha512: "SHA512"
};
var FormFieldPaymentConfigChargeOneOffCurrencyEnum = {
  Aud: "AUD",
  Cad: "CAD",
  Chf: "CHF",
  Eur: "EUR",
  Gbp: "GBP",
  Inr: "INR",
  Mxn: "MXN",
  Sek: "SEK",
  Usd: "USD"
};
var FormsRequestParametersHydrateEnum = {
  FlowCount: "flow_count",
  Links: "links"
};
var GetBruteForceSettingsResponseContent;
(function(GetBruteForceSettingsResponseContent2) {
  let Shields;
  (function(Shields2) {
    Shields2.Item = {
      Block: "block",
      UserNotification: "user_notification"
    };
  })(Shields = GetBruteForceSettingsResponseContent2.Shields || (GetBruteForceSettingsResponseContent2.Shields = {}));
  GetBruteForceSettingsResponseContent2.Mode = {
    CountPerIdentifierAndIp: "count_per_identifier_and_ip",
    CountPerIdentifier: "count_per_identifier"
  };
})(GetBruteForceSettingsResponseContent || (GetBruteForceSettingsResponseContent = {}));
var GetFlowRequestParametersHydrateEnum = {
  FormCount: "form_count",
  Forms: "forms"
};
var GuardianEnrollmentFactorEnum = {
  PushNotification: "push-notification",
  Phone: "phone",
  Email: "email",
  Otp: "otp",
  WebauthnRoaming: "webauthn-roaming",
  WebauthnPlatform: "webauthn-platform"
};
var GuardianEnrollmentStatus = {
  Pending: "pending",
  Confirmed: "confirmed"
};
var GuardianFactorNameEnum = {
  PushNotification: "push-notification",
  Sms: "sms",
  Email: "email",
  Duo: "duo",
  Otp: "otp",
  WebauthnRoaming: "webauthn-roaming",
  WebauthnPlatform: "webauthn-platform",
  RecoveryCode: "recovery-code"
};
var GuardianFactorPhoneFactorMessageTypeEnum = {
  Sms: "sms",
  Voice: "voice"
};
var GuardianFactorsProviderPushNotificationProviderDataEnum = {
  Guardian: "guardian",
  Sns: "sns",
  Direct: "direct"
};
var GuardianFactorsProviderSmsProviderEnum = {
  Auth0: "auth0",
  Twilio: "twilio",
  PhoneMessageHook: "phone-message-hook"
};
var HookTriggerIdEnum = {
  CredentialsExchange: "credentials-exchange",
  PreUserRegistration: "pre-user-registration",
  PostUserRegistration: "post-user-registration",
  PostChangePassword: "post-change-password",
  SendPhoneMessage: "send-phone-message"
};
var IdentityProviderEnum = {
  Ad: "ad",
  Adfs: "adfs",
  Amazon: "amazon",
  Apple: "apple",
  Dropbox: "dropbox",
  Bitbucket: "bitbucket",
  Aol: "aol",
  Auth0Oidc: "auth0-oidc",
  Auth0: "auth0",
  Baidu: "baidu",
  Bitly: "bitly",
  Box: "box",
  Custom: "custom",
  Daccount: "daccount",
  Dwolla: "dwolla",
  Email: "email",
  EvernoteSandbox: "evernote-sandbox",
  Evernote: "evernote",
  Exact: "exact",
  Facebook: "facebook",
  Fitbit: "fitbit",
  Flickr: "flickr",
  Github: "github",
  GoogleApps: "google-apps",
  GoogleOauth2: "google-oauth2",
  Instagram: "instagram",
  Ip: "ip",
  Line: "line",
  Linkedin: "linkedin",
  Miicard: "miicard",
  Oauth1: "oauth1",
  Oauth2: "oauth2",
  Office365: "office365",
  Oidc: "oidc",
  Okta: "okta",
  Paypal: "paypal",
  PaypalSandbox: "paypal-sandbox",
  Pingfederate: "pingfederate",
  Planningcenter: "planningcenter",
  Renren: "renren",
  SalesforceCommunity: "salesforce-community",
  SalesforceSandbox: "salesforce-sandbox",
  Salesforce: "salesforce",
  Samlp: "samlp",
  Sharepoint: "sharepoint",
  Shopify: "shopify",
  Shop: "shop",
  Sms: "sms",
  Soundcloud: "soundcloud",
  ThecitySandbox: "thecity-sandbox",
  Thecity: "thecity",
  Thirtysevensignals: "thirtysevensignals",
  Twitter: "twitter",
  Untappd: "untappd",
  Vkontakte: "vkontakte",
  Waad: "waad",
  Weibo: "weibo",
  Windowslive: "windowslive",
  Wordpress: "wordpress",
  Yahoo: "yahoo",
  Yammer: "yammer",
  Yandex: "yandex"
};
var IntegrationFeatureTypeEnum = {
  Unspecified: "unspecified",
  Action: "action",
  SocialConnection: "social_connection",
  LogStream: "log_stream",
  SsoIntegration: "sso_integration",
  SmsProvider: "sms_provider"
};
var IntegrationRequiredParamTypeEnum = {
  Unspecified: "UNSPECIFIED",
  String: "STRING"
};
var JobFileFormatEnum = {
  Json: "json",
  Csv: "csv"
};
var LogStreamDatadogRegionEnum = {
  Us: "us",
  Eu: "eu",
  Us3: "us3",
  Us5: "us5"
};
var LogStreamEventBridgeSinkRegionEnum = {
  AfSouth1: "af-south-1",
  ApEast1: "ap-east-1",
  ApEast2: "ap-east-2",
  ApNortheast1: "ap-northeast-1",
  ApNortheast2: "ap-northeast-2",
  ApNortheast3: "ap-northeast-3",
  ApSouth1: "ap-south-1",
  ApSouth2: "ap-south-2",
  ApSoutheast1: "ap-southeast-1",
  ApSoutheast2: "ap-southeast-2",
  ApSoutheast3: "ap-southeast-3",
  ApSoutheast4: "ap-southeast-4",
  ApSoutheast5: "ap-southeast-5",
  ApSoutheast6: "ap-southeast-6",
  ApSoutheast7: "ap-southeast-7",
  CaCentral1: "ca-central-1",
  CaWest1: "ca-west-1",
  EuCentral1: "eu-central-1",
  EuCentral2: "eu-central-2",
  EuNorth1: "eu-north-1",
  EuSouth1: "eu-south-1",
  EuSouth2: "eu-south-2",
  EuWest1: "eu-west-1",
  EuWest2: "eu-west-2",
  EuWest3: "eu-west-3",
  IlCentral1: "il-central-1",
  MeCentral1: "me-central-1",
  MeSouth1: "me-south-1",
  MxCentral1: "mx-central-1",
  SaEast1: "sa-east-1",
  UsGovEast1: "us-gov-east-1",
  UsGovWest1: "us-gov-west-1",
  UsEast1: "us-east-1",
  UsEast2: "us-east-2",
  UsWest1: "us-west-1",
  UsWest2: "us-west-2"
};
var LogStreamEventGridRegionEnum = {
  Australiacentral: "australiacentral",
  Australiaeast: "australiaeast",
  Australiasoutheast: "australiasoutheast",
  Brazilsouth: "brazilsouth",
  Canadacentral: "canadacentral",
  Canadaeast: "canadaeast",
  Centralindia: "centralindia",
  Centralus: "centralus",
  Eastasia: "eastasia",
  Eastus: "eastus",
  Eastus2: "eastus2",
  Francecentral: "francecentral",
  Germanywestcentral: "germanywestcentral",
  Japaneast: "japaneast",
  Japanwest: "japanwest",
  Koreacentral: "koreacentral",
  Koreasouth: "koreasouth",
  Northcentralus: "northcentralus",
  Northeurope: "northeurope",
  Norwayeast: "norwayeast",
  Southafricanorth: "southafricanorth",
  Southcentralus: "southcentralus",
  Southeastasia: "southeastasia",
  Southindia: "southindia",
  Swedencentral: "swedencentral",
  Switzerlandnorth: "switzerlandnorth",
  Uaenorth: "uaenorth",
  Uksouth: "uksouth",
  Ukwest: "ukwest",
  Westcentralus: "westcentralus",
  Westeurope: "westeurope",
  Westindia: "westindia",
  Westus: "westus",
  Westus2: "westus2"
};
var LogStreamFilterGroupNameEnum = {
  AuthLoginFail: "auth.login.fail",
  AuthLoginNotification: "auth.login.notification",
  AuthLoginSuccess: "auth.login.success",
  AuthLogoutFail: "auth.logout.fail",
  AuthLogoutSuccess: "auth.logout.success",
  AuthSignupFail: "auth.signup.fail",
  AuthSignupSuccess: "auth.signup.success",
  AuthSilentAuthFail: "auth.silent_auth.fail",
  AuthSilentAuthSuccess: "auth.silent_auth.success",
  AuthTokenExchangeFail: "auth.token_exchange.fail",
  AuthTokenExchangeSuccess: "auth.token_exchange.success",
  ManagementFail: "management.fail",
  ManagementSuccess: "management.success",
  ScimEvent: "scim.event",
  SystemNotification: "system.notification",
  UserFail: "user.fail",
  UserNotification: "user.notification",
  UserSuccess: "user.success",
  Actions: "actions",
  Other: "other"
};
var LogStreamHttpContentFormatEnum = {
  Jsonarray: "JSONARRAY",
  Jsonlines: "JSONLINES",
  Jsonobject: "JSONOBJECT"
};
var LogStreamMixpanelRegionEnum = {
  Us: "us",
  Eu: "eu"
};
var LogStreamPiiLogFieldsEnum = {
  FirstName: "first_name",
  LastName: "last_name",
  Username: "username",
  Email: "email",
  Phone: "phone",
  Address: "address"
};
var LogStreamPiiMethodEnum = {
  Mask: "mask",
  Hash: "hash"
};
var LogStreamStatusEnum = {
  Active: "active",
  Paused: "paused",
  Suspended: "suspended"
};
var MfaPolicyEnum = {
  AllApplications: "all-applications",
  ConfidenceScore: "confidence-score"
};
var NetworkAclRuleScopeEnum = {
  Management: "management",
  Authentication: "authentication",
  Tenant: "tenant",
  DynamicClientRegistration: "dynamic_client_registration"
};
var OrganizationDiscoveryDomainStatus = {
  Pending: "pending",
  Verified: "verified"
};
var OrganizationUsageEnum = {
  Deny: "deny",
  Allow: "allow",
  Require: "require"
};
var PartialGroupsEnum = {
  Login: "login",
  LoginId: "login-id",
  LoginPassword: "login-password",
  LoginPasswordless: "login-passwordless",
  Signup: "signup",
  SignupId: "signup-id",
  SignupPassword: "signup-password",
  CustomizedConsent: "customized-consent"
};
var PhoneProviderDeliveryMethodEnum = {
  Text: "text",
  Voice: "voice"
};
var PhoneProviderNameEnum = {
  Twilio: "twilio",
  Custom: "custom"
};
var PhoneTemplateNotificationTypeEnum = {
  OtpVerify: "otp_verify",
  OtpEnroll: "otp_enroll",
  ChangePassword: "change_password",
  BlockedAccount: "blocked_account",
  PasswordBreach: "password_breach"
};
var PreferredAuthenticationMethodEnum = {
  Voice: "voice",
  Sms: "sms"
};
var PromptGroupNameEnum = {
  Login: "login",
  LoginId: "login-id",
  LoginPassword: "login-password",
  LoginPasswordless: "login-passwordless",
  LoginEmailVerification: "login-email-verification",
  Signup: "signup",
  SignupId: "signup-id",
  SignupPassword: "signup-password",
  PhoneIdentifierEnrollment: "phone-identifier-enrollment",
  PhoneIdentifierChallenge: "phone-identifier-challenge",
  EmailIdentifierChallenge: "email-identifier-challenge",
  ResetPassword: "reset-password",
  CustomForm: "custom-form",
  Consent: "consent",
  CustomizedConsent: "customized-consent",
  Logout: "logout",
  MfaPush: "mfa-push",
  MfaOtp: "mfa-otp",
  MfaVoice: "mfa-voice",
  MfaPhone: "mfa-phone",
  MfaWebauthn: "mfa-webauthn",
  MfaSms: "mfa-sms",
  MfaEmail: "mfa-email",
  MfaRecoveryCode: "mfa-recovery-code",
  Mfa: "mfa",
  Status: "status",
  DeviceFlow: "device-flow",
  EmailVerification: "email-verification",
  EmailOtpChallenge: "email-otp-challenge",
  Organizations: "organizations",
  Invitation: "invitation",
  Common: "common",
  Passkeys: "passkeys",
  Captcha: "captcha",
  BruteForceProtection: "brute-force-protection",
  AsyncApprovalFlow: "async-approval-flow"
};
var PromptLanguageEnum = {
  Am: "am",
  Ar: "ar",
  ArEg: "ar-EG",
  ArSa: "ar-SA",
  Az: "az",
  Bg: "bg",
  Bn: "bn",
  Bs: "bs",
  CaEs: "ca-ES",
  Cnr: "cnr",
  Cs: "cs",
  Cy: "cy",
  Da: "da",
  De: "de",
  El: "el",
  En: "en",
  EnCa: "en-CA",
  Es: "es",
  Es419: "es-419",
  EsAr: "es-AR",
  EsMx: "es-MX",
  Et: "et",
  EuEs: "eu-ES",
  Fa: "fa",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  FrFr: "fr-FR",
  GlEs: "gl-ES",
  Gu: "gu",
  He: "he",
  Hi: "hi",
  Hr: "hr",
  Hu: "hu",
  Hy: "hy",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ka: "ka",
  Kk: "kk",
  Kn: "kn",
  Ko: "ko",
  Lt: "lt",
  Lv: "lv",
  Mk: "mk",
  Ml: "ml",
  Mn: "mn",
  Mr: "mr",
  Ms: "ms",
  My: "my",
  Nb: "nb",
  Nl: "nl",
  Nn: "nn",
  No: "no",
  Pa: "pa",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  PtPt: "pt-PT",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  So: "so",
  Sq: "sq",
  Sr: "sr",
  Sv: "sv",
  Sw: "sw",
  Ta: "ta",
  Te: "te",
  Th: "th",
  Tl: "tl",
  Tr: "tr",
  Uk: "uk",
  Ur: "ur",
  Vi: "vi",
  Zgh: "zgh",
  ZhCn: "zh-CN",
  ZhHk: "zh-HK",
  ZhTw: "zh-TW"
};
var PublicKeyCredentialAlgorithmEnum = {
  Rs256: "RS256",
  Rs384: "RS384",
  Ps256: "PS256"
};
var RefreshTokenExpirationTypeEnum = {
  Expiring: "expiring",
  NonExpiring: "non-expiring"
};
var RefreshTokenRotationTypeEnum = {
  Rotating: "rotating",
  NonRotating: "non-rotating"
};
var ResourceServerProofOfPossessionMechanismEnum = {
  Mtls: "mtls",
  Dpop: "dpop"
};
var ResourceServerSubjectTypeAuthorizationClientPolicyEnum = {
  DenyAll: "deny_all",
  RequireClientGrant: "require_client_grant"
};
var ResourceServerSubjectTypeAuthorizationUserPolicyEnum = {
  AllowAll: "allow_all",
  DenyAll: "deny_all",
  RequireClientGrant: "require_client_grant"
};
var ResourceServerTokenDialectResponseEnum = {
  AccessToken: "access_token",
  AccessTokenAuthz: "access_token_authz",
  Rfc9068Profile: "rfc9068_profile",
  Rfc9068ProfileAuthz: "rfc9068_profile_authz"
};
var ResourceServerTokenDialectSchemaEnum = {
  AccessToken: "access_token",
  AccessTokenAuthz: "access_token_authz",
  Rfc9068Profile: "rfc9068_profile",
  Rfc9068ProfileAuthz: "rfc9068_profile_authz"
};
var ResourceServerTokenEncryptionAlgorithmEnum = {
  RsaOaep256: "RSA-OAEP-256",
  RsaOaep384: "RSA-OAEP-384",
  RsaOaep512: "RSA-OAEP-512"
};
var RotateConnectionKeysSigningAlgEnum = {
  Rs256: "RS256",
  Rs512: "RS512",
  Ps256: "PS256",
  Es256: "ES256"
};
var ScreenGroupNameEnum = {
  Login: "login",
  LoginId: "login-id",
  LoginPassword: "login-password",
  LoginPasswordlessEmailCode: "login-passwordless-email-code",
  LoginPasswordlessEmailLink: "login-passwordless-email-link",
  LoginPasswordlessSmsOtp: "login-passwordless-sms-otp",
  LoginEmailVerification: "login-email-verification",
  Signup: "signup",
  SignupId: "signup-id",
  SignupPassword: "signup-password",
  PhoneIdentifierEnrollment: "phone-identifier-enrollment",
  PhoneIdentifierChallenge: "phone-identifier-challenge",
  EmailIdentifierChallenge: "email-identifier-challenge",
  ResetPasswordRequest: "reset-password-request",
  ResetPasswordEmail: "reset-password-email",
  ResetPassword: "reset-password",
  ResetPasswordSuccess: "reset-password-success",
  ResetPasswordError: "reset-password-error",
  ResetPasswordMfaEmailChallenge: "reset-password-mfa-email-challenge",
  ResetPasswordMfaOtpChallenge: "reset-password-mfa-otp-challenge",
  ResetPasswordMfaPhoneChallenge: "reset-password-mfa-phone-challenge",
  ResetPasswordMfaPushChallengePush: "reset-password-mfa-push-challenge-push",
  ResetPasswordMfaRecoveryCodeChallenge: "reset-password-mfa-recovery-code-challenge",
  ResetPasswordMfaSmsChallenge: "reset-password-mfa-sms-challenge",
  ResetPasswordMfaVoiceChallenge: "reset-password-mfa-voice-challenge",
  ResetPasswordMfaWebauthnPlatformChallenge: "reset-password-mfa-webauthn-platform-challenge",
  ResetPasswordMfaWebauthnRoamingChallenge: "reset-password-mfa-webauthn-roaming-challenge",
  CustomForm: "custom-form",
  Consent: "consent",
  CustomizedConsent: "customized-consent",
  Logout: "logout",
  LogoutComplete: "logout-complete",
  LogoutAborted: "logout-aborted",
  MfaPushWelcome: "mfa-push-welcome",
  MfaPushEnrollmentQr: "mfa-push-enrollment-qr",
  MfaPushEnrollmentCode: "mfa-push-enrollment-code",
  MfaPushSuccess: "mfa-push-success",
  MfaPushChallengePush: "mfa-push-challenge-push",
  MfaPushList: "mfa-push-list",
  MfaOtpEnrollmentQr: "mfa-otp-enrollment-qr",
  MfaOtpEnrollmentCode: "mfa-otp-enrollment-code",
  MfaOtpChallenge: "mfa-otp-challenge",
  MfaVoiceEnrollment: "mfa-voice-enrollment",
  MfaVoiceChallenge: "mfa-voice-challenge",
  MfaPhoneChallenge: "mfa-phone-challenge",
  MfaPhoneEnrollment: "mfa-phone-enrollment",
  MfaWebauthnPlatformEnrollment: "mfa-webauthn-platform-enrollment",
  MfaWebauthnRoamingEnrollment: "mfa-webauthn-roaming-enrollment",
  MfaWebauthnPlatformChallenge: "mfa-webauthn-platform-challenge",
  MfaWebauthnRoamingChallenge: "mfa-webauthn-roaming-challenge",
  MfaWebauthnChangeKeyNickname: "mfa-webauthn-change-key-nickname",
  MfaWebauthnEnrollmentSuccess: "mfa-webauthn-enrollment-success",
  MfaWebauthnError: "mfa-webauthn-error",
  MfaWebauthnNotAvailableError: "mfa-webauthn-not-available-error",
  MfaCountryCodes: "mfa-country-codes",
  MfaSmsEnrollment: "mfa-sms-enrollment",
  MfaSmsChallenge: "mfa-sms-challenge",
  MfaSmsList: "mfa-sms-list",
  MfaEmailChallenge: "mfa-email-challenge",
  MfaEmailList: "mfa-email-list",
  MfaRecoveryCodeEnrollment: "mfa-recovery-code-enrollment",
  MfaRecoveryCodeChallengeNewCode: "mfa-recovery-code-challenge-new-code",
  MfaRecoveryCodeChallenge: "mfa-recovery-code-challenge",
  MfaDetectBrowserCapabilities: "mfa-detect-browser-capabilities",
  MfaEnrollResult: "mfa-enroll-result",
  MfaLoginOptions: "mfa-login-options",
  MfaBeginEnrollOptions: "mfa-begin-enroll-options",
  Status: "status",
  DeviceCodeActivation: "device-code-activation",
  DeviceCodeActivationAllowed: "device-code-activation-allowed",
  DeviceCodeActivationDenied: "device-code-activation-denied",
  DeviceCodeConfirmation: "device-code-confirmation",
  EmailVerificationResult: "email-verification-result",
  EmailOtpChallenge: "email-otp-challenge",
  OrganizationSelection: "organization-selection",
  OrganizationPicker: "organization-picker",
  PreLoginOrganizationPicker: "pre-login-organization-picker",
  AcceptInvitation: "accept-invitation",
  RedeemTicket: "redeem-ticket",
  PasskeyEnrollment: "passkey-enrollment",
  PasskeyEnrollmentLocal: "passkey-enrollment-local",
  InterstitialCaptcha: "interstitial-captcha",
  BruteForceProtectionUnblock: "brute-force-protection-unblock",
  BruteForceProtectionUnblockSuccess: "brute-force-protection-unblock-success",
  BruteForceProtectionUnblockFailure: "brute-force-protection-unblock-failure",
  AsyncApprovalError: "async-approval-error",
  AsyncApprovalWrongUser: "async-approval-wrong-user",
  AsyncApprovalAccepted: "async-approval-accepted",
  AsyncApprovalDenied: "async-approval-denied"
};
var SearchEngineVersionsEnum = {
  V1: "v1",
  V2: "v2",
  V3: "v3"
};
var SelfServiceProfileAllowedStrategyEnum = {
  Oidc: "oidc",
  Samlp: "samlp",
  Waad: "waad",
  GoogleApps: "google-apps",
  Adfs: "adfs",
  Okta: "okta",
  KeycloakSamlp: "keycloak-samlp",
  Pingfederate: "pingfederate"
};
var SelfServiceProfileSsoTicketDomainVerificationEnum = {
  None: "none",
  Optional: "optional",
  Required: "required"
};
var SelfServiceProfileSsoTicketIdpInitiatedClientProtocolEnum = {
  Samlp: "samlp",
  Wsfed: "wsfed",
  Oauth2: "oauth2"
};
var SelfServiceProfileSsoTicketProvisioningScopeEnum = {
  GetUsers: "get:users",
  PostUsers: "post:users",
  PutUsers: "put:users",
  PatchUsers: "patch:users",
  DeleteUsers: "delete:users"
};
var SessionCookieMetadataModeEnum = {
  NonPersistent: "non-persistent",
  Persistent: "persistent"
};
var SessionCookieModeEnum = {
  Persistent: "persistent",
  NonPersistent: "non-persistent"
};
var SigningAlgorithmEnum = {
  Hs256: "HS256",
  Rs256: "RS256",
  Rs512: "RS512",
  Ps256: "PS256"
};
var SignupStatusEnum = {
  Required: "required",
  Optional: "optional",
  Inactive: "inactive"
};
var SupportedLocales = {
  Am: "am",
  Ar: "ar",
  ArEg: "ar-EG",
  ArSa: "ar-SA",
  Az: "az",
  Bg: "bg",
  Bn: "bn",
  Bs: "bs",
  CaEs: "ca-ES",
  Cnr: "cnr",
  Cs: "cs",
  Cy: "cy",
  Da: "da",
  De: "de",
  El: "el",
  En: "en",
  EnCa: "en-CA",
  Es: "es",
  Es419: "es-419",
  EsAr: "es-AR",
  EsMx: "es-MX",
  Et: "et",
  EuEs: "eu-ES",
  Fa: "fa",
  Fi: "fi",
  Fr: "fr",
  FrCa: "fr-CA",
  FrFr: "fr-FR",
  GlEs: "gl-ES",
  Gu: "gu",
  He: "he",
  Hi: "hi",
  Hr: "hr",
  Hu: "hu",
  Hy: "hy",
  Id: "id",
  Is: "is",
  It: "it",
  Ja: "ja",
  Ka: "ka",
  Kk: "kk",
  Kn: "kn",
  Ko: "ko",
  Lt: "lt",
  Lv: "lv",
  Mk: "mk",
  Ml: "ml",
  Mn: "mn",
  Mr: "mr",
  Ms: "ms",
  My: "my",
  Nb: "nb",
  Nl: "nl",
  Nn: "nn",
  No: "no",
  Pa: "pa",
  Pl: "pl",
  Pt: "pt",
  PtBr: "pt-BR",
  PtPt: "pt-PT",
  Ro: "ro",
  Ru: "ru",
  Sk: "sk",
  Sl: "sl",
  So: "so",
  Sq: "sq",
  Sr: "sr",
  Sv: "sv",
  Sw: "sw",
  Ta: "ta",
  Te: "te",
  Th: "th",
  Tl: "tl",
  Tr: "tr",
  Uk: "uk",
  Ur: "ur",
  Vi: "vi",
  Zgh: "zgh",
  ZhCn: "zh-CN",
  ZhHk: "zh-HK",
  ZhTw: "zh-TW"
};
var SuspiciousIpThrottlingShieldsEnum = {
  Block: "block",
  AdminNotification: "admin_notification"
};
var TenantSettingsDeviceFlowCharset = {
  Base20: "base20",
  Digits: "digits"
};
var TenantSettingsResourceParameterProfile = {
  Audience: "audience",
  Compatibility: "compatibility"
};
var TwilioProviderDeliveryMethodEnum = {
  Text: "text",
  Voice: "voice"
};
var UniversalLoginExperienceEnum = {
  New: "new",
  Classic: "classic"
};
var UpdateBruteForceSettingsResponseContent;
(function(UpdateBruteForceSettingsResponseContent2) {
  let Shields;
  (function(Shields2) {
    Shields2.Item = {
      Block: "block",
      UserNotification: "user_notification"
    };
  })(Shields = UpdateBruteForceSettingsResponseContent2.Shields || (UpdateBruteForceSettingsResponseContent2.Shields = {}));
  UpdateBruteForceSettingsResponseContent2.Mode = {
    CountPerIdentifierAndIp: "count_per_identifier_and_ip",
    CountPerIdentifier: "count_per_identifier"
  };
})(UpdateBruteForceSettingsResponseContent || (UpdateBruteForceSettingsResponseContent = {}));
var UserAttributeProfileUserIdOidcStrategyOverrideMapping = {
  Sub: "sub",
  Oid: "oid",
  Email: "email"
};
var UserAuthenticationMethodPropertiesEnum = {
  Totp: "totp",
  Push: "push",
  Sms: "sms",
  Voice: "voice"
};
var UserEnrollmentAuthMethodEnum = {
  Authenticator: "authenticator",
  Guardian: "guardian",
  Sms: "sms",
  WebauthnPlatform: "webauthn-platform",
  WebauthnRoaming: "webauthn-roaming"
};
var UserEnrollmentStatusEnum = {
  Pending: "pending",
  Confirmed: "confirmed"
};
var UserIdentityProviderEnum = {
  Ad: "ad",
  Adfs: "adfs",
  Amazon: "amazon",
  Apple: "apple",
  Dropbox: "dropbox",
  Bitbucket: "bitbucket",
  Aol: "aol",
  Auth0Oidc: "auth0-oidc",
  Auth0: "auth0",
  Baidu: "baidu",
  Bitly: "bitly",
  Box: "box",
  Custom: "custom",
  Daccount: "daccount",
  Dwolla: "dwolla",
  Email: "email",
  EvernoteSandbox: "evernote-sandbox",
  Evernote: "evernote",
  Exact: "exact",
  Facebook: "facebook",
  Fitbit: "fitbit",
  Flickr: "flickr",
  Github: "github",
  GoogleApps: "google-apps",
  GoogleOauth2: "google-oauth2",
  Instagram: "instagram",
  Ip: "ip",
  Line: "line",
  Linkedin: "linkedin",
  Miicard: "miicard",
  Oauth1: "oauth1",
  Oauth2: "oauth2",
  Office365: "office365",
  Oidc: "oidc",
  Okta: "okta",
  Paypal: "paypal",
  PaypalSandbox: "paypal-sandbox",
  Pingfederate: "pingfederate",
  Planningcenter: "planningcenter",
  Renren: "renren",
  SalesforceCommunity: "salesforce-community",
  SalesforceSandbox: "salesforce-sandbox",
  Salesforce: "salesforce",
  Samlp: "samlp",
  Sharepoint: "sharepoint",
  Shopify: "shopify",
  Shop: "shop",
  Sms: "sms",
  Soundcloud: "soundcloud",
  ThecitySandbox: "thecity-sandbox",
  Thecity: "thecity",
  Thirtysevensignals: "thirtysevensignals",
  Twitter: "twitter",
  Untappd: "untappd",
  Vkontakte: "vkontakte",
  Waad: "waad",
  Weibo: "weibo",
  Windowslive: "windowslive",
  Wordpress: "wordpress",
  Yahoo: "yahoo",
  Yammer: "yammer",
  Yandex: "yandex"
};
var UserMultifactorProviderEnum = {
  Duo: "duo",
  GoogleAuthenticator: "google-authenticator"
};
var VerificationMethodEnum = {
  Link: "link",
  Otp: "otp"
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/auth/NoOpAuthProvider.mjs
var NoOpAuthProvider = class {
  getAuthRequest() {
    return Promise.resolve({ headers: {} });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/EndpointSupplier.mjs
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EndpointSupplier = {
  get: (supplier, arg) => __awaiter(void 0, void 0, void 0, function* () {
    if (typeof supplier === "function") {
      return supplier(arg);
    } else {
      return supplier;
    }
  })
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/logging/logger.mjs
var LogLevel = {
  Debug: "debug",
  Info: "info",
  Warn: "warn",
  Error: "error"
};
var logLevelMap = {
  [LogLevel.Debug]: 1,
  [LogLevel.Info]: 2,
  [LogLevel.Warn]: 3,
  [LogLevel.Error]: 4
};
var ConsoleLogger = class {
  debug(message2, ...args) {
    console.debug(message2, ...args);
  }
  info(message2, ...args) {
    console.info(message2, ...args);
  }
  warn(message2, ...args) {
    console.warn(message2, ...args);
  }
  error(message2, ...args) {
    console.error(message2, ...args);
  }
};
var Logger = class {
  /**
   * Creates a new logger instance.
   * @param config - Logger configuration
   */
  constructor(config) {
    this.level = logLevelMap[config.level];
    this.logger = config.logger;
    this.silent = config.silent;
  }
  /**
   * Checks if a log level should be output based on configuration.
   * @param level - The log level to check
   * @returns True if the level should be logged
   */
  shouldLog(level) {
    return !this.silent && this.level <= logLevelMap[level];
  }
  /**
   * Checks if debug logging is enabled.
   * @returns True if debug logs should be output
   */
  isDebug() {
    return this.shouldLog(LogLevel.Debug);
  }
  /**
   * Logs a debug message if debug logging is enabled.
   * @param message - The message to log
   * @param args - Additional arguments to log
   */
  debug(message2, ...args) {
    if (this.isDebug()) {
      this.logger.debug(message2, ...args);
    }
  }
  /**
   * Checks if info logging is enabled.
   * @returns True if info logs should be output
   */
  isInfo() {
    return this.shouldLog(LogLevel.Info);
  }
  /**
   * Logs an info message if info logging is enabled.
   * @param message - The message to log
   * @param args - Additional arguments to log
   */
  info(message2, ...args) {
    if (this.isInfo()) {
      this.logger.info(message2, ...args);
    }
  }
  /**
   * Checks if warning logging is enabled.
   * @returns True if warning logs should be output
   */
  isWarn() {
    return this.shouldLog(LogLevel.Warn);
  }
  /**
   * Logs a warning message if warning logging is enabled.
   * @param message - The message to log
   * @param args - Additional arguments to log
   */
  warn(message2, ...args) {
    if (this.isWarn()) {
      this.logger.warn(message2, ...args);
    }
  }
  /**
   * Checks if error logging is enabled.
   * @returns True if error logs should be output
   */
  isError() {
    return this.shouldLog(LogLevel.Error);
  }
  /**
   * Logs an error message if error logging is enabled.
   * @param message - The message to log
   * @param args - Additional arguments to log
   */
  error(message2, ...args) {
    if (this.isError()) {
      this.logger.error(message2, ...args);
    }
  }
};
function createLogger(config) {
  var _a, _b, _c;
  if (config == null) {
    return defaultLogger;
  }
  if (config instanceof Logger) {
    return config;
  }
  config = config !== null && config !== void 0 ? config : {};
  (_a = config.level) !== null && _a !== void 0 ? _a : config.level = LogLevel.Info;
  (_b = config.logger) !== null && _b !== void 0 ? _b : config.logger = new ConsoleLogger();
  (_c = config.silent) !== null && _c !== void 0 ? _c : config.silent = true;
  return new Logger(config);
}
var defaultLogger = new Logger({
  level: LogLevel.Info,
  logger: new ConsoleLogger(),
  silent: true
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/url/qs.mjs
var defaultQsOptions = {
  arrayFormat: "indices",
  encode: true
};
function encodeValue(value, shouldEncode) {
  if (value === void 0) {
    return "";
  }
  if (value === null) {
    return "";
  }
  const stringValue = String(value);
  return shouldEncode ? encodeURIComponent(stringValue) : stringValue;
}
function stringifyObject(obj, prefix = "", options) {
  const parts = [];
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}[${key}]` : key;
    if (value === void 0) {
      continue;
    }
    if (Array.isArray(value)) {
      if (value.length === 0) {
        continue;
      }
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        if (item === void 0) {
          continue;
        }
        if (typeof item === "object" && !Array.isArray(item) && item !== null) {
          const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
          parts.push(...stringifyObject(item, arrayKey, options));
        } else {
          const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
          const encodedKey = options.encode ? encodeURIComponent(arrayKey) : arrayKey;
          parts.push(`${encodedKey}=${encodeValue(item, options.encode)}`);
        }
      }
    } else if (typeof value === "object" && value !== null) {
      if (Object.keys(value).length === 0) {
        continue;
      }
      parts.push(...stringifyObject(value, fullKey, options));
    } else {
      const encodedKey = options.encode ? encodeURIComponent(fullKey) : fullKey;
      parts.push(`${encodedKey}=${encodeValue(value, options.encode)}`);
    }
  }
  return parts;
}
function toQueryString(obj, options) {
  if (obj == null || typeof obj !== "object") {
    return "";
  }
  const parts = stringifyObject(obj, "", Object.assign(Object.assign({}, defaultQsOptions), options));
  return parts.join("&");
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/createRequestUrl.mjs
function createRequestUrl(baseUrl, queryParameters) {
  const queryString = toQueryString(queryParameters, { arrayFormat: "repeat" });
  return queryString ? `${baseUrl}?${queryString}` : baseUrl;
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/BinaryResponse.mjs
function getBinaryResponse(response) {
  const binaryResponse = {
    get bodyUsed() {
      return response.bodyUsed;
    },
    stream: () => response.body,
    arrayBuffer: response.arrayBuffer.bind(response),
    blob: response.blob.bind(response)
  };
  if ("bytes" in response && typeof response.bytes === "function") {
    binaryResponse.bytes = response.bytes.bind(response);
  }
  return binaryResponse;
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/getResponseBody.mjs
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getResponseBody(response, responseType) {
  return __awaiter2(this, void 0, void 0, function* () {
    switch (responseType) {
      case "binary-response":
        return getBinaryResponse(response);
      case "blob":
        return yield response.blob();
      case "arrayBuffer":
        return yield response.arrayBuffer();
      case "sse":
        if (response.body == null) {
          return {
            ok: false,
            error: {
              reason: "body-is-null",
              statusCode: response.status
            }
          };
        }
        return response.body;
      case "streaming":
        if (response.body == null) {
          return {
            ok: false,
            error: {
              reason: "body-is-null",
              statusCode: response.status
            }
          };
        }
        return response.body;
      case "text":
        return yield response.text();
    }
    const text = yield response.text();
    if (text.length > 0) {
      try {
        const responseBody = fromJson(text);
        return responseBody;
      } catch (_err) {
        return {
          ok: false,
          error: {
            reason: "non-json",
            statusCode: response.status,
            rawBody: text
          }
        };
      }
    }
    return void 0;
  });
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/getErrorResponseBody.mjs
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getErrorResponseBody(response) {
  return __awaiter3(this, void 0, void 0, function* () {
    var _a, _b, _c;
    let contentType = (_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    if (contentType == null || contentType.length === 0) {
      return getResponseBody(response);
    }
    if (contentType.indexOf(";") !== -1) {
      contentType = (_c = (_b = contentType.split(";")[0]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : "";
    }
    switch (contentType) {
      case "application/hal+json":
      case "application/json":
      case "application/ld+json":
      case "application/problem+json":
      case "application/vnd.api+json":
      case "text/json": {
        const text = yield response.text();
        return text.length > 0 ? fromJson(text) : void 0;
      }
      default:
        if (contentType.startsWith("application/vnd.") && contentType.endsWith("+json")) {
          const text = yield response.text();
          return text.length > 0 ? fromJson(text) : void 0;
        }
        return yield response.text();
    }
  });
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/getFetchFn.mjs
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getFetchFn() {
  return __awaiter4(this, void 0, void 0, function* () {
    return fetch;
  });
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/getRequestBody.mjs
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getRequestBody(_a) {
  return __awaiter5(this, arguments, void 0, function* ({ body, type }) {
    if (type === "form") {
      return toQueryString(body, { arrayFormat: "repeat", encode: true });
    }
    if (type.includes("json")) {
      return toJson(body);
    } else {
      return body;
    }
  });
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/Headers.mjs
var Headers2;
if (typeof globalThis.Headers !== "undefined") {
  Headers2 = globalThis.Headers;
} else {
  Headers2 = class Headers3 {
    constructor(init) {
      this.headers = /* @__PURE__ */ new Map();
      if (init) {
        if (init instanceof Headers3) {
          init.forEach((value, key) => this.append(key, value));
        } else if (Array.isArray(init)) {
          for (const [key, value] of init) {
            if (typeof key === "string" && typeof value === "string") {
              this.append(key, value);
            } else {
              throw new TypeError("Each header entry must be a [string, string] tuple");
            }
          }
        } else {
          for (const [key, value] of Object.entries(init)) {
            if (typeof value === "string") {
              this.append(key, value);
            } else {
              throw new TypeError("Header values must be strings");
            }
          }
        }
      }
    }
    append(name, value) {
      const key = name.toLowerCase();
      const existing = this.headers.get(key) || [];
      this.headers.set(key, [...existing, value]);
    }
    delete(name) {
      const key = name.toLowerCase();
      this.headers.delete(key);
    }
    get(name) {
      const key = name.toLowerCase();
      const values = this.headers.get(key);
      return values ? values.join(", ") : null;
    }
    has(name) {
      const key = name.toLowerCase();
      return this.headers.has(key);
    }
    set(name, value) {
      const key = name.toLowerCase();
      this.headers.set(key, [value]);
    }
    forEach(callbackfn, thisArg) {
      const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
      this.headers.forEach((values, key) => boundCallback(values.join(", "), key, this));
    }
    getSetCookie() {
      return this.headers.get("set-cookie") || [];
    }
    *entries() {
      for (const [key, values] of this.headers.entries()) {
        yield [key, values.join(", ")];
      }
    }
    *keys() {
      yield* this.headers.keys();
    }
    *values() {
      for (const values of this.headers.values()) {
        yield values.join(", ");
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
  };
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/signals.mjs
var TIMEOUT = "timeout";
function getTimeoutSignal(timeoutMs) {
  const controller = new AbortController();
  const abortId = setTimeout(() => controller.abort(TIMEOUT), timeoutMs);
  return { signal: controller.signal, abortId };
}
function anySignal(...args) {
  const signals = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
  const controller = new AbortController();
  for (const signal of signals) {
    if (signal.aborted) {
      controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason);
      break;
    }
    signal.addEventListener("abort", () => controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason), {
      signal: controller.signal
    });
  }
  return controller.signal;
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/makeRequest.mjs
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var makeRequest = (fetchFn, url, method, headers, requestBody, timeoutMs, abortSignal, withCredentials, duplex) => __awaiter6(void 0, void 0, void 0, function* () {
  const signals = [];
  let timeoutAbortId;
  if (timeoutMs != null) {
    const { signal, abortId } = getTimeoutSignal(timeoutMs);
    timeoutAbortId = abortId;
    signals.push(signal);
  }
  if (abortSignal != null) {
    signals.push(abortSignal);
  }
  const newSignals = anySignal(signals);
  const response = yield fetchFn(url, {
    method,
    headers,
    body: requestBody,
    signal: newSignals,
    credentials: withCredentials ? "include" : void 0,
    // @ts-ignore
    duplex
  });
  if (timeoutAbortId != null) {
    clearTimeout(timeoutAbortId);
  }
  return response;
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/RawResponse.mjs
var abortRawResponse = {
  headers: new Headers2(),
  redirected: false,
  status: 499,
  statusText: "Client Closed Request",
  type: "error",
  url: ""
};
var unknownRawResponse = {
  headers: new Headers2(),
  redirected: false,
  status: 0,
  statusText: "Unknown Error",
  type: "error",
  url: ""
};
function toRawResponse(response) {
  return {
    headers: response.headers,
    redirected: response.redirected,
    status: response.status,
    statusText: response.statusText,
    type: response.type,
    url: response.url
  };
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/requestWithRetries.mjs
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var INITIAL_RETRY_DELAY = 1e3;
var MAX_RETRY_DELAY = 6e4;
var DEFAULT_MAX_RETRIES = 2;
var JITTER_FACTOR = 0.2;
function addPositiveJitter(delay) {
  const jitterMultiplier = 1 + Math.random() * JITTER_FACTOR;
  return delay * jitterMultiplier;
}
function addSymmetricJitter(delay) {
  const jitterMultiplier = 1 + (Math.random() - 0.5) * JITTER_FACTOR;
  return delay * jitterMultiplier;
}
function getRetryDelayFromHeaders(response, retryAttempt) {
  const retryAfter = response.headers.get("Retry-After");
  if (retryAfter) {
    const retryAfterSeconds = parseInt(retryAfter, 10);
    if (!Number.isNaN(retryAfterSeconds) && retryAfterSeconds > 0) {
      return Math.min(retryAfterSeconds * 1e3, MAX_RETRY_DELAY);
    }
    const retryAfterDate = new Date(retryAfter);
    if (!Number.isNaN(retryAfterDate.getTime())) {
      const delay = retryAfterDate.getTime() - Date.now();
      if (delay > 0) {
        return Math.min(Math.max(delay, 0), MAX_RETRY_DELAY);
      }
    }
  }
  const rateLimitReset = response.headers.get("X-RateLimit-Reset");
  if (rateLimitReset) {
    const resetTime = parseInt(rateLimitReset, 10);
    if (!Number.isNaN(resetTime)) {
      const delay = resetTime * 1e3 - Date.now();
      if (delay > 0) {
        return addPositiveJitter(Math.min(delay, MAX_RETRY_DELAY));
      }
    }
  }
  return addSymmetricJitter(Math.min(INITIAL_RETRY_DELAY * Math.pow(2, retryAttempt), MAX_RETRY_DELAY));
}
function requestWithRetries(requestFn_1) {
  return __awaiter7(this, arguments, void 0, function* (requestFn, maxRetries = DEFAULT_MAX_RETRIES) {
    let response = yield requestFn();
    for (let i = 0; i < maxRetries; ++i) {
      if ([408, 429].includes(response.status) || response.status >= 500) {
        const delay = getRetryDelayFromHeaders(response, i);
        yield new Promise((resolve) => setTimeout(resolve, delay));
        response = yield requestFn();
      } else {
        break;
      }
    }
    return response;
  });
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/Fetcher.mjs
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SENSITIVE_HEADERS = /* @__PURE__ */ new Set([
  "authorization",
  "www-authenticate",
  "x-api-key",
  "api-key",
  "apikey",
  "x-api-token",
  "x-auth-token",
  "auth-token",
  "cookie",
  "set-cookie",
  "proxy-authorization",
  "proxy-authenticate",
  "x-csrf-token",
  "x-xsrf-token",
  "x-session-token",
  "x-access-token"
]);
function redactHeaders(headers) {
  const filtered = {};
  for (const [key, value] of headers instanceof Headers2 ? headers.entries() : Object.entries(headers)) {
    if (SENSITIVE_HEADERS.has(key.toLowerCase())) {
      filtered[key] = "[REDACTED]";
    } else {
      filtered[key] = value;
    }
  }
  return filtered;
}
var SENSITIVE_QUERY_PARAMS = /* @__PURE__ */ new Set([
  "api_key",
  "api-key",
  "apikey",
  "token",
  "access_token",
  "access-token",
  "auth_token",
  "auth-token",
  "password",
  "passwd",
  "secret",
  "api_secret",
  "api-secret",
  "apisecret",
  "key",
  "session",
  "session_id",
  "session-id"
]);
function redactQueryParameters(queryParameters) {
  if (queryParameters == null) {
    return queryParameters;
  }
  const redacted = {};
  for (const [key, value] of Object.entries(queryParameters)) {
    if (SENSITIVE_QUERY_PARAMS.has(key.toLowerCase())) {
      redacted[key] = "[REDACTED]";
    } else {
      redacted[key] = value;
    }
  }
  return redacted;
}
function redactUrl(url) {
  const protocolIndex = url.indexOf("://");
  if (protocolIndex === -1)
    return url;
  const afterProtocol = protocolIndex + 3;
  const pathStart = url.indexOf("/", afterProtocol);
  let queryStart = url.indexOf("?", afterProtocol);
  let fragmentStart = url.indexOf("#", afterProtocol);
  const firstDelimiter = Math.min(pathStart === -1 ? url.length : pathStart, queryStart === -1 ? url.length : queryStart, fragmentStart === -1 ? url.length : fragmentStart);
  let atIndex = -1;
  for (let i = afterProtocol; i < firstDelimiter; i++) {
    if (url[i] === "@") {
      atIndex = i;
    }
  }
  if (atIndex !== -1) {
    url = `${url.slice(0, afterProtocol)}[REDACTED]@${url.slice(atIndex + 1)}`;
  }
  queryStart = url.indexOf("?");
  if (queryStart === -1)
    return url;
  fragmentStart = url.indexOf("#", queryStart);
  const queryEnd = fragmentStart !== -1 ? fragmentStart : url.length;
  const queryString = url.slice(queryStart + 1, queryEnd);
  if (queryString.length === 0)
    return url;
  const lower = queryString.toLowerCase();
  const hasSensitive = lower.includes("token") || lower.includes("key") || lower.includes("password") || lower.includes("passwd") || lower.includes("secret") || lower.includes("session") || lower.includes("auth");
  if (!hasSensitive) {
    return url;
  }
  const redactedParams = [];
  const params = queryString.split("&");
  for (const param of params) {
    const equalIndex = param.indexOf("=");
    if (equalIndex === -1) {
      redactedParams.push(param);
      continue;
    }
    const key = param.slice(0, equalIndex);
    let shouldRedact = SENSITIVE_QUERY_PARAMS.has(key.toLowerCase());
    if (!shouldRedact && key.includes("%")) {
      try {
        const decodedKey = decodeURIComponent(key);
        shouldRedact = SENSITIVE_QUERY_PARAMS.has(decodedKey.toLowerCase());
      } catch (_a) {
      }
    }
    redactedParams.push(shouldRedact ? `${key}=[REDACTED]` : param);
  }
  return url.slice(0, queryStart + 1) + redactedParams.join("&") + url.slice(queryEnd);
}
function getHeaders(args) {
  return __awaiter8(this, void 0, void 0, function* () {
    var _a;
    const newHeaders = new Headers2();
    newHeaders.set("Accept", args.responseType === "json" ? "application/json" : args.responseType === "text" ? "text/plain" : "*/*");
    if (args.body !== void 0 && args.contentType != null) {
      newHeaders.set("Content-Type", args.contentType);
    }
    if (args.headers == null) {
      return newHeaders;
    }
    for (const [key, value] of Object.entries(args.headers)) {
      const result = yield EndpointSupplier.get(value, { endpointMetadata: (_a = args.endpointMetadata) !== null && _a !== void 0 ? _a : {} });
      if (typeof result === "string") {
        newHeaders.set(key, result);
        continue;
      }
      if (result == null) {
        continue;
      }
      newHeaders.set(key, `${result}`);
    }
    return newHeaders;
  });
}
function fetcherImpl(args) {
  return __awaiter8(this, void 0, void 0, function* () {
    var _a, _b, _c;
    const url = createRequestUrl(args.url, args.queryParameters);
    const requestBody = yield getRequestBody({
      body: args.body,
      type: (_a = args.requestType) !== null && _a !== void 0 ? _a : "other"
    });
    const fetchFn = (_b = args.fetchFn) !== null && _b !== void 0 ? _b : yield getFetchFn();
    const headers = yield getHeaders(args);
    const logger = createLogger(args.logging);
    if (logger.isDebug()) {
      const metadata = {
        method: args.method,
        url: redactUrl(url),
        headers: redactHeaders(headers),
        queryParameters: redactQueryParameters(args.queryParameters),
        hasBody: requestBody != null
      };
      logger.debug("Making HTTP request", metadata);
    }
    try {
      const response = yield requestWithRetries(() => __awaiter8(this, void 0, void 0, function* () {
        return makeRequest(fetchFn, url, args.method, headers, requestBody, args.timeoutMs, args.abortSignal, args.withCredentials, args.duplex);
      }), args.maxRetries);
      if (response.status >= 200 && response.status < 400) {
        if (logger.isDebug()) {
          const metadata = {
            method: args.method,
            url: redactUrl(url),
            statusCode: response.status,
            responseHeaders: redactHeaders(response.headers)
          };
          logger.debug("HTTP request succeeded", metadata);
        }
        const body = yield getResponseBody(response, args.responseType);
        return {
          ok: true,
          body,
          headers: response.headers,
          rawResponse: toRawResponse(response)
        };
      } else {
        if (logger.isError()) {
          const metadata = {
            method: args.method,
            url: redactUrl(url),
            statusCode: response.status,
            responseHeaders: redactHeaders(Object.fromEntries(response.headers.entries()))
          };
          logger.error("HTTP request failed with error status", metadata);
        }
        return {
          ok: false,
          error: {
            reason: "status-code",
            statusCode: response.status,
            body: yield getErrorResponseBody(response)
          },
          rawResponse: toRawResponse(response)
        };
      }
    } catch (error) {
      if ((_c = args.abortSignal) === null || _c === void 0 ? void 0 : _c.aborted) {
        if (logger.isError()) {
          const metadata = {
            method: args.method,
            url: redactUrl(url)
          };
          logger.error("HTTP request was aborted", metadata);
        }
        return {
          ok: false,
          error: {
            reason: "unknown",
            errorMessage: "The user aborted a request"
          },
          rawResponse: abortRawResponse
        };
      } else if (error instanceof Error && error.name === "AbortError") {
        if (logger.isError()) {
          const metadata = {
            method: args.method,
            url: redactUrl(url),
            timeoutMs: args.timeoutMs
          };
          logger.error("HTTP request timed out", metadata);
        }
        return {
          ok: false,
          error: {
            reason: "timeout"
          },
          rawResponse: abortRawResponse
        };
      } else if (error instanceof Error) {
        if (logger.isError()) {
          const metadata = {
            method: args.method,
            url: redactUrl(url),
            errorMessage: error.message
          };
          logger.error("HTTP request failed with error", metadata);
        }
        return {
          ok: false,
          error: {
            reason: "unknown",
            errorMessage: error.message
          },
          rawResponse: unknownRawResponse
        };
      }
      if (logger.isError()) {
        const metadata = {
          method: args.method,
          url: redactUrl(url),
          error: toJson(error)
        };
        logger.error("HTTP request failed with unknown error", metadata);
      }
      return {
        ok: false,
        error: {
          reason: "unknown",
          errorMessage: toJson(error)
        },
        rawResponse: unknownRawResponse
      };
    }
  });
}
var fetcher = fetcherImpl;

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/HttpResponsePromise.mjs
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HttpResponsePromise = class _HttpResponsePromise extends Promise {
  constructor(promise) {
    super((resolve) => {
      resolve(void 0);
    });
    this.innerPromise = promise;
  }
  /**
   * Creates an `HttpResponsePromise` from a function that returns a promise.
   *
   * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
   * @param args - Arguments to pass to the function.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromFunction(fn, ...args) {
    return new _HttpResponsePromise(fn(...args));
  }
  /**
   * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
   *
   * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
   * @returns A function that returns an `HttpResponsePromise` instance.
   */
  static interceptFunction(fn) {
    return (...args) => {
      return _HttpResponsePromise.fromPromise(fn(...args));
    };
  }
  /**
   * Creates an `HttpResponsePromise` from an existing promise.
   *
   * @param promise - A promise resolving to a `WithRawResponse` object.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromPromise(promise) {
    return new _HttpResponsePromise(promise);
  }
  /**
   * Creates an `HttpResponsePromise` from an executor function.
   *
   * @param executor - A function that takes resolve and reject callbacks to create a promise.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromExecutor(executor) {
    const promise = new Promise(executor);
    return new _HttpResponsePromise(promise);
  }
  /**
   * Creates an `HttpResponsePromise` from a resolved result.
   *
   * @param result - A `WithRawResponse` object to resolve immediately.
   * @returns An `HttpResponsePromise` instance.
   */
  static fromResult(result) {
    const promise = Promise.resolve(result);
    return new _HttpResponsePromise(promise);
  }
  unwrap() {
    if (!this.unwrappedPromise) {
      this.unwrappedPromise = this.innerPromise.then(({ data }) => data);
    }
    return this.unwrappedPromise;
  }
  /** @inheritdoc */
  then(onfulfilled, onrejected) {
    return this.unwrap().then(onfulfilled, onrejected);
  }
  /** @inheritdoc */
  catch(onrejected) {
    return this.unwrap().catch(onrejected);
  }
  /** @inheritdoc */
  finally(onfinally) {
    return this.unwrap().finally(onfinally);
  }
  /**
   * Retrieves the data and raw response.
   *
   * @returns A promise resolving to a `WithRawResponse` object.
   */
  withRawResponse() {
    return __awaiter9(this, void 0, void 0, function* () {
      return yield this.innerPromise;
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/fetcher/Supplier.mjs
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Supplier = {
  get: (supplier) => __awaiter10(void 0, void 0, void 0, function* () {
    if (typeof supplier === "function") {
      return supplier();
    } else {
      return supplier;
    }
  })
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/file/file.mjs
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function toMultipartDataPart(file) {
  return __awaiter11(this, void 0, void 0, function* () {
    const { data, filename, contentType } = yield getFileWithMetadata(file, {
      noSniffFileSize: true
    });
    return {
      data,
      filename,
      contentType
    };
  });
}
function getFileWithMetadata(file_1) {
  return __awaiter11(this, arguments, void 0, function* (file, { noSniffFileSize } = {}) {
    var _a, _b, _c, _d, _e;
    if (isFileLike(file)) {
      return getFileWithMetadata({
        data: file
      }, { noSniffFileSize });
    }
    if ("path" in file) {
      const fs = yield import("./fs-6AIMAK65.js");
      if (!fs || !fs.createReadStream) {
        throw new Error("File path uploads are not supported in this environment.");
      }
      const data = fs.createReadStream(file.path);
      const contentLength = (_a = file.contentLength) !== null && _a !== void 0 ? _a : noSniffFileSize === true ? void 0 : yield tryGetFileSizeFromPath(file.path);
      const filename = (_b = file.filename) !== null && _b !== void 0 ? _b : getNameFromPath(file.path);
      return {
        data,
        filename,
        contentType: file.contentType,
        contentLength
      };
    }
    if ("data" in file) {
      const data = file.data;
      const contentLength = (_c = file.contentLength) !== null && _c !== void 0 ? _c : yield tryGetContentLengthFromFileLike(data, {
        noSniffFileSize
      });
      const filename = (_d = file.filename) !== null && _d !== void 0 ? _d : tryGetNameFromFileLike(data);
      return {
        data,
        filename,
        contentType: (_e = file.contentType) !== null && _e !== void 0 ? _e : tryGetContentTypeFromFileLike(data),
        contentLength
      };
    }
    throw new Error(`Invalid FileUpload of type ${typeof file}: ${JSON.stringify(file)}`);
  });
}
function isFileLike(value) {
  return isBuffer(value) || isArrayBufferView(value) || isArrayBuffer(value) || isUint8Array(value) || isBlob(value) || isFile(value) || isStreamLike(value) || isReadableStream(value);
}
function tryGetFileSizeFromPath(path) {
  return __awaiter11(this, void 0, void 0, function* () {
    try {
      const fs = yield import("./fs-6AIMAK65.js");
      if (!fs || !fs.promises || !fs.promises.stat) {
        return void 0;
      }
      const fileStat = yield fs.promises.stat(path);
      return fileStat.size;
    } catch (_fallbackError) {
      return void 0;
    }
  });
}
function tryGetNameFromFileLike(data) {
  if (isNamedValue(data)) {
    return data.name;
  }
  if (isPathedValue(data)) {
    return getNameFromPath(data.path.toString());
  }
  return void 0;
}
function tryGetContentLengthFromFileLike(data_1) {
  return __awaiter11(this, arguments, void 0, function* (data, { noSniffFileSize } = {}) {
    if (isBuffer(data)) {
      return data.length;
    }
    if (isArrayBufferView(data)) {
      return data.byteLength;
    }
    if (isArrayBuffer(data)) {
      return data.byteLength;
    }
    if (isBlob(data)) {
      return data.size;
    }
    if (isFile(data)) {
      return data.size;
    }
    if (noSniffFileSize === true) {
      return void 0;
    }
    if (isPathedValue(data)) {
      return yield tryGetFileSizeFromPath(data.path.toString());
    }
    return void 0;
  });
}
function tryGetContentTypeFromFileLike(data) {
  if (isBlob(data)) {
    return data.type;
  }
  if (isFile(data)) {
    return data.type;
  }
  return void 0;
}
function getNameFromPath(path) {
  const lastForwardSlash = path.lastIndexOf("/");
  const lastBackSlash = path.lastIndexOf("\\");
  const lastSlashIndex = Math.max(lastForwardSlash, lastBackSlash);
  return lastSlashIndex >= 0 ? path.substring(lastSlashIndex + 1) : path;
}
function isNamedValue(value) {
  return typeof value === "object" && value != null && "name" in value;
}
function isPathedValue(value) {
  return typeof value === "object" && value != null && "path" in value;
}
function isStreamLike(value) {
  return typeof value === "object" && value != null && ("read" in value || "pipe" in value);
}
function isReadableStream(value) {
  return typeof value === "object" && value != null && "getReader" in value;
}
function isBuffer(value) {
  return typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(value);
}
function isArrayBufferView(value) {
  return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
}
function isArrayBuffer(value) {
  return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
}
function isUint8Array(value) {
  return typeof Uint8Array !== "undefined" && value instanceof Uint8Array;
}
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFile(value) {
  return typeof File !== "undefined" && value instanceof File;
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/runtime/runtime.mjs
var RUNTIME = evaluateRuntime();
function evaluateRuntime() {
  var _a, _b, _c, _d, _e;
  const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  if (isBrowser) {
    return {
      type: "browser",
      version: window.navigator.userAgent
    };
  }
  const isCloudflare = typeof globalThis !== "undefined" && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === "Cloudflare-Workers";
  if (isCloudflare) {
    return {
      type: "workerd"
    };
  }
  const isEdgeRuntime = typeof EdgeRuntime === "string";
  if (isEdgeRuntime) {
    return {
      type: "edge-runtime"
    };
  }
  const isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "DedicatedWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "ServiceWorkerGlobalScope" || ((_d = self.constructor) === null || _d === void 0 ? void 0 : _d.name) === "SharedWorkerGlobalScope");
  if (isWebWorker) {
    return {
      type: "web-worker"
    };
  }
  const isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
  if (isDeno) {
    return {
      type: "deno",
      version: Deno.version.deno
    };
  }
  const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
  if (isBun) {
    return {
      type: "bun",
      version: Bun.version
    };
  }
  const isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
  if (isReactNative) {
    return {
      type: "react-native"
    };
  }
  const isNode = typeof process !== "undefined" && "version" in process && !!process.version && "versions" in process && !!((_e = process.versions) === null || _e === void 0 ? void 0 : _e.node);
  if (isNode) {
    return {
      type: "node",
      version: process.versions.node,
      parsedVersion: Number(process.versions.node.split(".")[0])
    };
  }
  return {
    type: "unknown"
  };
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/form-data-utils/FormDataWrapper.mjs
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
function newFormData() {
  return __awaiter12(this, void 0, void 0, function* () {
    return new FormDataWrapper();
  });
}
var FormDataWrapper = class {
  constructor() {
    this.fd = new FormData();
  }
  setup() {
    return __awaiter12(this, void 0, void 0, function* () {
    });
  }
  append(key, value) {
    this.fd.append(key, String(value));
  }
  appendFile(key, value) {
    return __awaiter12(this, void 0, void 0, function* () {
      const { data, filename, contentType } = yield toMultipartDataPart(value);
      const blob = yield convertToBlob(data, contentType);
      if (filename) {
        this.fd.append(key, blob, filename);
      } else {
        this.fd.append(key, blob);
      }
    });
  }
  getRequest() {
    return {
      body: this.fd,
      headers: {},
      duplex: "half"
    };
  }
};
function isStreamLike2(value) {
  return typeof value === "object" && value != null && ("read" in value || "pipe" in value);
}
function isReadableStream2(value) {
  return typeof value === "object" && value != null && "getReader" in value;
}
function isBuffer2(value) {
  return typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(value);
}
function isArrayBufferView2(value) {
  return ArrayBuffer.isView(value);
}
function streamToBuffer(stream) {
  return __awaiter12(this, void 0, void 0, function* () {
    var _a, stream_1, stream_1_1;
    var _b, e_1, _c, _d;
    if (RUNTIME.type === "node") {
      const { Readable } = yield import("./stream-JRI2EKKN.js");
      if (stream instanceof Readable) {
        const chunks = [];
        try {
          for (_a = true, stream_1 = __asyncValues(stream); stream_1_1 = yield stream_1.next(), _b = stream_1_1.done, !_b; _a = true) {
            _d = stream_1_1.value;
            _a = false;
            const chunk = _d;
            chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_a && !_b && (_c = stream_1.return)) yield _c.call(stream_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return Buffer.concat(chunks);
      }
    }
    if (isReadableStream2(stream)) {
      const reader = stream.getReader();
      const chunks = [];
      try {
        while (true) {
          const { done, value } = yield reader.read();
          if (done)
            break;
          chunks.push(value);
        }
      } finally {
        reader.releaseLock();
      }
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return Buffer.from(result);
    }
    throw new Error("Unsupported stream type: " + typeof stream + ". Expected Node.js Readable stream or Web ReadableStream.");
  });
}
function convertToBlob(value, contentType) {
  return __awaiter12(this, void 0, void 0, function* () {
    if (isStreamLike2(value) || isReadableStream2(value)) {
      const buffer = yield streamToBuffer(value);
      return new Blob([buffer], { type: contentType });
    }
    if (value instanceof Blob) {
      return value;
    }
    if (isBuffer2(value)) {
      return new Blob([value], { type: contentType });
    }
    if (value instanceof ArrayBuffer) {
      return new Blob([value], { type: contentType });
    }
    if (isArrayBufferView2(value)) {
      return new Blob([value], { type: contentType });
    }
    if (typeof value === "string") {
      return new Blob([value], { type: contentType });
    }
    if (typeof value === "object" && value !== null) {
      return new Blob([toJson(value)], { type: contentType !== null && contentType !== void 0 ? contentType : "application/json" });
    }
    return new Blob([String(value)], { type: contentType });
  });
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/logging/index.mjs
var logging_exports = {};
__export(logging_exports, {
  ConsoleLogger: () => ConsoleLogger,
  LogLevel: () => LogLevel,
  Logger: () => Logger,
  createLogger: () => createLogger
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/pagination/CustomPager.mjs
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __await = function(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f2) {
    return function(v) {
      return Promise.resolve(v).then(f2, reject);
    };
  }
  function verb(n, f2) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f2) i[n] = f2(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v) {
    if (f2(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};
var __asyncValues2 = function(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var CustomPager = class _CustomPager {
  constructor(args) {
    this.response = args.response;
    this.rawResponse = args.rawResponse;
    this.data = args.items;
    this._hasNextPage = args.hasNextPage;
    this._hasPreviousPage = args.hasPreviousPage;
    this.nextRequest = args.nextRequest;
    this.previousRequest = args.previousRequest;
    this.context = args.context;
    this.parser = args.parser;
  }
  /**
   * @returns whether there is a next page to load
   */
  hasNextPage() {
    return this._hasNextPage;
  }
  /**
   * @returns whether there is a previous page to load
   */
  hasPreviousPage() {
    return this._hasPreviousPage;
  }
  /**
   * Retrieves the next page of results.
   * @returns this pager with updated data
   * @throws Error if there is no next page
   */
  getNextPage() {
    return __awaiter13(this, void 0, void 0, function* () {
      if (!this._hasNextPage || !this.nextRequest) {
        throw new Error("No next page available");
      }
      const { data, rawResponse } = yield this.context.sendRequest(this.nextRequest).withRawResponse();
      const parsed = yield this.parser(this.nextRequest, { data, rawResponse });
      this.response = data;
      this.rawResponse = rawResponse;
      this.data = parsed.items;
      this._hasNextPage = parsed.hasNextPage;
      this._hasPreviousPage = parsed.hasPreviousPage;
      this.context.currentRequest = this.nextRequest;
      this.nextRequest = parsed.nextRequest;
      this.previousRequest = parsed.previousRequest;
      return this;
    });
  }
  /**
   * Retrieves the previous page of results.
   * @returns this pager with updated data
   * @throws Error if there is no previous page
   */
  getPreviousPage() {
    return __awaiter13(this, void 0, void 0, function* () {
      if (!this._hasPreviousPage || !this.previousRequest) {
        throw new Error("No previous page available");
      }
      const { data, rawResponse } = yield this.context.sendRequest(this.previousRequest).withRawResponse();
      const parsed = yield this.parser(this.previousRequest, { data, rawResponse });
      this.response = data;
      this.rawResponse = rawResponse;
      this.data = parsed.items;
      this._hasNextPage = parsed.hasNextPage;
      this._hasPreviousPage = parsed.hasPreviousPage;
      this.context.currentRequest = this.previousRequest;
      this.nextRequest = parsed.nextRequest;
      this.previousRequest = parsed.previousRequest;
      return this;
    });
  }
  iterMessages() {
    return __asyncGenerator(this, arguments, function* iterMessages_1() {
      for (const item of this.data) {
        yield yield __await(item);
      }
      while (this.hasNextPage()) {
        yield __await(this.getNextPage());
        for (const item of this.data) {
          yield yield __await(item);
        }
      }
    });
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, arguments, function* _a() {
      var _b, e_1, _c, _d;
      try {
        for (var _e = true, _f = __asyncValues2(this.iterMessages()), _g; _g = yield __await(_f.next()), _b = _g.done, !_b; _e = true) {
          _d = _g.value;
          _e = false;
          const message2 = _d;
          yield yield __await(message2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_e && !_b && (_c = _f.return)) yield __await(_c.call(_f));
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    });
  }
  /**
   * Creates a CustomPager by making the initial request and parsing the response.
   *
   * @param args.sendRequest Function to send a request and get a response
   * @param args.initialRequest The initial request to start pagination
   * @param args.parse The parser function to extract items and pagination state
   * @returns A new CustomPager instance
   */
  static create(args) {
    return __awaiter13(this, void 0, void 0, function* () {
      const { data, rawResponse } = yield args.sendRequest(args.initialRequest).withRawResponse();
      const parsed = yield args.parse(args.initialRequest, { data, rawResponse });
      return new _CustomPager({
        response: data,
        rawResponse,
        items: parsed.items,
        hasNextPage: parsed.hasNextPage,
        hasPreviousPage: parsed.hasPreviousPage,
        nextRequest: parsed.nextRequest,
        previousRequest: parsed.previousRequest,
        context: {
          sendRequest: args.sendRequest,
          currentRequest: args.initialRequest
        },
        parser: args.parse
      });
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/pagination/Page.mjs
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __await2 = function(v) {
  return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
};
var __asyncGenerator2 = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f2) {
    return function(v) {
      return Promise.resolve(v).then(f2, reject);
    };
  }
  function verb(n, f2) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f2) i[n] = f2(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v) {
    if (f2(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};
var __asyncValues3 = function(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var Page = class {
  constructor({ response, rawResponse, hasNextPage, getItems, loadPage }) {
    this.response = response;
    this.rawResponse = rawResponse;
    this.data = getItems(response);
    this._hasNextPage = hasNextPage;
    this.getItems = getItems;
    this.loadNextPage = loadPage;
  }
  /**
   * Retrieves the next page
   * @returns this
   */
  getNextPage() {
    return __awaiter14(this, void 0, void 0, function* () {
      const { data, rawResponse } = yield this.loadNextPage(this.response).withRawResponse();
      this.response = data;
      this.rawResponse = rawResponse;
      this.data = this.getItems(this.response);
      return this;
    });
  }
  /**
   * @returns whether there is a next page to load
   */
  hasNextPage() {
    return this._hasNextPage(this.response);
  }
  iterMessages() {
    return __asyncGenerator2(this, arguments, function* iterMessages_1() {
      for (const item of this.data) {
        yield yield __await2(item);
      }
      while (this.hasNextPage()) {
        yield __await2(this.getNextPage());
        for (const item of this.data) {
          yield yield __await2(item);
        }
      }
    });
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator2(this, arguments, function* _a() {
      var _b, e_1, _c, _d;
      try {
        for (var _e = true, _f = __asyncValues3(this.iterMessages()), _g; _g = yield __await2(_f.next()), _b = _g.done, !_b; _e = true) {
          _d = _g.value;
          _e = false;
          const message2 = _d;
          yield yield __await2(message2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_e && !_b && (_c = _f.return)) yield __await2(_c.call(_f));
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/url/index.mjs
var url_exports = {};
__export(url_exports, {
  encodePathParam: () => encodePathParam,
  join: () => join,
  toQueryString: () => toQueryString
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/url/encodePathParam.mjs
function encodePathParam(param) {
  if (param === null) {
    return "null";
  }
  const typeofParam = typeof param;
  switch (typeofParam) {
    case "undefined":
      return "undefined";
    case "string":
    case "number":
    case "boolean":
      break;
    default:
      param = String(param);
      break;
  }
  return encodeURIComponent(param);
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/url/join.mjs
function join(base, ...segments) {
  if (!base) {
    return "";
  }
  if (segments.length === 0) {
    return base;
  }
  if (base.includes("://")) {
    let url;
    try {
      url = new URL(base);
    } catch (_a) {
      return joinPath(base, ...segments);
    }
    const lastSegment = segments[segments.length - 1];
    const shouldPreserveTrailingSlash = lastSegment === null || lastSegment === void 0 ? void 0 : lastSegment.endsWith("/");
    for (const segment of segments) {
      const cleanSegment = trimSlashes(segment);
      if (cleanSegment) {
        url.pathname = joinPathSegments(url.pathname, cleanSegment);
      }
    }
    if (shouldPreserveTrailingSlash && !url.pathname.endsWith("/")) {
      url.pathname += "/";
    }
    return url.toString();
  }
  return joinPath(base, ...segments);
}
function joinPath(base, ...segments) {
  if (segments.length === 0) {
    return base;
  }
  let result = base;
  const lastSegment = segments[segments.length - 1];
  const shouldPreserveTrailingSlash = lastSegment === null || lastSegment === void 0 ? void 0 : lastSegment.endsWith("/");
  for (const segment of segments) {
    const cleanSegment = trimSlashes(segment);
    if (cleanSegment) {
      result = joinPathSegments(result, cleanSegment);
    }
  }
  if (shouldPreserveTrailingSlash && !result.endsWith("/")) {
    result += "/";
  }
  return result;
}
function joinPathSegments(left, right) {
  if (left.endsWith("/")) {
    return left + right;
  }
  return `${left}/${right}`;
}
function trimSlashes(str) {
  if (!str)
    return str;
  let start = 0;
  let end = str.length;
  if (str.startsWith("/"))
    start = 1;
  if (str.endsWith("/"))
    end = str.length - 1;
  return start === 0 && end === str.length ? str : str.slice(start, end);
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/utils/setObjectProperty.mjs
function setObjectProperty(object, path, value) {
  if (object == null) {
    return object;
  }
  const keys = path.split(".");
  if (keys.length === 0) {
    return object;
  }
  let current = object;
  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (key == null) {
      continue;
    }
    if (!current[key] || typeof current[key] !== "object") {
      current[key] = {};
    }
    current = current[key];
  }
  const lastKey = keys[keys.length - 1];
  if (lastKey == null) {
    return object;
  }
  current[lastKey] = value;
  return object;
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/auth/BearerAuthProvider.mjs
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BearerAuthProvider = class {
  constructor(options) {
    this.token = options.token;
  }
  static canCreate(options) {
    return options.token != null;
  }
  getAuthRequest(arg) {
    return __awaiter15(this, void 0, void 0, function* () {
      const token = yield Supplier.get(this.token);
      if (token == null) {
        throw new ManagementError({
          message: "Please specify a token by passing it in to the constructor"
        });
      }
      return {
        headers: { Authorization: `Bearer ${token}` }
      };
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/BaseClient.mjs
function normalizeClientOptions(options) {
  return Object.assign(Object.assign({}, options), { logging: logging_exports.createLogger(options === null || options === void 0 ? void 0 : options.logging) });
}
function normalizeClientOptionsWithAuth(options) {
  var _a;
  const normalized = normalizeClientOptions(options);
  const normalizedWithNoOpAuthProvider = withNoOpAuthProvider(normalized);
  (_a = normalized.authProvider) !== null && _a !== void 0 ? _a : normalized.authProvider = new BearerAuthProvider(normalizedWithNoOpAuthProvider);
  return normalized;
}
function withNoOpAuthProvider(options) {
  return Object.assign(Object.assign({}, options), { authProvider: new NoOpAuthProvider() });
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/headers.mjs
function mergeHeaders(...headersArray) {
  const result = {};
  for (const [key, value] of headersArray.filter((headers) => headers != null).flatMap((headers) => Object.entries(headers))) {
    const insensitiveKey = key.toLowerCase();
    if (value != null) {
      result[insensitiveKey] = value;
    } else if (insensitiveKey in result) {
      delete result[insensitiveKey];
    }
  }
  return result;
}
function mergeOnlyDefinedHeaders(...headersArray) {
  const result = {};
  for (const [key, value] of headersArray.filter((headers) => headers != null).flatMap((headers) => Object.entries(headers))) {
    const insensitiveKey = key.toLowerCase();
    if (value != null) {
      result[insensitiveKey] = value;
    }
  }
  return result;
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/environments.mjs
var ManagementEnvironment = {
  Default: "https://%7BTENANT%7D.auth0.com/api/v2"
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/errors/handleNonStatusCodeError.mjs
function handleNonStatusCodeError(error, rawResponse, method, path) {
  switch (error.reason) {
    case "non-json":
      throw new ManagementError({
        statusCode: error.statusCode,
        body: error.rawBody,
        rawResponse
      });
    case "body-is-null":
      throw new ManagementError({
        statusCode: error.statusCode,
        rawResponse
      });
    case "timeout":
      throw new ManagementTimeoutError(`Timeout exceeded when calling ${method} ${path}.`);
    case "unknown":
      throw new ManagementError({
        message: error.errorMessage,
        rawResponse
      });
    default:
      throw new ManagementError({
        message: "Unknown error",
        rawResponse
      });
  }
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/resources/executions/client/Client.mjs
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ExecutionsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve information about a specific execution of a trigger. Relevant execution IDs will be included in tenant logs generated as part of that authentication flow. Executions will only be stored for 10 days after their creation.
   *
   * @param {string} id - The ID of the execution to retrieve.
   * @param {ExecutionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.executions.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter16(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `actions/executions/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/actions/executions/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/resources/triggers/resources/bindings/client/Client.mjs
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BindingsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve the actions that are bound to a trigger. Once an action is created and deployed, it must be attached (i.e. bound) to a trigger so that it will be executed as part of a flow. The list of actions returned reflects the order in which they will be executed during the appropriate flow.
   *
   * @param {Management.ActionTriggerTypeEnum} triggerId - An actions extensibility point.
   * @param {Management.ListActionTriggerBindingsRequestParameters} request
   * @param {BindingsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.triggers.bindings.list("triggerId", {
   *         page: 1,
   *         per_page: 1
   *     })
   */
  list(triggerId_1) {
    return __awaiter17(this, arguments, void 0, function* (triggerId, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter17(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const { page = 0, per_page: perPage = 50 } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_c = this._options) === null || _c === void 0 ? void 0 : _c.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_d = this._options.fetcher) !== null && _d !== void 0 ? _d : fetcher)({
          url: url_exports.join((_f = (_e = yield Supplier.get(this._options.baseUrl)) !== null && _e !== void 0 ? _e : yield Supplier.get(this._options.environment)) !== null && _f !== void 0 ? _f : ManagementEnvironment.Default, `actions/triggers/${url_exports.encodePathParam(triggerId)}/bindings`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_j = (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.timeoutInSeconds) !== null && _j !== void 0 ? _j : 60) * 1e3,
          maxRetries: (_k = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _k !== void 0 ? _k : (_l = this._options) === null || _l === void 0 ? void 0 : _l.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_m = this._options) === null || _m === void 0 ? void 0 : _m.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/actions/triggers/{triggerId}/bindings");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.bindings) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.bindings) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Update the actions that are bound (i.e. attached) to a trigger. Once an action is created and deployed, it must be attached (i.e. bound) to a trigger so that it will be executed as part of a flow. The order in which the actions are provided will determine the order in which they are executed.
   *
   * @param {Management.ActionTriggerTypeEnum} triggerId - An actions extensibility point.
   * @param {Management.UpdateActionBindingsRequestContent} request
   * @param {BindingsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.triggers.bindings.updateMany("triggerId")
   */
  updateMany(triggerId, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__updateMany(triggerId, request, requestOptions));
  }
  __updateMany(triggerId_1) {
    return __awaiter17(this, arguments, void 0, function* (triggerId, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `actions/triggers/${url_exports.encodePathParam(triggerId)}/bindings`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/actions/triggers/{triggerId}/bindings");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/resources/triggers/client/Client.mjs
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TriggersClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get bindings() {
    var _a;
    return (_a = this._bindings) !== null && _a !== void 0 ? _a : this._bindings = new BindingsClient(this._options);
  }
  /**
   * Retrieve the set of triggers currently available within actions. A trigger is an extensibility point to which actions can be bound.
   *
   * @param {TriggersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.triggers.list()
   */
  list(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter18(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "actions/triggers"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/actions/triggers");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/resources/versions/client/Client.mjs
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var VersionsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve all of an action's versions. An action version is created whenever an action is deployed. An action version is immutable, once created.
   *
   * @param {string} actionId - The ID of the action.
   * @param {Management.ListActionVersionsRequestParameters} request
   * @param {VersionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.versions.list("actionId", {
   *         page: 1,
   *         per_page: 1
   *     })
   */
  list(actionId_1) {
    return __awaiter19(this, arguments, void 0, function* (actionId, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter19(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const { page = 0, per_page: perPage = 50 } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_c = this._options) === null || _c === void 0 ? void 0 : _c.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_d = this._options.fetcher) !== null && _d !== void 0 ? _d : fetcher)({
          url: url_exports.join((_f = (_e = yield Supplier.get(this._options.baseUrl)) !== null && _e !== void 0 ? _e : yield Supplier.get(this._options.environment)) !== null && _f !== void 0 ? _f : ManagementEnvironment.Default, `actions/actions/${url_exports.encodePathParam(actionId)}/versions`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_j = (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.timeoutInSeconds) !== null && _j !== void 0 ? _j : 60) * 1e3,
          maxRetries: (_k = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _k !== void 0 ? _k : (_l = this._options) === null || _l === void 0 ? void 0 : _l.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_m = this._options) === null || _m === void 0 ? void 0 : _m.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/actions/actions/{actionId}/versions");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.versions) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.versions) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Retrieve a specific version of an action. An action version is created whenever an action is deployed. An action version is immutable, once created.
   *
   * @param {string} actionId - The ID of the action.
   * @param {string} id - The ID of the action version.
   * @param {VersionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.versions.get("actionId", "id")
   */
  get(actionId, id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(actionId, id, requestOptions));
  }
  __get(actionId, id, requestOptions) {
    return __awaiter19(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `actions/actions/${url_exports.encodePathParam(actionId)}/versions/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/actions/actions/{actionId}/versions/{id}");
    });
  }
  /**
   * Performs the equivalent of a roll-back of an action to an earlier, specified version. Creates a new, deployed action version that is identical to the specified version. If this action is currently bound to a trigger, the system will begin executing the newly-created version immediately.
   *
   * @param {string} actionId - The ID of an action.
   * @param {string} id - The ID of an action version.
   * @param {Management.DeployActionVersionRequestContent | undefined} request
   * @param {VersionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.versions.deploy("actionId", "id")
   */
  deploy(actionId, id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__deploy(actionId, id, request, requestOptions));
  }
  __deploy(actionId, id, request, requestOptions) {
    return __awaiter19(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `actions/actions/${url_exports.encodePathParam(actionId)}/versions/${url_exports.encodePathParam(id)}/deploy`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request != null ? request : void 0,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/actions/actions/{actionId}/versions/{id}/deploy");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/actions/client/Client.mjs
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ActionsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get versions() {
    var _a;
    return (_a = this._versions) !== null && _a !== void 0 ? _a : this._versions = new VersionsClient(this._options);
  }
  get executions() {
    var _a;
    return (_a = this._executions) !== null && _a !== void 0 ? _a : this._executions = new ExecutionsClient(this._options);
  }
  get triggers() {
    var _a;
    return (_a = this._triggers) !== null && _a !== void 0 ? _a : this._triggers = new TriggersClient(this._options);
  }
  /**
   * Retrieve all actions.
   *
   * @param {Management.ListActionsRequestParameters} request
   * @param {ActionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.list({
   *         triggerId: "triggerId",
   *         actionName: "actionName",
   *         deployed: true,
   *         page: 1,
   *         per_page: 1,
   *         installed: true
   *     })
   */
  list() {
    return __awaiter20(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter20(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const { triggerId, actionName, deployed, page = 0, per_page: perPage = 50, installed } = request2;
        const _queryParams = {};
        if (triggerId !== void 0) {
          _queryParams["triggerId"] = triggerId;
        }
        if (actionName !== void 0) {
          _queryParams["actionName"] = actionName;
        }
        if (deployed !== void 0) {
          _queryParams["deployed"] = (_a = deployed === null || deployed === void 0 ? void 0 : deployed.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (page !== void 0) {
          _queryParams["page"] = (_b = page === null || page === void 0 ? void 0 : page.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_c = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (installed !== void 0) {
          _queryParams["installed"] = (_d = installed === null || installed === void 0 ? void 0 : installed.toString()) !== null && _d !== void 0 ? _d : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_e = this._options) === null || _e === void 0 ? void 0 : _e.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_f = this._options.fetcher) !== null && _f !== void 0 ? _f : fetcher)({
          url: url_exports.join((_h = (_g = yield Supplier.get(this._options.baseUrl)) !== null && _g !== void 0 ? _g : yield Supplier.get(this._options.environment)) !== null && _h !== void 0 ? _h : ManagementEnvironment.Default, "actions/actions"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_l = (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.timeoutInSeconds) !== null && _l !== void 0 ? _l : 60) * 1e3,
          maxRetries: (_m = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _m !== void 0 ? _m : (_o = this._options) === null || _o === void 0 ? void 0 : _o.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_p = this._options) === null || _p === void 0 ? void 0 : _p.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/actions/actions");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.actions) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.actions) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create an action. Once an action is created, it must be deployed, and then bound to a trigger before it will be executed as part of a flow.
   *
   * @param {Management.CreateActionRequestContent} request
   * @param {ActionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.create({
   *         name: "name",
   *         supported_triggers: [{
   *                 id: "id"
   *             }]
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter20(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "actions/actions"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/actions/actions");
    });
  }
  /**
   * Retrieve an action by its ID.
   *
   * @param {string} id - The ID of the action to retrieve.
   * @param {ActionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter20(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `actions/actions/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/actions/actions/{id}");
    });
  }
  /**
   * Deletes an action and all of its associated versions. An action must be unbound from all triggers before it can be deleted.
   *
   * @param {string} id - The ID of the action to delete.
   * @param {Management.DeleteActionRequestParameters} request
   * @param {ActionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.delete("id", {
   *         force: true
   *     })
   */
  delete(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, request, requestOptions));
  }
  __delete(id_1) {
    return __awaiter20(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { force } = request;
      const _queryParams = {};
      if (force !== void 0) {
        _queryParams["force"] = (_a = force === null || force === void 0 ? void 0 : force.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `actions/actions/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/actions/actions/{id}");
    });
  }
  /**
   * Update an existing action. If this action is currently bound to a trigger, updating it will <strong>not</strong> affect any user flows until the action is deployed.
   *
   * @param {string} id - The id of the action to update.
   * @param {Management.UpdateActionRequestContent} request
   * @param {ActionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter20(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `actions/actions/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/actions/actions/{id}");
    });
  }
  /**
   * Deploy an action. Deploying an action will create a new immutable version of the action. If the action is currently bound to a trigger, then the system will begin executing the newly deployed version of the action immediately. Otherwise, the action will only be executed as a part of a flow once it is bound to that flow.
   *
   * @param {string} id - The ID of an action.
   * @param {ActionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.deploy("id")
   */
  deploy(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__deploy(id, requestOptions));
  }
  __deploy(id, requestOptions) {
    return __awaiter20(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `actions/actions/${url_exports.encodePathParam(id)}/deploy`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/actions/actions/{id}/deploy");
    });
  }
  /**
   * Test an action. After updating an action, it can be tested prior to being deployed to ensure it behaves as expected.
   *
   * @param {string} id - The id of the action to test.
   * @param {Management.TestActionRequestContent} request
   * @param {ActionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.actions.test("id", {
   *         payload: {
   *             "key": "value"
   *         }
   *     })
   */
  test(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__test(id, request, requestOptions));
  }
  __test(id, request, requestOptions) {
    return __awaiter20(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `actions/actions/${url_exports.encodePathParam(id)}/test`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/actions/actions/{id}/test");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/anomaly/resources/blocks/client/Client.mjs
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BlocksClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Check if the given IP address is blocked via the <a href="https://auth0.com/docs/configure/attack-protection/suspicious-ip-throttling">Suspicious IP Throttling</a> due to multiple suspicious attempts.
   *
   * @param {Management.AnomalyIpFormat} id - IP address to check.
   * @param {BlocksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.anomaly.blocks.checkIp("id")
   */
  checkIp(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__checkIp(id, requestOptions));
  }
  __checkIp(id, requestOptions) {
    return __awaiter21(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `anomaly/blocks/ips/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/anomaly/blocks/ips/{id}");
    });
  }
  /**
   * Remove a block imposed by <a href="https://auth0.com/docs/configure/attack-protection/suspicious-ip-throttling">Suspicious IP Throttling</a> for the given IP address.
   *
   * @param {Management.AnomalyIpFormat} id - IP address to unblock.
   * @param {BlocksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.anomaly.blocks.unblockIp("id")
   */
  unblockIp(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__unblockIp(id, requestOptions));
  }
  __unblockIp(id, requestOptions) {
    return __awaiter21(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `anomaly/blocks/ips/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/anomaly/blocks/ips/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/anomaly/client/Client.mjs
var AnomalyClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get blocks() {
    var _a;
    return (_a = this._blocks) !== null && _a !== void 0 ? _a : this._blocks = new BlocksClient(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/botDetection/client/Client.mjs
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BotDetectionClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Get the Bot Detection configuration of your tenant.
   *
   * @param {BotDetectionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.botDetection.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter22(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/bot-detection"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/attack-protection/bot-detection");
    });
  }
  /**
   * Update the Bot Detection configuration of your tenant.
   *
   * @param {Management.UpdateBotDetectionSettingsRequestContent} request
   * @param {BotDetectionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.botDetection.update()
   */
  update(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update() {
    return __awaiter22(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/bot-detection"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/attack-protection/bot-detection");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/breachedPasswordDetection/client/Client.mjs
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BreachedPasswordDetectionClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details of the Breached Password Detection configuration of your tenant.
   *
   * @param {BreachedPasswordDetectionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.breachedPasswordDetection.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter23(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/breached-password-detection"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/attack-protection/breached-password-detection");
    });
  }
  /**
   * Update details of the Breached Password Detection configuration of your tenant.
   *
   * @param {Management.UpdateBreachedPasswordDetectionSettingsRequestContent} request
   * @param {BreachedPasswordDetectionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.breachedPasswordDetection.update()
   */
  update(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update() {
    return __awaiter23(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/breached-password-detection"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/attack-protection/breached-password-detection");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/bruteForceProtection/client/Client.mjs
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BruteForceProtectionClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details of the Brute-force Protection configuration of your tenant.
   *
   * @param {BruteForceProtectionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.bruteForceProtection.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter24(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/brute-force-protection"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/attack-protection/brute-force-protection");
    });
  }
  /**
   * Update the Brute-force Protection configuration of your tenant.
   *
   * @param {Management.UpdateBruteForceSettingsRequestContent} request
   * @param {BruteForceProtectionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.bruteForceProtection.update()
   */
  update(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update() {
    return __awaiter24(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/brute-force-protection"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/attack-protection/brute-force-protection");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/captcha/client/Client.mjs
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CaptchaClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Get the CAPTCHA configuration for your client.
   *
   * @param {CaptchaClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.captcha.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter25(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/captcha"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/attack-protection/captcha");
    });
  }
  /**
   * Update existing CAPTCHA configuration for your client.
   *
   * @param {Management.UpdateAttackProtectionCaptchaRequestContent} request
   * @param {CaptchaClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.captcha.update()
   */
  update(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update() {
    return __awaiter25(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/captcha"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/attack-protection/captcha");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/resources/suspiciousIpThrottling/client/Client.mjs
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SuspiciousIpThrottlingClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details of the Suspicious IP Throttling configuration of your tenant.
   *
   * @param {SuspiciousIpThrottlingClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.suspiciousIpThrottling.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter26(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/suspicious-ip-throttling"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/attack-protection/suspicious-ip-throttling");
    });
  }
  /**
   * Update the details of the Suspicious IP Throttling configuration of your tenant.
   *
   * @param {Management.UpdateSuspiciousIpThrottlingSettingsRequestContent} request
   * @param {SuspiciousIpThrottlingClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.attackProtection.suspiciousIpThrottling.update()
   */
  update(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update() {
    return __awaiter26(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "attack-protection/suspicious-ip-throttling"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/attack-protection/suspicious-ip-throttling");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/attackProtection/client/Client.mjs
var AttackProtectionClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get botDetection() {
    var _a;
    return (_a = this._botDetection) !== null && _a !== void 0 ? _a : this._botDetection = new BotDetectionClient(this._options);
  }
  get breachedPasswordDetection() {
    var _a;
    return (_a = this._breachedPasswordDetection) !== null && _a !== void 0 ? _a : this._breachedPasswordDetection = new BreachedPasswordDetectionClient(this._options);
  }
  get bruteForceProtection() {
    var _a;
    return (_a = this._bruteForceProtection) !== null && _a !== void 0 ? _a : this._bruteForceProtection = new BruteForceProtectionClient(this._options);
  }
  get captcha() {
    var _a;
    return (_a = this._captcha) !== null && _a !== void 0 ? _a : this._captcha = new CaptchaClient(this._options);
  }
  get suspiciousIpThrottling() {
    var _a;
    return (_a = this._suspiciousIpThrottling) !== null && _a !== void 0 ? _a : this._suspiciousIpThrottling = new SuspiciousIpThrottlingClient(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/phone/resources/providers/client/Client.mjs
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProvidersClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve a list of <a href="https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers">phone providers</a> details set for a Tenant. A list of fields to include or exclude may also be specified.
   *
   * @param {Management.ListBrandingPhoneProvidersRequestParameters} request
   * @param {ProvidersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.providers.list({
   *         disabled: true
   *     })
   */
  list(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
  }
  __list() {
    return __awaiter27(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { disabled } = request;
      const _queryParams = {};
      if (disabled !== void 0) {
        _queryParams["disabled"] = (_a = disabled === null || disabled === void 0 ? void 0 : disabled.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "branding/phone/providers"),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/branding/phone/providers");
    });
  }
  /**
   * Create a <a href="https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers">phone provider</a>.
   * The <code>credentials</code> object requires different properties depending on the phone provider (which is specified using the <code>name</code> property).
   *
   * @param {Management.CreateBrandingPhoneProviderRequestContent} request
   * @param {ProvidersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.providers.create({
   *         name: "twilio",
   *         credentials: {
   *             auth_token: "auth_token"
   *         }
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "branding/phone/providers"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/branding/phone/providers");
    });
  }
  /**
   * Retrieve <a href="https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers">phone provider</a> details. A list of fields to include or exclude may also be specified.
   *
   * @param {string} id
   * @param {ProvidersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.providers.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/phone/providers/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/branding/phone/providers/{id}");
    });
  }
  /**
   * Delete the configured phone provider.
   *
   * @param {string} id
   * @param {ProvidersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.providers.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/phone/providers/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/branding/phone/providers/{id}");
    });
  }
  /**
   * Update a <a href="https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers">phone provider</a>.
   * The <code>credentials</code> object requires different properties depending on the phone provider (which is specified using the <code>name</code> property).
   *
   * @param {string} id
   * @param {Management.UpdateBrandingPhoneProviderRequestContent} request
   * @param {ProvidersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.providers.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter27(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/phone/providers/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/branding/phone/providers/{id}");
    });
  }
  /**
   * @param {string} id
   * @param {Management.CreatePhoneProviderSendTestRequestContent} request
   * @param {ProvidersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.providers.test("id", {
   *         to: "to"
   *     })
   */
  test(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__test(id, request, requestOptions));
  }
  __test(id, request, requestOptions) {
    return __awaiter27(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/phone/providers/${url_exports.encodePathParam(id)}/try`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/branding/phone/providers/{id}/try");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/phone/resources/templates/client/Client.mjs
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TemplatesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * @param {Management.ListPhoneTemplatesRequestParameters} request
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.templates.list({
   *         disabled: true
   *     })
   */
  list(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
  }
  __list() {
    return __awaiter28(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { disabled } = request;
      const _queryParams = {};
      if (disabled !== void 0) {
        _queryParams["disabled"] = (_a = disabled === null || disabled === void 0 ? void 0 : disabled.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "branding/phone/templates"),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/branding/phone/templates");
    });
  }
  /**
   * @param {Management.CreatePhoneTemplateRequestContent} request
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.templates.create()
   */
  create(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create() {
    return __awaiter28(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "branding/phone/templates"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/branding/phone/templates");
    });
  }
  /**
   * @param {string} id
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.templates.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter28(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/phone/templates/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/branding/phone/templates/{id}");
    });
  }
  /**
   * @param {string} id
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.templates.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter28(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/phone/templates/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/branding/phone/templates/{id}");
    });
  }
  /**
   * @param {string} id
   * @param {Management.UpdatePhoneTemplateRequestContent} request
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.templates.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter28(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/phone/templates/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/branding/phone/templates/{id}");
    });
  }
  /**
   * @param {string} id
   * @param {Management.ResetPhoneTemplateRequestContent} request
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.templates.reset("id", {
   *         "key": "value"
   *     })
   */
  reset(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__reset(id, request, requestOptions));
  }
  __reset(id, request, requestOptions) {
    return __awaiter28(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/phone/templates/${url_exports.encodePathParam(id)}/reset`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/branding/phone/templates/{id}/reset");
    });
  }
  /**
   * @param {string} id
   * @param {Management.CreatePhoneTemplateTestNotificationRequestContent} request
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.phone.templates.test("id", {
   *         to: "to"
   *     })
   */
  test(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__test(id, request, requestOptions));
  }
  __test(id, request, requestOptions) {
    return __awaiter28(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/phone/templates/${url_exports.encodePathParam(id)}/try`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/branding/phone/templates/{id}/try");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/phone/client/Client.mjs
var PhoneClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get providers() {
    var _a;
    return (_a = this._providers) !== null && _a !== void 0 ? _a : this._providers = new ProvidersClient(this._options);
  }
  get templates() {
    var _a;
    return (_a = this._templates) !== null && _a !== void 0 ? _a : this._templates = new TemplatesClient(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/templates/client/Client.mjs
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TemplatesClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.PaymentRequiredError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.templates.getUniversalLogin()
   */
  getUniversalLogin(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getUniversalLogin(requestOptions));
  }
  __getUniversalLogin(requestOptions) {
    return __awaiter29(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "branding/templates/universal-login"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 402:
            throw new PaymentRequiredError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/branding/templates/universal-login");
    });
  }
  /**
   * Update the Universal Login branding template.
   *
   * <p>When <code>content-type</code> header is set to <code>application/json</code>:</p>
   * <pre>
   * {
   *   "template": "&lt;!DOCTYPE html&gt;{% assign resolved_dir = dir | default: "auto" %}&lt;html lang="{{locale}}" dir="{{resolved_dir}}"&gt;&lt;head&gt;{%- auth0:head -%}&lt;/head&gt;&lt;body class="_widget-auto-layout"&gt;{%- auth0:widget -%}&lt;/body&gt;&lt;/html&gt;"
   * }
   * </pre>
   *
   * <p>
   *   When <code>content-type</code> header is set to <code>text/html</code>:
   * </p>
   * <pre>
   * &lt!DOCTYPE html&gt;
   * {% assign resolved_dir = dir | default: "auto" %}
   * &lt;html lang="{{locale}}" dir="{{resolved_dir}}"&gt;
   *   &lt;head&gt;
   *     {%- auth0:head -%}
   *   &lt;/head&gt;
   *   &lt;body class="_widget-auto-layout"&gt;
   *     {%- auth0:widget -%}
   *   &lt;/body&gt;
   * &lt;/html&gt;
   * </pre>
   *
   * @param {Management.UpdateUniversalLoginTemplateRequestContent} request
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.PaymentRequiredError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.templates.updateUniversalLogin("string")
   */
  updateUniversalLogin(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__updateUniversalLogin(request, requestOptions));
  }
  __updateUniversalLogin(request, requestOptions) {
    return __awaiter29(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "branding/templates/universal-login"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 402:
            throw new PaymentRequiredError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/branding/templates/universal-login");
    });
  }
  /**
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.PaymentRequiredError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.templates.deleteUniversalLogin()
   */
  deleteUniversalLogin(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__deleteUniversalLogin(requestOptions));
  }
  __deleteUniversalLogin(requestOptions) {
    return __awaiter29(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "branding/templates/universal-login"),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 402:
            throw new PaymentRequiredError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/branding/templates/universal-login");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/resources/themes/client/Client.mjs
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ThemesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Create branding theme.
   *
   * @param {Management.CreateBrandingThemeRequestContent} request
   * @param {ThemesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.themes.create({
   *         borders: {
   *             button_border_radius: 1.1,
   *             button_border_weight: 1.1,
   *             buttons_style: "pill",
   *             input_border_radius: 1.1,
   *             input_border_weight: 1.1,
   *             inputs_style: "pill",
   *             show_widget_shadow: true,
   *             widget_border_weight: 1.1,
   *             widget_corner_radius: 1.1
   *         },
   *         colors: {
   *             body_text: "body_text",
   *             error: "error",
   *             header: "header",
   *             icons: "icons",
   *             input_background: "input_background",
   *             input_border: "input_border",
   *             input_filled_text: "input_filled_text",
   *             input_labels_placeholders: "input_labels_placeholders",
   *             links_focused_components: "links_focused_components",
   *             primary_button: "primary_button",
   *             primary_button_label: "primary_button_label",
   *             secondary_button_border: "secondary_button_border",
   *             secondary_button_label: "secondary_button_label",
   *             success: "success",
   *             widget_background: "widget_background",
   *             widget_border: "widget_border"
   *         },
   *         fonts: {
   *             body_text: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             buttons_text: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             font_url: "font_url",
   *             input_labels: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             links: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             links_style: "normal",
   *             reference_text_size: 1.1,
   *             subtitle: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             title: {
   *                 bold: true,
   *                 size: 1.1
   *             }
   *         },
   *         page_background: {
   *             background_color: "background_color",
   *             background_image_url: "background_image_url",
   *             page_layout: "center"
   *         },
   *         widget: {
   *             header_text_alignment: "center",
   *             logo_height: 1.1,
   *             logo_position: "center",
   *             logo_url: "logo_url",
   *             social_buttons_layout: "bottom"
   *         }
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter30(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "branding/themes"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/branding/themes");
    });
  }
  /**
   * Retrieve default branding theme.
   *
   * @param {ThemesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.themes.getDefault()
   */
  getDefault(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getDefault(requestOptions));
  }
  __getDefault(requestOptions) {
    return __awaiter30(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "branding/themes/default"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/branding/themes/default");
    });
  }
  /**
   * Retrieve branding theme.
   *
   * @param {string} themeId - The ID of the theme
   * @param {ThemesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.themes.get("themeId")
   */
  get(themeId, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(themeId, requestOptions));
  }
  __get(themeId, requestOptions) {
    return __awaiter30(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/themes/${url_exports.encodePathParam(themeId)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/branding/themes/{themeId}");
    });
  }
  /**
   * Delete branding theme.
   *
   * @param {string} themeId - The ID of the theme
   * @param {ThemesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.themes.delete("themeId")
   */
  delete(themeId, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(themeId, requestOptions));
  }
  __delete(themeId, requestOptions) {
    return __awaiter30(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/themes/${url_exports.encodePathParam(themeId)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/branding/themes/{themeId}");
    });
  }
  /**
   * Update branding theme.
   *
   * @param {string} themeId - The ID of the theme
   * @param {Management.UpdateBrandingThemeRequestContent} request
   * @param {ThemesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.themes.update("themeId", {
   *         borders: {
   *             button_border_radius: 1.1,
   *             button_border_weight: 1.1,
   *             buttons_style: "pill",
   *             input_border_radius: 1.1,
   *             input_border_weight: 1.1,
   *             inputs_style: "pill",
   *             show_widget_shadow: true,
   *             widget_border_weight: 1.1,
   *             widget_corner_radius: 1.1
   *         },
   *         colors: {
   *             body_text: "body_text",
   *             error: "error",
   *             header: "header",
   *             icons: "icons",
   *             input_background: "input_background",
   *             input_border: "input_border",
   *             input_filled_text: "input_filled_text",
   *             input_labels_placeholders: "input_labels_placeholders",
   *             links_focused_components: "links_focused_components",
   *             primary_button: "primary_button",
   *             primary_button_label: "primary_button_label",
   *             secondary_button_border: "secondary_button_border",
   *             secondary_button_label: "secondary_button_label",
   *             success: "success",
   *             widget_background: "widget_background",
   *             widget_border: "widget_border"
   *         },
   *         fonts: {
   *             body_text: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             buttons_text: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             font_url: "font_url",
   *             input_labels: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             links: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             links_style: "normal",
   *             reference_text_size: 1.1,
   *             subtitle: {
   *                 bold: true,
   *                 size: 1.1
   *             },
   *             title: {
   *                 bold: true,
   *                 size: 1.1
   *             }
   *         },
   *         page_background: {
   *             background_color: "background_color",
   *             background_image_url: "background_image_url",
   *             page_layout: "center"
   *         },
   *         widget: {
   *             header_text_alignment: "center",
   *             logo_height: 1.1,
   *             logo_position: "center",
   *             logo_url: "logo_url",
   *             social_buttons_layout: "bottom"
   *         }
   *     })
   */
  update(themeId, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(themeId, request, requestOptions));
  }
  __update(themeId, request, requestOptions) {
    return __awaiter30(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `branding/themes/${url_exports.encodePathParam(themeId)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/branding/themes/{themeId}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/branding/client/Client.mjs
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BrandingClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get templates() {
    var _a;
    return (_a = this._templates) !== null && _a !== void 0 ? _a : this._templates = new TemplatesClient2(this._options);
  }
  get themes() {
    var _a;
    return (_a = this._themes) !== null && _a !== void 0 ? _a : this._themes = new ThemesClient(this._options);
  }
  get phone() {
    var _a;
    return (_a = this._phone) !== null && _a !== void 0 ? _a : this._phone = new PhoneClient(this._options);
  }
  /**
   * Retrieve branding settings.
   *
   * @param {BrandingClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter31(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "branding"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/branding");
    });
  }
  /**
   * Update branding settings.
   *
   * @param {Management.UpdateBrandingRequestContent} request
   * @param {BrandingClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.branding.update()
   */
  update(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update() {
    return __awaiter31(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "branding"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/branding");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clientGrants/resources/organizations/client/Client.mjs
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OrganizationsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * @param {string} id - ID of the client grant
   * @param {Management.ListClientGrantOrganizationsRequestParameters} request
   * @param {OrganizationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clientGrants.organizations.list("id", {
   *         from: "from",
   *         take: 1
   *     })
   */
  list(id_1) {
    return __awaiter32(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter32(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `client-grants/${url_exports.encodePathParam(id)}/organizations`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/client-grants/{id}/organizations");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.organizations) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clientGrants/client/Client.mjs
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClientGrantsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get organizations() {
    var _a;
    return (_a = this._organizations) !== null && _a !== void 0 ? _a : this._organizations = new OrganizationsClient(this._options);
  }
  /**
   * Retrieve a list of <a href="https://auth0.com/docs/get-started/applications/application-access-to-apis-client-grants">client grants</a>, including the scopes associated with the application/API pair.
   *
   * @param {Management.ListClientGrantsRequestParameters} request
   * @param {ClientGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clientGrants.list({
   *         from: "from",
   *         take: 1,
   *         audience: "audience",
   *         client_id: "client_id",
   *         allow_any_organization: true,
   *         subject_type: "client"
   *     })
   */
  list() {
    return __awaiter33(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter33(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const { from: from_, take = 50, audience, client_id: clientId, allow_any_organization: allowAnyOrganization, subject_type: subjectType } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (audience !== void 0) {
          _queryParams["audience"] = audience;
        }
        if (clientId !== void 0) {
          _queryParams["client_id"] = clientId;
        }
        if (allowAnyOrganization !== void 0) {
          _queryParams["allow_any_organization"] = (_b = allowAnyOrganization === null || allowAnyOrganization === void 0 ? void 0 : allowAnyOrganization.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (subjectType !== void 0) {
          _queryParams["subject_type"] = subjectType;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_c = this._options) === null || _c === void 0 ? void 0 : _c.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_d = this._options.fetcher) !== null && _d !== void 0 ? _d : fetcher)({
          url: url_exports.join((_f = (_e = yield Supplier.get(this._options.baseUrl)) !== null && _e !== void 0 ? _e : yield Supplier.get(this._options.environment)) !== null && _f !== void 0 ? _f : ManagementEnvironment.Default, "client-grants"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_j = (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.timeoutInSeconds) !== null && _j !== void 0 ? _j : 60) * 1e3,
          maxRetries: (_k = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _k !== void 0 ? _k : (_l = this._options) === null || _l === void 0 ? void 0 : _l.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_m = this._options) === null || _m === void 0 ? void 0 : _m.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/client-grants");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.client_grants) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Create a client grant for a machine-to-machine login flow. To learn more, read <a href="https://www.auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow">Client Credential Flow</a>.
   *
   * @param {Management.CreateClientGrantRequestContent} request
   * @param {ClientGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clientGrants.create({
   *         client_id: "client_id",
   *         audience: "audience"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter33(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "client-grants"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/client-grants");
    });
  }
  /**
   * Delete the <a href="https://www.auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow">Client Credential Flow</a> from your machine-to-machine application.
   *
   * @param {string} id - ID of the client grant to delete.
   * @param {ClientGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clientGrants.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter33(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `client-grants/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/client-grants/{id}");
    });
  }
  /**
   * Update a client grant.
   *
   * @param {string} id - ID of the client grant to update.
   * @param {Management.UpdateClientGrantRequestContent} request
   * @param {ClientGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clientGrants.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter33(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `client-grants/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/client-grants/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clients/resources/connections/client/Client.mjs
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ConnectionsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve all connections that are enabled for the specified <a href="https://www.auth0.com/docs/get-started/applications"> Application</a>, using checkpoint pagination. A list of fields to include or exclude for each connection may also be specified.
   * <ul>
   *   <li>
   *     This endpoint requires the <code>read:connections</code> scope and any one of <code>read:clients</code> or <code>read:client_summary</code>.
   *   </li>
   *   <li>
   *     <b>Note</b>: The first time you call this endpoint, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no further results are remaining.
   *   </li>
   * </ul>
   *
   * @param {string} id - ID of the client for which to retrieve enabled connections.
   * @param {Management.ConnectionsGetRequest} request
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.connections.get("id", {
   *         from: "from",
   *         take: 1,
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  get(id_1) {
    return __awaiter34(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter34(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const { strategy, from: from_, take = 50, fields, include_fields: includeFields } = request2;
        const _queryParams = {};
        if (strategy !== void 0) {
          if (Array.isArray(strategy)) {
            _queryParams["strategy"] = strategy.map((item) => item);
          } else {
            _queryParams["strategy"] = strategy;
          }
        }
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_b = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _b !== void 0 ? _b : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_c = this._options) === null || _c === void 0 ? void 0 : _c.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_d = this._options.fetcher) !== null && _d !== void 0 ? _d : fetcher)({
          url: url_exports.join((_f = (_e = yield Supplier.get(this._options.baseUrl)) !== null && _e !== void 0 ? _e : yield Supplier.get(this._options.environment)) !== null && _f !== void 0 ? _f : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(id)}/connections`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_j = (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.timeoutInSeconds) !== null && _j !== void 0 ? _j : 60) * 1e3,
          maxRetries: (_k = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _k !== void 0 ? _k : (_l = this._options) === null || _l === void 0 ? void 0 : _l.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_m = this._options) === null || _m === void 0 ? void 0 : _m.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/clients/{id}/connections");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.connections) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clients/resources/credentials/client/Client.mjs
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CredentialsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Get the details of a client credential.
   *
   * <b>Important</b>: To enable credentials to be used for a client authentication method, set the <code>client_authentication_methods</code> property on the client. To enable credentials to be used for JWT-Secured Authorization requests set the <code>signed_request_object</code> property on the client.
   *
   * @param {string} client_id - ID of the client.
   * @param {CredentialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.credentials.list("client_id")
   */
  list(client_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(client_id, requestOptions));
  }
  __list(client_id, requestOptions) {
    return __awaiter35(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(client_id)}/credentials`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/clients/{client_id}/credentials");
    });
  }
  /**
   * Create a client credential associated to your application. Credentials can be used to configure Private Key JWT and mTLS authentication methods, as well as for JWT-secured Authorization requests.
   *
   * <h5>Public Key</h5>Public Key credentials can be used to set up Private Key JWT client authentication and JWT-secured Authorization requests.
   *
   * Sample: <pre><code>{
   *   "credential_type": "public_key",
   *   "name": "string",
   *   "pem": "string",
   *   "alg": "RS256",
   *   "parse_expiry_from_cert": false,
   *   "expires_at": "2022-12-31T23:59:59Z"
   * }</code></pre>
   * <h5>Certificate (CA-signed & self-signed)</h5>Certificate credentials can be used to set up mTLS client authentication. CA-signed certificates can be configured either with a signed certificate or with just the certificate Subject DN.
   *
   * CA-signed Certificate Sample (pem): <pre><code>{
   *   "credential_type": "x509_cert",
   *   "name": "string",
   *   "pem": "string"
   * }</code></pre>CA-signed Certificate Sample (subject_dn): <pre><code>{
   *   "credential_type": "cert_subject_dn",
   *   "name": "string",
   *   "subject_dn": "string"
   * }</code></pre>Self-signed Certificate Sample: <pre><code>{
   *   "credential_type": "cert_subject_dn",
   *   "name": "string",
   *   "pem": "string"
   * }</code></pre>
   *
   * The credential will be created but not yet enabled for use until you set the corresponding properties in the client:
   * <ul>
   *   <li>To enable the credential for Private Key JWT or mTLS authentication methods, set the <code>client_authentication_methods</code> property on the client. For more information, read <a href="https://auth0.com/docs/get-started/applications/configure-private-key-jwt">Configure Private Key JWT Authentication</a> and <a href="https://auth0.com/docs/get-started/applications/configure-mtls">Configure mTLS Authentication</a></li>
   *   <li>To enable the credential for JWT-secured Authorization requests, set the <code>signed_request_object</code>property on the client. For more information, read <a href="https://auth0.com/docs/get-started/applications/configure-jar">Configure JWT-secured Authorization Requests (JAR)</a></li>
   * </ul>
   *
   * @param {string} client_id - ID of the client.
   * @param {Management.PostClientCredentialRequestContent} request
   * @param {CredentialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.credentials.create("client_id", {
   *         credential_type: "public_key"
   *     })
   */
  create(client_id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(client_id, request, requestOptions));
  }
  __create(client_id, request, requestOptions) {
    return __awaiter35(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(client_id)}/credentials`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/clients/{client_id}/credentials");
    });
  }
  /**
   * Get the details of a client credential.
   *
   * <b>Important</b>: To enable credentials to be used for a client authentication method, set the <code>client_authentication_methods</code> property on the client. To enable credentials to be used for JWT-Secured Authorization requests set the <code>signed_request_object</code> property on the client.
   *
   * @param {string} client_id - ID of the client.
   * @param {string} credential_id - ID of the credential.
   * @param {CredentialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.credentials.get("client_id", "credential_id")
   */
  get(client_id, credential_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(client_id, credential_id, requestOptions));
  }
  __get(client_id, credential_id, requestOptions) {
    return __awaiter35(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(client_id)}/credentials/${url_exports.encodePathParam(credential_id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/clients/{client_id}/credentials/{credential_id}");
    });
  }
  /**
   * Delete a client credential you previously created. May be enabled or disabled. For more information, read <a href="https://www.auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow">Client Credential Flow</a>.
   *
   * @param {string} client_id - ID of the client.
   * @param {string} credential_id - ID of the credential to delete.
   * @param {CredentialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.credentials.delete("client_id", "credential_id")
   */
  delete(client_id, credential_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(client_id, credential_id, requestOptions));
  }
  __delete(client_id, credential_id, requestOptions) {
    return __awaiter35(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(client_id)}/credentials/${url_exports.encodePathParam(credential_id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/clients/{client_id}/credentials/{credential_id}");
    });
  }
  /**
   * Change a client credential you previously created. May be enabled or disabled. For more information, read <a href="https://www.auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow">Client Credential Flow</a>.
   *
   * @param {string} client_id - ID of the client.
   * @param {string} credential_id - ID of the credential.
   * @param {Management.PatchClientCredentialRequestContent} request
   * @param {CredentialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.credentials.update("client_id", "credential_id")
   */
  update(client_id, credential_id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(client_id, credential_id, request, requestOptions));
  }
  __update(client_id_1, credential_id_1) {
    return __awaiter35(this, arguments, void 0, function* (client_id, credential_id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(client_id)}/credentials/${url_exports.encodePathParam(credential_id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/clients/{client_id}/credentials/{credential_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/clients/client/Client.mjs
var __awaiter36 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClientsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get credentials() {
    var _a;
    return (_a = this._credentials) !== null && _a !== void 0 ? _a : this._credentials = new CredentialsClient(this._options);
  }
  get connections() {
    var _a;
    return (_a = this._connections) !== null && _a !== void 0 ? _a : this._connections = new ConnectionsClient(this._options);
  }
  /**
   * Retrieve clients (applications and SSO integrations) matching provided filters. A list of fields to include or exclude may also be specified.
   * For more information, read <a href="https://www.auth0.com/docs/get-started/applications"> Applications in Auth0</a> and <a href="https://www.auth0.com/docs/authenticate/single-sign-on"> Single Sign-On</a>.
   *
   * <ul>
   *   <li>
   *     The following can be retrieved with any scope:
   *     <code>client_id</code>, <code>app_type</code>, <code>name</code>, and <code>description</code>.
   *   </li>
   *   <li>
   *     The following properties can only be retrieved with the <code>read:clients</code> or
   *     <code>read:client_keys</code> scope:
   *     <code>callbacks</code>, <code>oidc_logout</code>, <code>allowed_origins</code>,
   *     <code>web_origins</code>, <code>tenant</code>, <code>global</code>, <code>config_route</code>,
   *     <code>callback_url_template</code>, <code>jwt_configuration</code>,
   *     <code>jwt_configuration.lifetime_in_seconds</code>, <code>jwt_configuration.secret_encoded</code>,
   *     <code>jwt_configuration.scopes</code>, <code>jwt_configuration.alg</code>, <code>api_type</code>,
   *     <code>logo_uri</code>, <code>allowed_clients</code>, <code>owners</code>, <code>custom_login_page</code>,
   *     <code>custom_login_page_off</code>, <code>sso</code>, <code>addons</code>, <code>form_template</code>,
   *     <code>custom_login_page_codeview</code>, <code>resource_servers</code>, <code>client_metadata</code>,
   *     <code>mobile</code>, <code>mobile.android</code>, <code>mobile.ios</code>, <code>allowed_logout_urls</code>,
   *     <code>token_endpoint_auth_method</code>, <code>is_first_party</code>, <code>oidc_conformant</code>,
   *     <code>is_token_endpoint_ip_header_trusted</code>, <code>initiate_login_uri</code>, <code>grant_types</code>,
   *     <code>refresh_token</code>, <code>refresh_token.rotation_type</code>, <code>refresh_token.expiration_type</code>,
   *     <code>refresh_token.leeway</code>, <code>refresh_token.token_lifetime</code>, <code>refresh_token.policies</code>, <code>organization_usage</code>,
   *     <code>organization_require_behavior</code>.
   *   </li>
   *   <li>
   *     The following properties can only be retrieved with the
   *     <code>read:client_keys</code> or <code>read:client_credentials</code> scope:
   *     <code>encryption_key</code>, <code>encryption_key.pub</code>, <code>encryption_key.cert</code>,
   *     <code>client_secret</code>, <code>client_authentication_methods</code> and <code>signing_key</code>.
   *   </li>
   * </ul>
   *
   * @param {Management.ListClientsRequestParameters} request
   * @param {ClientsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.list({
   *         fields: "fields",
   *         include_fields: true,
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true,
   *         is_global: true,
   *         is_first_party: true,
   *         app_type: "app_type",
   *         q: "q"
   *     })
   */
  list() {
    return __awaiter36(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter36(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        const { fields, include_fields: includeFields, page = 0, per_page: perPage = 50, include_totals: includeTotals = true, is_global: isGlobal, is_first_party: isFirstParty, app_type: appType, q } = request2;
        const _queryParams = {};
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (page !== void 0) {
          _queryParams["page"] = (_b = page === null || page === void 0 ? void 0 : page.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_c = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_d = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _d !== void 0 ? _d : null;
        }
        if (isGlobal !== void 0) {
          _queryParams["is_global"] = (_e = isGlobal === null || isGlobal === void 0 ? void 0 : isGlobal.toString()) !== null && _e !== void 0 ? _e : null;
        }
        if (isFirstParty !== void 0) {
          _queryParams["is_first_party"] = (_f = isFirstParty === null || isFirstParty === void 0 ? void 0 : isFirstParty.toString()) !== null && _f !== void 0 ? _f : null;
        }
        if (appType !== void 0) {
          _queryParams["app_type"] = appType;
        }
        if (q !== void 0) {
          _queryParams["q"] = q;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_g = this._options) === null || _g === void 0 ? void 0 : _g.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_h = this._options.fetcher) !== null && _h !== void 0 ? _h : fetcher)({
          url: url_exports.join((_k = (_j = yield Supplier.get(this._options.baseUrl)) !== null && _j !== void 0 ? _j : yield Supplier.get(this._options.environment)) !== null && _k !== void 0 ? _k : ManagementEnvironment.Default, "clients"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_o = (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.timeoutInSeconds) !== null && _o !== void 0 ? _o : 60) * 1e3,
          maxRetries: (_p = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _p !== void 0 ? _p : (_q = this._options) === null || _q === void 0 ? void 0 : _q.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_r = this._options) === null || _r === void 0 ? void 0 : _r.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/clients");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.clients) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.clients) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create a new client (application or SSO integration). For more information, read <a href="https://www.auth0.com/docs/get-started/auth0-overview/create-applications">Create Applications</a>
   * <a href="https://www.auth0.com/docs/authenticate/single-sign-on/api-endpoints-for-single-sign-on>">API Endpoints for Single Sign-On</a>.
   *
   * Notes:
   * - We recommend leaving the `client_secret` parameter unspecified to allow the generation of a safe secret.
   * - The <code>client_authentication_methods</code> and <code>token_endpoint_auth_method</code> properties are mutually exclusive. Use
   * <code>client_authentication_methods</code> to configure the client with Private Key JWT authentication method. Otherwise, use <code>token_endpoint_auth_method</code>
   * to configure the client with client secret (basic or post) or with no authentication method (none).
   * - When using <code>client_authentication_methods</code> to configure the client with Private Key JWT authentication method, specify fully defined credentials.
   * These credentials will be automatically enabled for Private Key JWT authentication on the client.
   * - To configure <code>client_authentication_methods</code>, the <code>create:client_credentials</code> scope is required.
   * - To configure <code>client_authentication_methods</code>, the property <code>jwt_configuration.alg</code> must be set to RS256.
   *
   * <div class="alert alert-warning">SSO Integrations created via this endpoint will accept login requests and share user profile information.</div>
   *
   * @param {Management.CreateClientRequestContent} request
   * @param {ClientsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.create({
   *         name: "name"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter36(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "clients"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/clients");
    });
  }
  /**
   * Retrieve client details by ID. Clients are SSO connections or Applications linked with your Auth0 tenant. A list of fields to include or exclude may also be specified.
   * For more information, read <a href="https://www.auth0.com/docs/get-started/applications"> Applications in Auth0</a> and <a href="https://www.auth0.com/docs/authenticate/single-sign-on"> Single Sign-On</a>.
   * <ul>
   *   <li>
   *     The following properties can be retrieved with any of the scopes:
   *     <code>client_id</code>, <code>app_type</code>, <code>name</code>, and <code>description</code>.
   *   </li>
   *   <li>
   *     The following properties can only be retrieved with the <code>read:clients</code> or
   *     <code>read:client_keys</code> scopes:
   *     <code>callbacks</code>, <code>oidc_logout</code>, <code>allowed_origins</code>,
   *     <code>web_origins</code>, <code>tenant</code>, <code>global</code>, <code>config_route</code>,
   *     <code>callback_url_template</code>, <code>jwt_configuration</code>,
   *     <code>jwt_configuration.lifetime_in_seconds</code>, <code>jwt_configuration.secret_encoded</code>,
   *     <code>jwt_configuration.scopes</code>, <code>jwt_configuration.alg</code>, <code>api_type</code>,
   *     <code>logo_uri</code>, <code>allowed_clients</code>, <code>owners</code>, <code>custom_login_page</code>,
   *     <code>custom_login_page_off</code>, <code>sso</code>, <code>addons</code>, <code>form_template</code>,
   *     <code>custom_login_page_codeview</code>, <code>resource_servers</code>, <code>client_metadata</code>,
   *     <code>mobile</code>, <code>mobile.android</code>, <code>mobile.ios</code>, <code>allowed_logout_urls</code>,
   *     <code>token_endpoint_auth_method</code>, <code>is_first_party</code>, <code>oidc_conformant</code>,
   *     <code>is_token_endpoint_ip_header_trusted</code>, <code>initiate_login_uri</code>, <code>grant_types</code>,
   *     <code>refresh_token</code>, <code>refresh_token.rotation_type</code>, <code>refresh_token.expiration_type</code>,
   *     <code>refresh_token.leeway</code>, <code>refresh_token.token_lifetime</code>, <code>refresh_token.policies</code>, <code>organization_usage</code>,
   *     <code>organization_require_behavior</code>.
   *   </li>
   *   <li>
   *     The following properties can only be retrieved with the <code>read:client_keys</code> or <code>read:client_credentials</code> scopes:
   *     <code>encryption_key</code>, <code>encryption_key.pub</code>, <code>encryption_key.cert</code>,
   *     <code>client_secret</code>, <code>client_authentication_methods</code> and <code>signing_key</code>.
   *   </li>
   * </ul>
   *
   * @param {string} id - ID of the client to retrieve.
   * @param {Management.GetClientRequestParameters} request
   * @param {ClientsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.get("id", {
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  get(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
  }
  __get(id_1) {
    return __awaiter36(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { fields, include_fields: includeFields } = request;
      const _queryParams = {};
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/clients/{id}");
    });
  }
  /**
   * Delete a client and related configuration (rules, connections, etc).
   *
   * @param {string} id - ID of the client to delete.
   * @param {ClientsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter36(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/clients/{id}");
    });
  }
  /**
   * Updates a client's settings. For more information, read <a href="https://www.auth0.com/docs/get-started/applications"> Applications in Auth0</a> and <a href="https://www.auth0.com/docs/authenticate/single-sign-on"> Single Sign-On</a>.
   *
   * Notes:
   * - The `client_secret` and `signing_key` attributes can only be updated with the `update:client_keys` scope.
   * - The <code>client_authentication_methods</code> and <code>token_endpoint_auth_method</code> properties are mutually exclusive. Use <code>client_authentication_methods</code> to configure the client with Private Key JWT authentication method. Otherwise, use <code>token_endpoint_auth_method</code> to configure the client with client secret (basic or post) or with no authentication method (none).
   * - When using <code>client_authentication_methods</code> to configure the client with Private Key JWT authentication method, only specify the credential IDs that were generated when creating the credentials on the client.
   * - To configure <code>client_authentication_methods</code>, the <code>update:client_credentials</code> scope is required.
   * - To configure <code>client_authentication_methods</code>, the property <code>jwt_configuration.alg</code> must be set to RS256.
   * - To change a client's <code>is_first_party</code> property to <code>false</code>, the <code>organization_usage</code> and <code>organization_require_behavior</code> properties must be unset.
   *
   * @param {string} id - ID of the client to update.
   * @param {Management.UpdateClientRequestContent} request
   * @param {ClientsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter36(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/clients/{id}");
    });
  }
  /**
   * Rotate a client secret.
   *
   * This endpoint cannot be used with clients configured with Private Key JWT authentication method (client_authentication_methods configured with private_key_jwt). The generated secret is NOT base64 encoded.
   *
   * For more information, read <a href="https://www.auth0.com/docs/get-started/applications/rotate-client-secret">Rotate Client Secrets</a>.
   *
   * @param {string} id - ID of the client that will rotate secrets.
   * @param {ClientsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.clients.rotateSecret("id")
   */
  rotateSecret(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__rotateSecret(id, requestOptions));
  }
  __rotateSecret(id, requestOptions) {
    return __awaiter36(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `clients/${url_exports.encodePathParam(id)}/rotate-secret`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/clients/{id}/rotate-secret");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connectionProfiles/client/Client.mjs
var __awaiter37 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ConnectionProfilesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve a list of Connection Profiles. This endpoint supports Checkpoint pagination.
   *
   * @param {Management.ListConnectionProfileRequestParameters} request
   * @param {ConnectionProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connectionProfiles.list({
   *         from: "from",
   *         take: 1
   *     })
   */
  list() {
    return __awaiter37(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter37(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "connection-profiles"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connection-profiles");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.connection_profiles) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Create a Connection Profile.
   *
   * @param {Management.CreateConnectionProfileRequestContent} request
   * @param {ConnectionProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connectionProfiles.create({
   *         name: "name"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "connection-profiles"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/connection-profiles");
    });
  }
  /**
   * Retrieve a list of Connection Profile Templates.
   *
   * @param {ConnectionProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connectionProfiles.listTemplates()
   */
  listTemplates(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__listTemplates(requestOptions));
  }
  __listTemplates(requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "connection-profiles/templates"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connection-profiles/templates");
    });
  }
  /**
   * Retrieve a Connection Profile Template.
   *
   * @param {string} id - ID of the connection-profile-template to retrieve.
   * @param {ConnectionProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connectionProfiles.getTemplate("id")
   */
  getTemplate(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getTemplate(id, requestOptions));
  }
  __getTemplate(id, requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connection-profiles/templates/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connection-profiles/templates/{id}");
    });
  }
  /**
   * Retrieve details about a single Connection Profile specified by ID.
   *
   * @param {string} id - ID of the connection-profile to retrieve.
   * @param {ConnectionProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connectionProfiles.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connection-profiles/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connection-profiles/{id}");
    });
  }
  /**
   * Delete a single Connection Profile specified by ID.
   *
   * @param {string} id - ID of the connection-profile to delete.
   * @param {ConnectionProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connectionProfiles.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter37(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connection-profiles/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/connection-profiles/{id}");
    });
  }
  /**
   * Update the details of a specific Connection Profile.
   *
   * @param {string} id - ID of the connection profile to update.
   * @param {Management.UpdateConnectionProfileRequestContent} request
   * @param {ConnectionProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connectionProfiles.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter37(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connection-profiles/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/connection-profiles/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/clients/client/Client.mjs
var __awaiter38 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClientsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve all clients that have the specified <a href="https://auth0.com/docs/authenticate/identity-providers">connection</a> enabled.
   *
   * <b>Note</b>: The first time you call this endpoint, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no further results are remaining.
   *
   * @param {string} id - The id of the connection for which enabled clients are to be retrieved
   * @param {Management.GetConnectionEnabledClientsRequestParameters} request
   * @param {ClientsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.clients.get("id", {
   *         take: 1,
   *         from: "from"
   *     })
   */
  get(id_1) {
    return __awaiter38(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter38(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { take = 50, from: from_ } = request2;
        const _queryParams = {};
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/clients`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections/{id}/clients");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.clients) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * @param {string} id - The id of the connection to modify
   * @param {Management.UpdateEnabledClientConnectionsRequestContent} request
   * @param {ClientsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.clients.update("id", [{
   *             client_id: "client_id",
   *             status: true
   *         }])
   */
  update(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id, request, requestOptions) {
    return __awaiter38(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/clients`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/connections/{id}/clients");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/directoryProvisioning/resources/synchronizations/client/Client.mjs
var __awaiter39 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SynchronizationsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Request an on-demand synchronization of the directory.
   *
   * @param {string} id - The id of the connection to trigger synchronization for
   * @param {SynchronizationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.directoryProvisioning.synchronizations.create("id")
   */
  create(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, requestOptions));
  }
  __create(id, requestOptions) {
    return __awaiter39(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/directory-provisioning/synchronizations`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/connections/{id}/directory-provisioning/synchronizations");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/directoryProvisioning/client/Client.mjs
var __awaiter40 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DirectoryProvisioningClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get synchronizations() {
    var _a;
    return (_a = this._synchronizations) !== null && _a !== void 0 ? _a : this._synchronizations = new SynchronizationsClient(this._options);
  }
  /**
   * Retrieve the directory provisioning configuration of a connection.
   *
   * @param {string} id - The id of the connection to retrieve its directory provisioning configuration
   * @param {DirectoryProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.directoryProvisioning.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter40(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/directory-provisioning`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections/{id}/directory-provisioning");
    });
  }
  /**
   * Create a directory provisioning configuration for a connection.
   *
   * @param {string} id - The id of the connection to create its directory provisioning configuration
   * @param {Management.CreateDirectoryProvisioningRequestContent | null} request
   * @param {DirectoryProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.directoryProvisioning.create("id")
   */
  create(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id, request, requestOptions) {
    return __awaiter40(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/directory-provisioning`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request != null ? request : void 0,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/connections/{id}/directory-provisioning");
    });
  }
  /**
   * Delete the directory provisioning configuration of a connection.
   *
   * @param {string} id - The id of the connection to delete its directory provisioning configuration
   * @param {DirectoryProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.directoryProvisioning.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter40(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/directory-provisioning`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/connections/{id}/directory-provisioning");
    });
  }
  /**
   * Update the directory provisioning configuration of a connection.
   *
   * @param {string} id - The id of the connection to create its directory provisioning configuration
   * @param {Management.UpdateDirectoryProvisioningRequestContent | null} request
   * @param {DirectoryProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.directoryProvisioning.update("id")
   */
  update(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id, request, requestOptions) {
    return __awaiter40(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/directory-provisioning`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request != null ? request : void 0,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/connections/{id}/directory-provisioning");
    });
  }
  /**
   * Retrieve the directory provisioning default attribute mapping of a connection.
   *
   * @param {string} id - The id of the connection to retrieve its directory provisioning configuration
   * @param {DirectoryProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.directoryProvisioning.getDefaultMapping("id")
   */
  getDefaultMapping(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getDefaultMapping(id, requestOptions));
  }
  __getDefaultMapping(id, requestOptions) {
    return __awaiter40(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/directory-provisioning/default-mapping`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections/{id}/directory-provisioning/default-mapping");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/keys/client/Client.mjs
var __awaiter41 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var KeysClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Gets the connection keys for the Okta or OIDC connection strategy.
   *
   * @param {string} id - ID of the connection
   * @param {KeysClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.keys.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter41(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/keys`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections/{id}/keys");
    });
  }
  /**
   * Rotates the connection keys for the Okta or OIDC connection strategies.
   *
   * @param {string} id - ID of the connection
   * @param {Management.RotateConnectionKeysRequestContent | null} request
   * @param {KeysClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.keys.rotate("id")
   */
  rotate(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__rotate(id, request, requestOptions));
  }
  __rotate(id, request, requestOptions) {
    return __awaiter41(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/keys/rotate`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request != null ? request : void 0,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/connections/{id}/keys/rotate");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/scimConfiguration/resources/tokens/client/Client.mjs
var __awaiter42 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TokensClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieves all scim tokens by its connection <code>id</code>.
   *
   * @param {string} id - The id of the connection to retrieve its SCIM configuration
   * @param {TokensClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.connections.scimConfiguration.tokens.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter42(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/scim-configuration/tokens`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections/{id}/scim-configuration/tokens");
    });
  }
  /**
   * Create a scim token for a scim client.
   *
   * @param {string} id - The id of the connection to create its SCIM token
   * @param {Management.CreateScimTokenRequestContent} request
   * @param {TokensClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   *
   * @example
   *     await client.connections.scimConfiguration.tokens.create("id")
   */
  create(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id_1) {
    return __awaiter42(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/scim-configuration/tokens`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/connections/{id}/scim-configuration/tokens");
    });
  }
  /**
   * Deletes a scim token by its connection <code>id</code> and <code>tokenId</code>.
   *
   * @param {string} id - The connection id that owns the SCIM token to delete
   * @param {string} tokenId - The id of the scim token to delete
   * @param {TokensClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.connections.scimConfiguration.tokens.delete("id", "tokenId")
   */
  delete(id, tokenId, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, tokenId, requestOptions));
  }
  __delete(id, tokenId, requestOptions) {
    return __awaiter42(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/scim-configuration/tokens/${url_exports.encodePathParam(tokenId)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/connections/{id}/scim-configuration/tokens/{tokenId}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/scimConfiguration/client/Client.mjs
var __awaiter43 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ScimConfigurationClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get tokens() {
    var _a;
    return (_a = this._tokens) !== null && _a !== void 0 ? _a : this._tokens = new TokensClient(this._options);
  }
  /**
   * Retrieves a scim configuration by its <code>connectionId</code>.
   *
   * @param {string} id - The id of the connection to retrieve its SCIM configuration
   * @param {ScimConfigurationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.connections.scimConfiguration.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter43(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/scim-configuration`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections/{id}/scim-configuration");
    });
  }
  /**
   * Create a scim configuration for a connection.
   *
   * @param {string} id - The id of the connection to create its SCIM configuration
   * @param {Management.CreateScimConfigurationRequestContent | null} request
   * @param {ScimConfigurationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.connections.scimConfiguration.create("id")
   */
  create(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id, request, requestOptions) {
    return __awaiter43(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/scim-configuration`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request != null ? request : void 0,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/connections/{id}/scim-configuration");
    });
  }
  /**
   * Deletes a scim configuration by its <code>connectionId</code>.
   *
   * @param {string} id - The id of the connection to delete its SCIM configuration
   * @param {ScimConfigurationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.connections.scimConfiguration.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter43(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/scim-configuration`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/connections/{id}/scim-configuration");
    });
  }
  /**
   * Update a scim configuration by its <code>connectionId</code>.
   *
   * @param {string} id - The id of the connection to update its SCIM configuration
   * @param {Management.UpdateScimConfigurationRequestContent} request
   * @param {ScimConfigurationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.connections.scimConfiguration.update("id", {
   *         user_id_attribute: "user_id_attribute",
   *         mapping: [{}]
   *     })
   */
  update(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id, request, requestOptions) {
    return __awaiter43(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/scim-configuration`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/connections/{id}/scim-configuration");
    });
  }
  /**
   * Retrieves a scim configuration's default mapping by its <code>connectionId</code>.
   *
   * @param {string} id - The id of the connection to retrieve its default SCIM mapping
   * @param {ScimConfigurationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.connections.scimConfiguration.getDefaultMapping("id")
   */
  getDefaultMapping(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getDefaultMapping(id, requestOptions));
  }
  __getDefaultMapping(id, requestOptions) {
    return __awaiter43(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/scim-configuration/default-mapping`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections/{id}/scim-configuration/default-mapping");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/resources/users/client/Client.mjs
var __awaiter44 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UsersClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Deletes a specified connection user by its email (you cannot delete all users from specific connection). Currently, only Database Connections are supported.
   *
   * @param {string} id - The id of the connection (currently only database connections are supported)
   * @param {Management.DeleteConnectionUsersByEmailQueryParameters} request
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.users.deleteByEmail("id", {
   *         email: "email"
   *     })
   */
  deleteByEmail(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__deleteByEmail(id, request, requestOptions));
  }
  __deleteByEmail(id, request, requestOptions) {
    return __awaiter44(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const { email } = request;
      const _queryParams = {};
      _queryParams["email"] = email;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/users`),
        method: "DELETE",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/connections/{id}/users");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/connections/client/Client.mjs
var __awaiter45 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ConnectionsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get clients() {
    var _a;
    return (_a = this._clients) !== null && _a !== void 0 ? _a : this._clients = new ClientsClient2(this._options);
  }
  get directoryProvisioning() {
    var _a;
    return (_a = this._directoryProvisioning) !== null && _a !== void 0 ? _a : this._directoryProvisioning = new DirectoryProvisioningClient(this._options);
  }
  get keys() {
    var _a;
    return (_a = this._keys) !== null && _a !== void 0 ? _a : this._keys = new KeysClient(this._options);
  }
  get scimConfiguration() {
    var _a;
    return (_a = this._scimConfiguration) !== null && _a !== void 0 ? _a : this._scimConfiguration = new ScimConfigurationClient(this._options);
  }
  get users() {
    var _a;
    return (_a = this._users) !== null && _a !== void 0 ? _a : this._users = new UsersClient(this._options);
  }
  /**
   * Retrieves detailed list of all <a href="https://auth0.com/docs/authenticate/identity-providers">connections</a> that match the specified strategy. If no strategy is provided, all connections within your tenant are retrieved. This action can accept a list of fields to include or exclude from the resulting list of connections.
   *
   * This endpoint supports two types of pagination:
   * <ul>
   * <li>Offset pagination</li>
   * <li>Checkpoint pagination</li>
   * </ul>
   *
   * Checkpoint pagination must be used if you need to retrieve more than 1000 connections.
   *
   * <h2>Checkpoint Pagination</h2>
   *
   * To search by checkpoint, use the following parameters:
   * <ul>
   * <li><code>from</code>: Optional id from which to start selection.</li>
   * <li><code>take</code>: The total amount of entries to retrieve when using the from parameter. Defaults to 50.</li>
   * </ul>
   *
   * <b>Note</b>: The first time you call this endpoint using checkpoint pagination, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no pages are remaining.
   *
   * @param {Management.ListConnectionsQueryParameters} request
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.list({
   *         from: "from",
   *         take: 1,
   *         name: "name",
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  list() {
    return __awaiter45(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter45(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const { from: from_, take = 50, strategy, name, fields, include_fields: includeFields } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (strategy !== void 0) {
          if (Array.isArray(strategy)) {
            _queryParams["strategy"] = strategy.map((item) => item);
          } else {
            _queryParams["strategy"] = strategy;
          }
        }
        if (name !== void 0) {
          _queryParams["name"] = name;
        }
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_b = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _b !== void 0 ? _b : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_c = this._options) === null || _c === void 0 ? void 0 : _c.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_d = this._options.fetcher) !== null && _d !== void 0 ? _d : fetcher)({
          url: url_exports.join((_f = (_e = yield Supplier.get(this._options.baseUrl)) !== null && _e !== void 0 ? _e : yield Supplier.get(this._options.environment)) !== null && _f !== void 0 ? _f : ManagementEnvironment.Default, "connections"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_j = (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.timeoutInSeconds) !== null && _j !== void 0 ? _j : 60) * 1e3,
          maxRetries: (_k = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _k !== void 0 ? _k : (_l = this._options) === null || _l === void 0 ? void 0 : _l.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_m = this._options) === null || _m === void 0 ? void 0 : _m.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.connections) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Creates a new connection according to the JSON object received in <code>body</code>.<br/>
   *
   * @param {Management.CreateConnectionRequestContent} request
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.create({
   *         name: "name",
   *         strategy: "ad"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter45(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "connections"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/connections");
    });
  }
  /**
   * Retrieve details for a specified <a href="https://auth0.com/docs/authenticate/identity-providers">connection</a> along with options that can be used for identity provider configuration.
   *
   * @param {string} id - The id of the connection to retrieve
   * @param {Management.GetConnectionRequestParameters} request
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.get("id", {
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  get(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
  }
  __get(id_1) {
    return __awaiter45(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { fields, include_fields: includeFields } = request;
      const _queryParams = {};
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections/{id}");
    });
  }
  /**
   * Removes a specific <a href="https://auth0.com/docs/authenticate/identity-providers">connection</a> from your tenant. This action cannot be undone. Once removed, users can no longer use this connection to authenticate.
   *
   * @param {string} id - The id of the connection to delete
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter45(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/connections/{id}");
    });
  }
  /**
   * Update details for a specific <a href="https://auth0.com/docs/authenticate/identity-providers">connection</a>, including option properties for identity provider configuration.
   *
   * <b>Note</b>: If you use the <code>options</code> parameter, the entire <code>options</code> object is overriden. To avoid partial data or other issues, ensure all parameters are present when using this option.
   *
   * @param {string} id - The id of the connection to update
   * @param {Management.UpdateConnectionRequestContent} request
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter45(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/connections/{id}");
    });
  }
  /**
   * Retrieves the status of an ad/ldap connection referenced by its <code>ID</code>. <code>200 OK</code> http status code response is returned  when the connection is online, otherwise a <code>404</code> status code is returned along with an error message
   *
   * @param {string} id - ID of the connection to check
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.connections.checkStatus("id")
   */
  checkStatus(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__checkStatus(id, requestOptions));
  }
  __checkStatus(id, requestOptions) {
    return __awaiter45(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `connections/${url_exports.encodePathParam(id)}/status`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/connections/{id}/status");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/customDomains/client/Client.mjs
var __awaiter46 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CustomDomainsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details on <a href="https://auth0.com/docs/custom-domains">custom domains</a>.
   *
   * @param {Management.ListCustomDomainsRequestParameters} request
   * @param {CustomDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.customDomains.list({
   *         q: "q",
   *         fields: "fields",
   *         include_fields: true,
   *         sort: "sort"
   *     })
   */
  list(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
  }
  __list() {
    return __awaiter46(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { q, fields, include_fields: includeFields, sort } = request;
      const _queryParams = {};
      if (q !== void 0) {
        _queryParams["q"] = q;
      }
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      if (sort !== void 0) {
        _queryParams["sort"] = sort;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "custom-domains"),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/custom-domains");
    });
  }
  /**
   * Create a new custom domain.
   *
   * Note: The custom domain will need to be verified before it will accept
   * requests.
   *
   * Optional attributes that can be updated:
   *
   * - custom_client_ip_header
   * - tls_policy
   *
   *
   * TLS Policies:
   *
   * - recommended - for modern usage this includes TLS 1.2 only
   *
   * @param {Management.CreateCustomDomainRequestContent} request
   * @param {CustomDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.customDomains.create({
   *         domain: "domain",
   *         type: "auth0_managed_certs"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter46(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "custom-domains"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/custom-domains");
    });
  }
  /**
   * Retrieve a custom domain configuration and status.
   *
   * @param {string} id - ID of the custom domain to retrieve.
   * @param {CustomDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.customDomains.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter46(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `custom-domains/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/custom-domains/{id}");
    });
  }
  /**
   * Delete a custom domain and stop serving requests for it.
   *
   * @param {string} id - ID of the custom domain to delete.
   * @param {CustomDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.customDomains.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter46(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `custom-domains/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/custom-domains/{id}");
    });
  }
  /**
   * Update a custom domain.
   *
   * These are the attributes that can be updated:
   *
   * - custom_client_ip_header
   * - tls_policy
   *
   * <h5>Updating CUSTOM_CLIENT_IP_HEADER for a custom domain</h5>To update the <code>custom_client_ip_header</code> for a domain, the body to
   * send should be:
   * <pre><code>{ "custom_client_ip_header": "cf-connecting-ip" }</code></pre>
   *
   * <h5>Updating TLS_POLICY for a custom domain</h5>To update the <code>tls_policy</code> for a domain, the body to send should be:
   * <pre><code>{ "tls_policy": "recommended" }</code></pre>
   *
   *
   * TLS Policies:
   *
   * - recommended - for modern usage this includes TLS 1.2 only
   *
   *
   * Some considerations:
   *
   * - The TLS ciphers and protocols available in each TLS policy follow industry recommendations, and may be updated occasionally.
   * - The <code>compatible</code> TLS policy is no longer supported.
   *
   * @param {string} id - The id of the custom domain to update
   * @param {Management.UpdateCustomDomainRequestContent} request
   * @param {CustomDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.customDomains.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter46(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `custom-domains/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/custom-domains/{id}");
    });
  }
  /**
   * Run the test process on a custom domain.
   *
   * @param {string} id - ID of the custom domain to test.
   * @param {CustomDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   *
   * @example
   *     await client.customDomains.test("id")
   */
  test(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__test(id, requestOptions));
  }
  __test(id, requestOptions) {
    return __awaiter46(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `custom-domains/${url_exports.encodePathParam(id)}/test`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/custom-domains/{id}/test");
    });
  }
  /**
   * Run the verification process on a custom domain.
   *
   * Note: Check the <code>status</code> field to see its verification status. Once verification is complete, it may take up to 10 minutes before the custom domain can start accepting requests.
   *
   * For <code>self_managed_certs</code>, when the custom domain is verified for the first time, the response will also include the <code>cname_api_key</code> which you will need to configure your proxy. This key must be kept secret, and is used to validate the proxy requests.
   *
   * <a href="https://auth0.com/docs/custom-domains#step-2-verify-ownership">Learn more</a> about verifying custom domains that use Auth0 Managed certificates.
   * <a href="https://auth0.com/docs/custom-domains/self-managed-certificates#step-2-verify-ownership">Learn more</a> about verifying custom domains that use Self Managed certificates.
   *
   * @param {string} id - ID of the custom domain to verify.
   * @param {CustomDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.customDomains.verify("id")
   */
  verify(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__verify(id, requestOptions));
  }
  __verify(id, requestOptions) {
    return __awaiter46(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `custom-domains/${url_exports.encodePathParam(id)}/verify`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/custom-domains/{id}/verify");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/deviceCredentials/client/Client.mjs
var __awaiter47 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DeviceCredentialsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve device credential information (<code>public_key</code>, <code>refresh_token</code>, or <code>rotating_refresh_token</code>) associated with a specific user.
   *
   * @param {Management.ListDeviceCredentialsRequestParameters} request
   * @param {DeviceCredentialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.deviceCredentials.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true,
   *         fields: "fields",
   *         include_fields: true,
   *         user_id: "user_id",
   *         client_id: "client_id",
   *         type: "public_key"
   *     })
   */
  list() {
    return __awaiter47(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter47(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true, fields, include_fields: includeFields, user_id: userId, client_id: clientId, type: type_ } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_d = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _d !== void 0 ? _d : null;
        }
        if (userId !== void 0) {
          _queryParams["user_id"] = userId;
        }
        if (clientId !== void 0) {
          _queryParams["client_id"] = clientId;
        }
        if (type_ !== void 0) {
          _queryParams["type"] = type_;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_e = this._options) === null || _e === void 0 ? void 0 : _e.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_f = this._options.fetcher) !== null && _f !== void 0 ? _f : fetcher)({
          url: url_exports.join((_h = (_g = yield Supplier.get(this._options.baseUrl)) !== null && _g !== void 0 ? _g : yield Supplier.get(this._options.environment)) !== null && _h !== void 0 ? _h : ManagementEnvironment.Default, "device-credentials"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_l = (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.timeoutInSeconds) !== null && _l !== void 0 ? _l : 60) * 1e3,
          maxRetries: (_m = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _m !== void 0 ? _m : (_o = this._options) === null || _o === void 0 ? void 0 : _o.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_p = this._options) === null || _p === void 0 ? void 0 : _p.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/device-credentials");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.device_credentials) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.device_credentials) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create a device credential public key to manage refresh token rotation for a given <code>user_id</code>. Device Credentials APIs are designed for ad-hoc administrative use only and paging is by default enabled for GET requests.
   *
   * When refresh token rotation is enabled, the endpoint becomes consistent. For more information, read <a href="https://auth0.com/docs/get-started/tenant-settings/signing-keys"> Signing Keys</a>.
   *
   * @param {Management.CreatePublicKeyDeviceCredentialRequestContent} request
   * @param {DeviceCredentialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.deviceCredentials.createPublicKey({
   *         device_name: "device_name",
   *         value: "value",
   *         device_id: "device_id"
   *     })
   */
  createPublicKey(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__createPublicKey(request, requestOptions));
  }
  __createPublicKey(request, requestOptions) {
    return __awaiter47(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "device-credentials"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: Object.assign(Object.assign({}, request), { type: "public_key" }),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/device-credentials");
    });
  }
  /**
   * Permanently delete a device credential (such as a refresh token or public key) with the given ID.
   *
   * @param {string} id - ID of the credential to delete.
   * @param {DeviceCredentialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.deviceCredentials.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter47(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `device-credentials/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/device-credentials/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/emails/resources/provider/client/Client.mjs
var __awaiter48 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProviderClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details of the <a href="https://auth0.com/docs/customize/email/smtp-email-providers">email provider configuration</a> in your tenant. A list of fields to include or exclude may also be specified.
   *
   * @param {Management.GetEmailProviderRequestParameters} request
   * @param {ProviderClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.emails.provider.get({
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  get(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(request, requestOptions));
  }
  __get() {
    return __awaiter48(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { fields, include_fields: includeFields } = request;
      const _queryParams = {};
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "emails/provider"),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/emails/provider");
    });
  }
  /**
   * Create an <a href="https://auth0.com/docs/email/providers">email provider</a>. The <code>credentials</code> object
   * requires different properties depending on the email provider (which is specified using the <code>name</code> property):
   * <ul>
   *   <li><code>mandrill</code> requires <code>api_key</code></li>
   *   <li><code>sendgrid</code> requires <code>api_key</code></li>
   *   <li>
   *     <code>sparkpost</code> requires <code>api_key</code>. Optionally, set <code>region</code> to <code>eu</code> to use
   *     the SparkPost service hosted in Western Europe; set to <code>null</code> to use the SparkPost service hosted in
   *     North America. <code>eu</code> or <code>null</code> are the only valid values for <code>region</code>.
   *   </li>
   *   <li>
   *     <code>mailgun</code> requires <code>api_key</code> and <code>domain</code>. Optionally, set <code>region</code> to
   *     <code>eu</code> to use the Mailgun service hosted in Europe; set to <code>null</code> otherwise. <code>eu</code> or
   *     <code>null</code> are the only valid values for <code>region</code>.
   *   </li>
   *   <li><code>ses</code> requires <code>accessKeyId</code>, <code>secretAccessKey</code>, and <code>region</code></li>
   *   <li>
   *     <code>smtp</code> requires <code>smtp_host</code>, <code>smtp_port</code>, <code>smtp_user</code>, and
   *     <code>smtp_pass</code>
   *   </li>
   * </ul>
   * Depending on the type of provider it is possible to specify <code>settings</code> object with different configuration
   * options, which will be used when sending an email:
   * <ul>
   *   <li>
   *     <code>smtp</code> provider, <code>settings</code> may contain <code>headers</code> object.
   *     <ul>
   *       <li>
   *         When using AWS SES SMTP host, you may provide a name of configuration set in
   *         <code>X-SES-Configuration-Set</code> header. Value must be a string.
   *       </li>
   *       <li>
   *         When using Sparkpost host, you may provide value for
   *         <code>X-MSYS_API</code> header. Value must be an object.
   *       </li>
   *     </ul>
   *   </li>
   *   <li>
   *     for <code>ses</code> provider, <code>settings</code> may contain <code>message</code> object, where you can provide
   *     a name of configuration set in <code>configuration_set_name</code> property. Value must be a string.
   *   </li>
   * </ul>
   *
   * @param {Management.CreateEmailProviderRequestContent} request
   * @param {ProviderClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.emails.provider.create({
   *         name: "mailgun",
   *         credentials: {
   *             api_key: "api_key"
   *         }
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter48(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "emails/provider"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/emails/provider");
    });
  }
  /**
   * Delete the email provider.
   *
   * @param {ProviderClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.emails.provider.delete()
   */
  delete(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(requestOptions));
  }
  __delete(requestOptions) {
    return __awaiter48(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "emails/provider"),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/emails/provider");
    });
  }
  /**
   * Update an <a href="https://auth0.com/docs/email/providers">email provider</a>. The <code>credentials</code> object
   * requires different properties depending on the email provider (which is specified using the <code>name</code> property):
   * <ul>
   *   <li><code>mandrill</code> requires <code>api_key</code></li>
   *   <li><code>sendgrid</code> requires <code>api_key</code></li>
   *   <li>
   *     <code>sparkpost</code> requires <code>api_key</code>. Optionally, set <code>region</code> to <code>eu</code> to use
   *     the SparkPost service hosted in Western Europe; set to <code>null</code> to use the SparkPost service hosted in
   *     North America. <code>eu</code> or <code>null</code> are the only valid values for <code>region</code>.
   *   </li>
   *   <li>
   *     <code>mailgun</code> requires <code>api_key</code> and <code>domain</code>. Optionally, set <code>region</code> to
   *     <code>eu</code> to use the Mailgun service hosted in Europe; set to <code>null</code> otherwise. <code>eu</code> or
   *     <code>null</code> are the only valid values for <code>region</code>.
   *   </li>
   *   <li><code>ses</code> requires <code>accessKeyId</code>, <code>secretAccessKey</code>, and <code>region</code></li>
   *   <li>
   *     <code>smtp</code> requires <code>smtp_host</code>, <code>smtp_port</code>, <code>smtp_user</code>, and
   *     <code>smtp_pass</code>
   *   </li>
   * </ul>
   * Depending on the type of provider it is possible to specify <code>settings</code> object with different configuration
   * options, which will be used when sending an email:
   * <ul>
   *   <li>
   *     <code>smtp</code> provider, <code>settings</code> may contain <code>headers</code> object.
   *     <ul>
   *       <li>
   *         When using AWS SES SMTP host, you may provide a name of configuration set in
   *         <code>X-SES-Configuration-Set</code> header. Value must be a string.
   *       </li>
   *       <li>
   *         When using Sparkpost host, you may provide value for
   *         <code>X-MSYS_API</code> header. Value must be an object.
   *       </li>
   *     </ul>
   *     for <code>ses</code> provider, <code>settings</code> may contain <code>message</code> object, where you can provide
   *     a name of configuration set in <code>configuration_set_name</code> property. Value must be a string.
   *   </li>
   * </ul>
   *
   * @param {Management.UpdateEmailProviderRequestContent} request
   * @param {ProviderClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.emails.provider.update()
   */
  update(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update() {
    return __awaiter48(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "emails/provider"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/emails/provider");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/emails/client/Client.mjs
var EmailsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get provider() {
    var _a;
    return (_a = this._provider) !== null && _a !== void 0 ? _a : this._provider = new ProviderClient(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/emailTemplates/client/Client.mjs
var __awaiter49 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EmailTemplatesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Create an email template.
   *
   * @param {Management.CreateEmailTemplateRequestContent} request
   * @param {EmailTemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.emailTemplates.create({
   *         template: "verify_email"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter49(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "email-templates"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/email-templates");
    });
  }
  /**
   * Retrieve an email template by pre-defined name. These names are `verify_email`, `verify_email_by_code`, `reset_email`, `reset_email_by_code`, `welcome_email`, `blocked_account`, `stolen_credentials`, `enrollment_email`, `mfa_oob_code`, `user_invitation`, and `async_approval`. The names `change_password`, and `password_reset` are also supported for legacy scenarios.
   *
   * @param {Management.EmailTemplateNameEnum} templateName - Template name. Can be `verify_email`, `verify_email_by_code`, `reset_email`, `reset_email_by_code`, `welcome_email`, `blocked_account`, `stolen_credentials`, `enrollment_email`, `mfa_oob_code`, `user_invitation`, `async_approval`, `change_password` (legacy), or `password_reset` (legacy).
   * @param {EmailTemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.emailTemplates.get("verify_email")
   */
  get(templateName, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(templateName, requestOptions));
  }
  __get(templateName, requestOptions) {
    return __awaiter49(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `email-templates/${url_exports.encodePathParam(templateName)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/email-templates/{templateName}");
    });
  }
  /**
   * Update an email template.
   *
   * @param {Management.EmailTemplateNameEnum} templateName - Template name. Can be `verify_email`, `verify_email_by_code`, `reset_email`, `reset_email_by_code`, `welcome_email`, `blocked_account`, `stolen_credentials`, `enrollment_email`, `mfa_oob_code`, `user_invitation`, `async_approval`, `change_password` (legacy), or `password_reset` (legacy).
   * @param {Management.SetEmailTemplateRequestContent} request
   * @param {EmailTemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.emailTemplates.set("verify_email", {
   *         template: "verify_email"
   *     })
   */
  set(templateName, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(templateName, request, requestOptions));
  }
  __set(templateName, request, requestOptions) {
    return __awaiter49(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `email-templates/${url_exports.encodePathParam(templateName)}`),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/email-templates/{templateName}");
    });
  }
  /**
   * Modify an email template.
   *
   * @param {Management.EmailTemplateNameEnum} templateName - Template name. Can be `verify_email`, `verify_email_by_code`, `reset_email`, `reset_email_by_code`, `welcome_email`, `blocked_account`, `stolen_credentials`, `enrollment_email`, `mfa_oob_code`, `user_invitation`, `async_approval`, `change_password` (legacy), or `password_reset` (legacy).
   * @param {Management.UpdateEmailTemplateRequestContent} request
   * @param {EmailTemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.emailTemplates.update("verify_email")
   */
  update(templateName, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(templateName, request, requestOptions));
  }
  __update(templateName_1) {
    return __awaiter49(this, arguments, void 0, function* (templateName, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `email-templates/${url_exports.encodePathParam(templateName)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/email-templates/{templateName}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/eventStreams/resources/deliveries/client/Client.mjs
var __awaiter50 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DeliveriesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * @param {string} id - Unique identifier for the event stream.
   * @param {Management.ListEventStreamDeliveriesRequestParameters} request
   * @param {DeliveriesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.deliveries.list("id", {
   *         statuses: "statuses",
   *         event_types: "event_types",
   *         date_from: "date_from",
   *         date_to: "date_to",
   *         from: "from",
   *         take: 1
   *     })
   */
  list(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(id, request, requestOptions));
  }
  __list(id_1) {
    return __awaiter50(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { statuses, event_types: eventTypes, date_from: dateFrom, date_to: dateTo, from: from_, take = 50 } = request;
      const _queryParams = {};
      if (statuses !== void 0) {
        _queryParams["statuses"] = statuses;
      }
      if (eventTypes !== void 0) {
        _queryParams["event_types"] = eventTypes;
      }
      if (dateFrom !== void 0) {
        _queryParams["date_from"] = dateFrom;
      }
      if (dateTo !== void 0) {
        _queryParams["date_to"] = dateTo;
      }
      if (from_ !== void 0) {
        _queryParams["from"] = from_;
      }
      if (take !== void 0) {
        _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `event-streams/${url_exports.encodePathParam(id)}/deliveries`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/event-streams/{id}/deliveries");
    });
  }
  /**
   * @param {string} id - Unique identifier for the event stream.
   * @param {string} event_id - Unique identifier for the event
   * @param {DeliveriesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.deliveries.getHistory("id", "event_id")
   */
  getHistory(id, event_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getHistory(id, event_id, requestOptions));
  }
  __getHistory(id, event_id, requestOptions) {
    return __awaiter50(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `event-streams/${url_exports.encodePathParam(id)}/deliveries/${url_exports.encodePathParam(event_id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/event-streams/{id}/deliveries/{event_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/eventStreams/resources/redeliveries/client/Client.mjs
var __awaiter51 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RedeliveriesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * @param {string} id - Unique identifier for the event stream.
   * @param {Management.CreateEventStreamRedeliveryRequestContent} request
   * @param {RedeliveriesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.redeliveries.create("id")
   */
  create(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id_1) {
    return __awaiter51(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `event-streams/${url_exports.encodePathParam(id)}/redeliver`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/event-streams/{id}/redeliver");
    });
  }
  /**
   * @param {string} id - Unique identifier for the event stream.
   * @param {string} event_id - Unique identifier for the event
   * @param {RedeliveriesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.redeliveries.createById("id", "event_id")
   */
  createById(id, event_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__createById(id, event_id, requestOptions));
  }
  __createById(id, event_id, requestOptions) {
    return __awaiter51(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `event-streams/${url_exports.encodePathParam(id)}/redeliver/${url_exports.encodePathParam(event_id)}`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/event-streams/{id}/redeliver/{event_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/eventStreams/client/Client.mjs
var __awaiter52 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EventStreamsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get deliveries() {
    var _a;
    return (_a = this._deliveries) !== null && _a !== void 0 ? _a : this._deliveries = new DeliveriesClient(this._options);
  }
  get redeliveries() {
    var _a;
    return (_a = this._redeliveries) !== null && _a !== void 0 ? _a : this._redeliveries = new RedeliveriesClient(this._options);
  }
  /**
   * @param {Management.ListEventStreamsRequestParameters} request
   * @param {EventStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.list({
   *         from: "from",
   *         take: 1
   *     })
   */
  list(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
  }
  __list() {
    return __awaiter52(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { from: from_, take = 50 } = request;
      const _queryParams = {};
      if (from_ !== void 0) {
        _queryParams["from"] = from_;
      }
      if (take !== void 0) {
        _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "event-streams"),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/event-streams");
    });
  }
  /**
   * @param {Management.EventStreamsCreateRequest} request
   * @param {EventStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.create({
   *         destination: {
   *             type: "webhook",
   *             configuration: {
   *                 webhook_endpoint: "webhook_endpoint",
   *                 webhook_authorization: {
   *                     method: "basic",
   *                     username: "username"
   *                 }
   *             }
   *         }
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter52(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "event-streams"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/event-streams");
    });
  }
  /**
   * @param {string} id - Unique identifier for the event stream.
   * @param {EventStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter52(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `event-streams/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/event-streams/{id}");
    });
  }
  /**
   * @param {string} id - Unique identifier for the event stream.
   * @param {EventStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter52(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `event-streams/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/event-streams/{id}");
    });
  }
  /**
   * @param {string} id - Unique identifier for the event stream.
   * @param {Management.UpdateEventStreamRequestContent} request
   * @param {EventStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter52(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `event-streams/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/event-streams/{id}");
    });
  }
  /**
   * @param {string} id - Unique identifier for the event stream.
   * @param {Management.CreateEventStreamTestEventRequestContent} request
   * @param {EventStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.eventStreams.test("id", {
   *         event_type: "user.created"
   *     })
   */
  test(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__test(id, request, requestOptions));
  }
  __test(id, request, requestOptions) {
    return __awaiter52(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `event-streams/${url_exports.encodePathParam(id)}/test`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/event-streams/{id}/test");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/flows/resources/executions/client/Client.mjs
var __awaiter53 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ExecutionsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * @param {string} flow_id - Flow id
   * @param {Management.ExecutionsListRequest} request
   * @param {ExecutionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.executions.list("flow_id", {
   *         from: "from",
   *         take: 1
   *     })
   */
  list(flow_id_1) {
    return __awaiter53(this, arguments, void 0, function* (flow_id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter53(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `flows/${url_exports.encodePathParam(flow_id)}/executions`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/flows/{flow_id}/executions");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.executions) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * @param {string} flow_id - Flow id
   * @param {string} execution_id - Flow execution id
   * @param {Management.ExecutionsGetRequest} request
   * @param {ExecutionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.executions.get("flow_id", "execution_id")
   */
  get(flow_id, execution_id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(flow_id, execution_id, request, requestOptions));
  }
  __get(flow_id_1, execution_id_1) {
    return __awaiter53(this, arguments, void 0, function* (flow_id, execution_id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const { hydrate } = request;
      const _queryParams = {};
      if (hydrate !== void 0) {
        if (Array.isArray(hydrate)) {
          _queryParams["hydrate"] = hydrate.map((item) => item);
        } else {
          _queryParams["hydrate"] = hydrate;
        }
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `flows/${url_exports.encodePathParam(flow_id)}/executions/${url_exports.encodePathParam(execution_id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/flows/{flow_id}/executions/{execution_id}");
    });
  }
  /**
   * @param {string} flow_id - Flows id
   * @param {string} execution_id - Flow execution identifier
   * @param {ExecutionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.executions.delete("flow_id", "execution_id")
   */
  delete(flow_id, execution_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(flow_id, execution_id, requestOptions));
  }
  __delete(flow_id, execution_id, requestOptions) {
    return __awaiter53(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `flows/${url_exports.encodePathParam(flow_id)}/executions/${url_exports.encodePathParam(execution_id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/flows/{flow_id}/executions/{execution_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/flows/resources/vault/resources/connections/client/Client.mjs
var __awaiter54 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ConnectionsClient3 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * @param {Management.ListFlowsVaultConnectionsRequestParameters} request
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.vault.connections.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list() {
    return __awaiter54(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter54(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, "flows/vault/connections"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/flows/vault/connections");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.connections) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.connections) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * @param {Management.CreateFlowsVaultConnectionRequestContent} request
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.vault.connections.create({
   *         name: "name",
   *         app_id: "ACTIVECAMPAIGN",
   *         setup: {
   *             type: "API_KEY",
   *             api_key: "api_key",
   *             base_url: "base_url"
   *         }
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter54(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "flows/vault/connections"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/flows/vault/connections");
    });
  }
  /**
   * @param {string} id - Flows Vault connection ID
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.vault.connections.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter54(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `flows/vault/connections/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/flows/vault/connections/{id}");
    });
  }
  /**
   * @param {string} id - Vault connection id
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.vault.connections.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter54(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `flows/vault/connections/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/flows/vault/connections/{id}");
    });
  }
  /**
   * @param {string} id - Flows Vault connection ID
   * @param {Management.UpdateFlowsVaultConnectionRequestContent} request
   * @param {ConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.vault.connections.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter54(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `flows/vault/connections/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/flows/vault/connections/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/flows/resources/vault/client/Client.mjs
var VaultClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get connections() {
    var _a;
    return (_a = this._connections) !== null && _a !== void 0 ? _a : this._connections = new ConnectionsClient3(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/flows/client/Client.mjs
var __awaiter55 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FlowsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get executions() {
    var _a;
    return (_a = this._executions) !== null && _a !== void 0 ? _a : this._executions = new ExecutionsClient2(this._options);
  }
  get vault() {
    var _a;
    return (_a = this._vault) !== null && _a !== void 0 ? _a : this._vault = new VaultClient(this._options);
  }
  /**
   * @param {Management.FlowsListRequest} request
   * @param {FlowsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true,
   *         synchronous: true
   *     })
   */
  list() {
    return __awaiter55(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter55(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true, hydrate, synchronous } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (hydrate !== void 0) {
          if (Array.isArray(hydrate)) {
            _queryParams["hydrate"] = hydrate.map((item) => item);
          } else {
            _queryParams["hydrate"] = hydrate;
          }
        }
        if (synchronous !== void 0) {
          _queryParams["synchronous"] = (_d = synchronous === null || synchronous === void 0 ? void 0 : synchronous.toString()) !== null && _d !== void 0 ? _d : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_e = this._options) === null || _e === void 0 ? void 0 : _e.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_f = this._options.fetcher) !== null && _f !== void 0 ? _f : fetcher)({
          url: url_exports.join((_h = (_g = yield Supplier.get(this._options.baseUrl)) !== null && _g !== void 0 ? _g : yield Supplier.get(this._options.environment)) !== null && _h !== void 0 ? _h : ManagementEnvironment.Default, "flows"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_l = (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.timeoutInSeconds) !== null && _l !== void 0 ? _l : 60) * 1e3,
          maxRetries: (_m = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _m !== void 0 ? _m : (_o = this._options) === null || _o === void 0 ? void 0 : _o.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_p = this._options) === null || _p === void 0 ? void 0 : _p.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/flows");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.flows) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.flows) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * @param {Management.CreateFlowRequestContent} request
   * @param {FlowsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.create({
   *         name: "name"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter55(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "flows"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/flows");
    });
  }
  /**
   * @param {string} id - Flow identifier
   * @param {Management.GetFlowRequestParameters} request
   * @param {FlowsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.get("id")
   */
  get(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
  }
  __get(id_1) {
    return __awaiter55(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const { hydrate } = request;
      const _queryParams = {};
      if (hydrate !== void 0) {
        if (Array.isArray(hydrate)) {
          _queryParams["hydrate"] = hydrate.map((item) => item);
        } else {
          _queryParams["hydrate"] = hydrate;
        }
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `flows/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/flows/{id}");
    });
  }
  /**
   * @param {string} id - Flow id
   * @param {FlowsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter55(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `flows/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/flows/{id}");
    });
  }
  /**
   * @param {string} id - Flow identifier
   * @param {Management.UpdateFlowRequestContent} request
   * @param {FlowsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.flows.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter55(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `flows/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/flows/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/forms/client/Client.mjs
var __awaiter56 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FormsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * @param {Management.ListFormsRequestParameters} request
   * @param {FormsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.forms.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list() {
    return __awaiter56(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter56(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true, hydrate } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (hydrate !== void 0) {
          if (Array.isArray(hydrate)) {
            _queryParams["hydrate"] = hydrate.map((item) => item);
          } else {
            _queryParams["hydrate"] = hydrate;
          }
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, "forms"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/forms");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.forms) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.forms) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * @param {Management.CreateFormRequestContent} request
   * @param {FormsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.forms.create({
   *         name: "name"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter56(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "forms"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/forms");
    });
  }
  /**
   * @param {string} id - The ID of the form to retrieve.
   * @param {Management.GetFormRequestParameters} request
   * @param {FormsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.forms.get("id")
   */
  get(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
  }
  __get(id_1) {
    return __awaiter56(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const { hydrate } = request;
      const _queryParams = {};
      if (hydrate !== void 0) {
        if (Array.isArray(hydrate)) {
          _queryParams["hydrate"] = hydrate.map((item) => item);
        } else {
          _queryParams["hydrate"] = hydrate;
        }
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `forms/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/forms/{id}");
    });
  }
  /**
   * @param {string} id - The ID of the form to delete.
   * @param {FormsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.forms.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter56(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `forms/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/forms/{id}");
    });
  }
  /**
   * @param {string} id - The ID of the form to update.
   * @param {Management.UpdateFormRequestContent} request
   * @param {FormsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.forms.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter56(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `forms/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/forms/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/enrollments/client/Client.mjs
var __awaiter57 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EnrollmentsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Create a <a href="https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/create-custom-enrollment-tickets">multi-factor authentication (MFA) enrollment ticket</a>, and optionally send an email with the created ticket, to a given user.
   * Create a <a href="https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/create-custom-enrollment-tickets">multi-factor authentication (MFA) enrollment ticket</a>, and optionally send an email with the created ticket to a given user. Enrollment tickets can specify which factor users must enroll with or allow existing MFA users to enroll in additional factors.<br/>
   *
   * Note: Users cannot enroll in Email as a factor through custom enrollment tickets.
   *
   * @param {Management.CreateGuardianEnrollmentTicketRequestContent} request
   * @param {EnrollmentsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.guardian.enrollments.createTicket({
   *         user_id: "user_id"
   *     })
   */
  createTicket(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__createTicket(request, requestOptions));
  }
  __createTicket(request, requestOptions) {
    return __awaiter57(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/enrollments/ticket"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/guardian/enrollments/ticket");
    });
  }
  /**
   * Retrieve details, such as status and type, for a specific multi-factor authentication enrollment registered to a user account.
   *
   * @param {string} id - ID of the enrollment to be retrieve.
   * @param {EnrollmentsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.enrollments.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter57(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `guardian/enrollments/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/enrollments/{id}");
    });
  }
  /**
   * Remove a specific multi-factor authentication (MFA) enrollment from a user's account. This allows the user to re-enroll with MFA. For more information, review <a href="https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa">Reset User Multi-Factor Authentication and Recovery Codes</a>.
   *
   * @param {string} id - ID of the enrollment to be deleted.
   * @param {EnrollmentsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.enrollments.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter57(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `guardian/enrollments/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/guardian/enrollments/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/duo/resources/settings/client/Client.mjs
var __awaiter58 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SettingsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieves the DUO account and factor configuration.
   *
   * @param {SettingsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.duo.settings.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter58(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/duo/settings"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/duo/settings");
    });
  }
  /**
   * Set the DUO account configuration and other properties specific to this factor.
   *
   * @param {Management.SetGuardianFactorDuoSettingsRequestContent} request
   * @param {SettingsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.duo.settings.set()
   */
  set(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(request, requestOptions));
  }
  __set() {
    return __awaiter58(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/duo/settings"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/duo/settings");
    });
  }
  /**
   * @param {Management.UpdateGuardianFactorDuoSettingsRequestContent} request
   * @param {SettingsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.duo.settings.update()
   */
  update(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update() {
    return __awaiter58(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/duo/settings"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/guardian/factors/duo/settings");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/duo/client/Client.mjs
var DuoClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get settings() {
    var _a;
    return (_a = this._settings) !== null && _a !== void 0 ? _a : this._settings = new SettingsClient(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/phone/client/Client.mjs
var __awaiter59 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PhoneClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve list of <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa">phone-type MFA factors</a> (i.e., sms and voice) that are enabled for your tenant.
   *
   * @param {PhoneClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.phone.getMessageTypes()
   */
  getMessageTypes(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getMessageTypes(requestOptions));
  }
  __getMessageTypes(requestOptions) {
    return __awaiter59(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/phone/message-types"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/phone/message-types");
    });
  }
  /**
   * Replace the list of <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa">phone-type MFA factors</a> (i.e., sms and voice) that are enabled for your tenant.
   *
   * @param {Management.SetGuardianFactorPhoneMessageTypesRequestContent} request
   * @param {PhoneClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.guardian.factors.phone.setMessageTypes({
   *         message_types: ["sms"]
   *     })
   */
  setMessageTypes(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setMessageTypes(request, requestOptions));
  }
  __setMessageTypes(request, requestOptions) {
    return __awaiter59(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/phone/message-types"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/phone/message-types");
    });
  }
  /**
   * Retrieve configuration details for a Twilio phone provider that has been set up in your tenant. To learn more, review <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa">Configure SMS and Voice Notifications for MFA</a>.
   *
   * @param {PhoneClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.phone.getTwilioProvider()
   */
  getTwilioProvider(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getTwilioProvider(requestOptions));
  }
  __getTwilioProvider(requestOptions) {
    return __awaiter59(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/phone/providers/twilio"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/phone/providers/twilio");
    });
  }
  /**
   * Update the configuration of a Twilio phone provider that has been set up in your tenant. To learn more, review <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa">Configure SMS and Voice Notifications for MFA</a>.
   *
   * @param {Management.SetGuardianFactorsProviderPhoneTwilioRequestContent} request
   * @param {PhoneClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.phone.setTwilioProvider()
   */
  setTwilioProvider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setTwilioProvider(request, requestOptions));
  }
  __setTwilioProvider() {
    return __awaiter59(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/phone/providers/twilio"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/phone/providers/twilio");
    });
  }
  /**
   * Retrieve details of the multi-factor authentication phone provider configured for your tenant.
   *
   * @param {PhoneClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.phone.getSelectedProvider()
   */
  getSelectedProvider(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getSelectedProvider(requestOptions));
  }
  __getSelectedProvider(requestOptions) {
    return __awaiter59(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/phone/selected-provider"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/phone/selected-provider");
    });
  }
  /**
   * @param {Management.SetGuardianFactorsProviderPhoneRequestContent} request
   * @param {PhoneClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.phone.setProvider({
   *         provider: "auth0"
   *     })
   */
  setProvider(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setProvider(request, requestOptions));
  }
  __setProvider(request, requestOptions) {
    return __awaiter59(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/phone/selected-provider"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/phone/selected-provider");
    });
  }
  /**
   * Retrieve details of the multi-factor authentication enrollment and verification templates for phone-type factors available in your tenant.
   *
   * @param {PhoneClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.phone.getTemplates()
   */
  getTemplates(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getTemplates(requestOptions));
  }
  __getTemplates(requestOptions) {
    return __awaiter59(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/phone/templates"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/phone/templates");
    });
  }
  /**
   * Customize the messages sent to complete phone enrollment and verification (subscription required).
   *
   * @param {Management.SetGuardianFactorPhoneTemplatesRequestContent} request
   * @param {PhoneClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.phone.setTemplates({
   *         enrollment_message: "enrollment_message",
   *         verification_message: "verification_message"
   *     })
   */
  setTemplates(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setTemplates(request, requestOptions));
  }
  __setTemplates(request, requestOptions) {
    return __awaiter59(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/phone/templates"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/phone/templates");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/pushNotification/client/Client.mjs
var __awaiter60 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PushNotificationClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve configuration details for the multi-factor authentication APNS provider associated with your tenant.
   *
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.getApnsProvider()
   */
  getApnsProvider(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getApnsProvider(requestOptions));
  }
  __getApnsProvider(requestOptions) {
    return __awaiter60(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/apns"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/push-notification/providers/apns");
    });
  }
  /**
   * Overwrite all configuration details of the multi-factor authentication APNS provider associated with your tenant.
   *
   * @param {Management.SetGuardianFactorsProviderPushNotificationApnsRequestContent} request
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.setApnsProvider()
   */
  setApnsProvider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setApnsProvider(request, requestOptions));
  }
  __setApnsProvider() {
    return __awaiter60(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/apns"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/push-notification/providers/apns");
    });
  }
  /**
   * Modify configuration details of the multi-factor authentication APNS provider associated with your tenant.
   *
   * @param {Management.UpdateGuardianFactorsProviderPushNotificationApnsRequestContent} request
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.updateApnsProvider()
   */
  updateApnsProvider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__updateApnsProvider(request, requestOptions));
  }
  __updateApnsProvider() {
    return __awaiter60(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/apns"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/guardian/factors/push-notification/providers/apns");
    });
  }
  /**
   * Overwrite all configuration details of the multi-factor authentication FCM provider associated with your tenant.
   *
   * @param {Management.SetGuardianFactorsProviderPushNotificationFcmRequestContent} request
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.setFcmProvider()
   */
  setFcmProvider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setFcmProvider(request, requestOptions));
  }
  __setFcmProvider() {
    return __awaiter60(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/fcm"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/push-notification/providers/fcm");
    });
  }
  /**
   * Modify configuration details of the multi-factor authentication FCM provider associated with your tenant.
   *
   * @param {Management.UpdateGuardianFactorsProviderPushNotificationFcmRequestContent} request
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.updateFcmProvider()
   */
  updateFcmProvider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__updateFcmProvider(request, requestOptions));
  }
  __updateFcmProvider() {
    return __awaiter60(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/fcm"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/guardian/factors/push-notification/providers/fcm");
    });
  }
  /**
   * Overwrite all configuration details of the multi-factor authentication FCMV1 provider associated with your tenant.
   *
   * @param {Management.SetGuardianFactorsProviderPushNotificationFcmv1RequestContent} request
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.setFcmv1Provider()
   */
  setFcmv1Provider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setFcmv1Provider(request, requestOptions));
  }
  __setFcmv1Provider() {
    return __awaiter60(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/fcmv1"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/push-notification/providers/fcmv1");
    });
  }
  /**
   * Modify configuration details of the multi-factor authentication FCMV1 provider associated with your tenant.
   *
   * @param {Management.UpdateGuardianFactorsProviderPushNotificationFcmv1RequestContent} request
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.updateFcmv1Provider()
   */
  updateFcmv1Provider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__updateFcmv1Provider(request, requestOptions));
  }
  __updateFcmv1Provider() {
    return __awaiter60(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/fcmv1"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/guardian/factors/push-notification/providers/fcmv1");
    });
  }
  /**
   * Retrieve configuration details for an AWS SNS push notification provider that has been enabled for MFA. To learn more, review <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa">Configure Push Notifications for MFA</a>.
   *
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.getSnsProvider()
   */
  getSnsProvider(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getSnsProvider(requestOptions));
  }
  __getSnsProvider(requestOptions) {
    return __awaiter60(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/sns"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/push-notification/providers/sns");
    });
  }
  /**
   * Configure the <a href="https://auth0.com/docs/multifactor-authentication/developer/sns-configuration">AWS SNS push notification provider configuration</a> (subscription required).
   *
   * @param {Management.SetGuardianFactorsProviderPushNotificationSnsRequestContent} request
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.setSnsProvider()
   */
  setSnsProvider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setSnsProvider(request, requestOptions));
  }
  __setSnsProvider() {
    return __awaiter60(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/sns"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/push-notification/providers/sns");
    });
  }
  /**
   * Configure the <a href="https://auth0.com/docs/multifactor-authentication/developer/sns-configuration">AWS SNS push notification provider configuration</a> (subscription required).
   *
   * @param {Management.UpdateGuardianFactorsProviderPushNotificationSnsRequestContent} request
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.updateSnsProvider()
   */
  updateSnsProvider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__updateSnsProvider(request, requestOptions));
  }
  __updateSnsProvider() {
    return __awaiter60(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/providers/sns"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/guardian/factors/push-notification/providers/sns");
    });
  }
  /**
   * Modify the push notification provider configured for your tenant. For more information, review <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa">Configure Push Notifications for MFA</a>.
   *
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.getSelectedProvider()
   */
  getSelectedProvider(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getSelectedProvider(requestOptions));
  }
  __getSelectedProvider(requestOptions) {
    return __awaiter60(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/selected-provider"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/push-notification/selected-provider");
    });
  }
  /**
   * Modify the push notification provider configured for your tenant. For more information, review <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa">Configure Push Notifications for MFA</a>.
   *
   * @param {Management.SetGuardianFactorsProviderPushNotificationRequestContent} request
   * @param {PushNotificationClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.pushNotification.setProvider({
   *         provider: "guardian"
   *     })
   */
  setProvider(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setProvider(request, requestOptions));
  }
  __setProvider(request, requestOptions) {
    return __awaiter60(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/push-notification/selected-provider"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/push-notification/selected-provider");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/resources/sms/client/Client.mjs
var __awaiter61 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SmsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve the <a href="https://auth0.com/docs/multifactor-authentication/twilio-configuration">Twilio SMS provider configuration</a> (subscription required).
   *
   *     A new endpoint is available to retrieve the Twilio configuration related to phone factors (<a href='https://auth0.com/docs/api/management/v2/#!/Guardian/get_twilio'>phone Twilio configuration</a>). It has the same payload as this one. Please use it instead.
   *
   * @param {SmsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.sms.getTwilioProvider()
   */
  getTwilioProvider(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getTwilioProvider(requestOptions));
  }
  __getTwilioProvider(requestOptions) {
    return __awaiter61(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/sms/providers/twilio"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/sms/providers/twilio");
    });
  }
  /**
   * This endpoint has been deprecated. To complete this action, use the <a href="https://auth0.com/docs/api/management/v2/guardian/put-twilio">Update Twilio phone configuration</a> endpoint.
   *
   *     <b>Previous functionality</b>: Update the Twilio SMS provider configuration.
   *
   * @param {Management.SetGuardianFactorsProviderSmsTwilioRequestContent} request
   * @param {SmsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.sms.setTwilioProvider()
   */
  setTwilioProvider(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setTwilioProvider(request, requestOptions));
  }
  __setTwilioProvider() {
    return __awaiter61(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/sms/providers/twilio"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/sms/providers/twilio");
    });
  }
  /**
   * This endpoint has been deprecated. To complete this action, use the <a href="https://auth0.com/docs/api/management/v2/guardian/get-phone-providers">Retrieve phone configuration</a> endpoint instead.
   *
   *     <b>Previous functionality</b>: Retrieve details for the multi-factor authentication SMS provider configured for your tenant.
   *
   * @param {SmsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.sms.getSelectedProvider()
   */
  getSelectedProvider(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getSelectedProvider(requestOptions));
  }
  __getSelectedProvider(requestOptions) {
    return __awaiter61(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/sms/selected-provider"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/sms/selected-provider");
    });
  }
  /**
   * This endpoint has been deprecated. To complete this action, use the <a href="https://auth0.com/docs/api/management/v2/guardian/put-phone-providers">Update phone configuration</a> endpoint instead.
   *
   *     <b>Previous functionality</b>: Update the multi-factor authentication SMS provider configuration in your tenant.
   *
   * @param {Management.SetGuardianFactorsProviderSmsRequestContent} request
   * @param {SmsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.sms.setProvider({
   *         provider: "auth0"
   *     })
   */
  setProvider(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setProvider(request, requestOptions));
  }
  __setProvider(request, requestOptions) {
    return __awaiter61(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/sms/selected-provider"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/sms/selected-provider");
    });
  }
  /**
   * This endpoint has been deprecated. To complete this action, use the <a href="https://auth0.com/docs/api/management/v2/guardian/get-factor-phone-templates">Retrieve enrollment and verification phone templates</a> endpoint instead.
   *
   *     <b>Previous function</b>: Retrieve details of SMS enrollment and verification templates configured for your tenant.
   *
   * @param {SmsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.sms.getTemplates()
   */
  getTemplates(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getTemplates(requestOptions));
  }
  __getTemplates(requestOptions) {
    return __awaiter61(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/sms/templates"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors/sms/templates");
    });
  }
  /**
   * This endpoint has been deprecated. To complete this action, use the <a href="https://auth0.com/docs/api/management/v2/guardian/put-factor-phone-templates">Update enrollment and verification phone templates</a> endpoint instead.
   *
   *     <b>Previous functionality</b>: Customize the messages sent to complete SMS enrollment and verification.
   *
   * @param {Management.SetGuardianFactorSmsTemplatesRequestContent} request
   * @param {SmsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.sms.setTemplates({
   *         enrollment_message: "enrollment_message",
   *         verification_message: "verification_message"
   *     })
   */
  setTemplates(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__setTemplates(request, requestOptions));
  }
  __setTemplates(request, requestOptions) {
    return __awaiter61(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors/sms/templates"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/sms/templates");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/factors/client/Client.mjs
var __awaiter62 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FactorsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get phone() {
    var _a;
    return (_a = this._phone) !== null && _a !== void 0 ? _a : this._phone = new PhoneClient2(this._options);
  }
  get pushNotification() {
    var _a;
    return (_a = this._pushNotification) !== null && _a !== void 0 ? _a : this._pushNotification = new PushNotificationClient(this._options);
  }
  get sms() {
    var _a;
    return (_a = this._sms) !== null && _a !== void 0 ? _a : this._sms = new SmsClient(this._options);
  }
  get duo() {
    var _a;
    return (_a = this._duo) !== null && _a !== void 0 ? _a : this._duo = new DuoClient(this._options);
  }
  /**
   * Retrieve details of all <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors">multi-factor authentication factors</a> associated with your tenant.
   *
   * @param {FactorsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.list()
   */
  list(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter62(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/factors"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/factors");
    });
  }
  /**
   * Update the status (i.e., enabled or disabled) of a specific multi-factor authentication factor.
   *
   * @param {Management.GuardianFactorNameEnum} name - Factor name. Can be `sms`, `push-notification`, `email`, `duo` `otp` `webauthn-roaming`, `webauthn-platform`, or `recovery-code`.
   * @param {Management.SetGuardianFactorRequestContent} request
   * @param {FactorsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.factors.set("push-notification", {
   *         enabled: true
   *     })
   */
  set(name, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(name, request, requestOptions));
  }
  __set(name, request, requestOptions) {
    return __awaiter62(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `guardian/factors/${url_exports.encodePathParam(name)}`),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/factors/{name}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/resources/policies/client/Client.mjs
var __awaiter63 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PoliciesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve the <a href="https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa">multi-factor authentication (MFA) policies</a> configured for your tenant.
   *
   * The following policies are supported:
   * <ul>
   * <li><code>all-applications</code> policy prompts with MFA for all logins.</li>
   * <li><code>confidence-score</code> policy prompts with MFA only for low confidence logins.</li>
   * </ul>
   *
   * <b>Note</b>: The <code>confidence-score</code> policy is part of the <a href="https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa">Adaptive MFA feature</a>. Adaptive MFA requires an add-on for the Enterprise plan; review <a href="https://auth0.com/pricing">Auth0 Pricing</a> for more details.
   *
   * @param {PoliciesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.policies.list()
   */
  list(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter63(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/policies"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/guardian/policies");
    });
  }
  /**
   * Set <a href="https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa">multi-factor authentication (MFA) policies</a> for your tenant.
   *
   * The following policies are supported:
   * <ul>
   * <li><code>all-applications</code> policy prompts with MFA for all logins.</li>
   * <li><code>confidence-score</code> policy prompts with MFA only for low confidence logins.</li>
   * </ul>
   *
   * <b>Note</b>: The <code>confidence-score</code> policy is part of the <a href="https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa">Adaptive MFA feature</a>. Adaptive MFA requires an add-on for the Enterprise plan; review <a href="https://auth0.com/pricing">Auth0 Pricing</a> for more details.
   *
   * @param {Management.SetGuardianPoliciesRequestContent} request
   * @param {PoliciesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.guardian.policies.set(["all-applications"])
   */
  set(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(request, requestOptions));
  }
  __set(request, requestOptions) {
    return __awaiter63(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "guardian/policies"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/guardian/policies");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/guardian/client/Client.mjs
var GuardianClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get enrollments() {
    var _a;
    return (_a = this._enrollments) !== null && _a !== void 0 ? _a : this._enrollments = new EnrollmentsClient(this._options);
  }
  get factors() {
    var _a;
    return (_a = this._factors) !== null && _a !== void 0 ? _a : this._factors = new FactorsClient(this._options);
  }
  get policies() {
    var _a;
    return (_a = this._policies) !== null && _a !== void 0 ? _a : this._policies = new PoliciesClient(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/hooks/resources/secrets/client/Client.mjs
var __awaiter64 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SecretsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve a hook's secrets by the ID of the hook.
   *
   * @param {string} id - ID of the hook to retrieve secrets from.
   * @param {SecretsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.hooks.secrets.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter64(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `hooks/${url_exports.encodePathParam(id)}/secrets`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/hooks/{id}/secrets");
    });
  }
  /**
   * Add one or more secrets to an existing hook. Accepts an object of key-value pairs, where the key is the name of the secret. A hook can have a maximum of 20 secrets.
   *
   * @param {string} id - The id of the hook to retrieve
   * @param {Management.CreateHookSecretRequestContent} request
   * @param {SecretsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.hooks.secrets.create("id", {
   *         "key": "value"
   *     })
   */
  create(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id, request, requestOptions) {
    return __awaiter64(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `hooks/${url_exports.encodePathParam(id)}/secrets`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/hooks/{id}/secrets");
    });
  }
  /**
   * Delete one or more existing secrets for a given hook. Accepts an array of secret names to delete.
   *
   * @param {string} id - ID of the hook whose secrets to delete.
   * @param {Management.DeleteHookSecretRequestContent} request
   * @param {SecretsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.hooks.secrets.delete("id", ["string"])
   */
  delete(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, request, requestOptions));
  }
  __delete(id, request, requestOptions) {
    return __awaiter64(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `hooks/${url_exports.encodePathParam(id)}/secrets`),
        method: "DELETE",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/hooks/{id}/secrets");
    });
  }
  /**
   * Update one or more existing secrets for an existing hook. Accepts an object of key-value pairs, where the key is the name of the existing secret.
   *
   * @param {string} id - ID of the hook whose secrets to update.
   * @param {Management.UpdateHookSecretRequestContent} request
   * @param {SecretsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.hooks.secrets.update("id", {
   *         "key": "value"
   *     })
   */
  update(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id, request, requestOptions) {
    return __awaiter64(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `hooks/${url_exports.encodePathParam(id)}/secrets`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/hooks/{id}/secrets");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/hooks/client/Client.mjs
var __awaiter65 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HooksClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get secrets() {
    var _a;
    return (_a = this._secrets) !== null && _a !== void 0 ? _a : this._secrets = new SecretsClient(this._options);
  }
  /**
   * Retrieve all <a href="https://auth0.com/docs/hooks">hooks</a>. Accepts a list of fields to include or exclude in the result.
   *
   * @param {Management.ListHooksRequestParameters} request
   * @param {HooksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.hooks.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true,
   *         enabled: true,
   *         fields: "fields",
   *         triggerId: "credentials-exchange"
   *     })
   */
  list() {
    return __awaiter65(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter65(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true, enabled, fields, triggerId } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (enabled !== void 0) {
          _queryParams["enabled"] = (_d = enabled === null || enabled === void 0 ? void 0 : enabled.toString()) !== null && _d !== void 0 ? _d : null;
        }
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (triggerId !== void 0) {
          _queryParams["triggerId"] = triggerId;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_e = this._options) === null || _e === void 0 ? void 0 : _e.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_f = this._options.fetcher) !== null && _f !== void 0 ? _f : fetcher)({
          url: url_exports.join((_h = (_g = yield Supplier.get(this._options.baseUrl)) !== null && _g !== void 0 ? _g : yield Supplier.get(this._options.environment)) !== null && _h !== void 0 ? _h : ManagementEnvironment.Default, "hooks"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_l = (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.timeoutInSeconds) !== null && _l !== void 0 ? _l : 60) * 1e3,
          maxRetries: (_m = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _m !== void 0 ? _m : (_o = this._options) === null || _o === void 0 ? void 0 : _o.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_p = this._options) === null || _p === void 0 ? void 0 : _p.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/hooks");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.hooks) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.hooks) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create a new hook.
   *
   * @param {Management.CreateHookRequestContent} request
   * @param {HooksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.hooks.create({
   *         name: "name",
   *         script: "script",
   *         triggerId: "credentials-exchange"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter65(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "hooks"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/hooks");
    });
  }
  /**
   * Retrieve <a href="https://auth0.com/docs/hooks">a hook</a> by its ID. Accepts a list of fields to include in the result.
   *
   * @param {string} id - ID of the hook to retrieve.
   * @param {Management.GetHookRequestParameters} request
   * @param {HooksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.hooks.get("id", {
   *         fields: "fields"
   *     })
   */
  get(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
  }
  __get(id_1) {
    return __awaiter65(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const { fields } = request;
      const _queryParams = {};
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `hooks/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/hooks/{id}");
    });
  }
  /**
   * Delete a hook.
   *
   * @param {string} id - ID of the hook to delete.
   * @param {HooksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.hooks.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter65(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `hooks/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/hooks/{id}");
    });
  }
  /**
   * Update an existing hook.
   *
   * @param {string} id - ID of the hook to update.
   * @param {Management.UpdateHookRequestContent} request
   * @param {HooksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.hooks.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter65(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `hooks/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/hooks/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/resources/errors/client/Client.mjs
var __awaiter66 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ErrorsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve error details of a failed job.
   *
   * @param {string} id - ID of the job.
   * @param {ErrorsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.jobs.errors.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter66(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `jobs/${url_exports.encodePathParam(id)}/errors`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/jobs/{id}/errors");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/resources/usersExports/client/Client.mjs
var __awaiter67 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UsersExportsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Export all users to a file via a long-running job.
   *
   * @param {Management.CreateExportUsersRequestContent} request
   * @param {UsersExportsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.jobs.usersExports.create()
   */
  create(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create() {
    return __awaiter67(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "jobs/users-exports"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/jobs/users-exports");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/resources/usersImports/client/Client.mjs
var __awaiter68 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UsersImportsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Import users from a <a href="https://auth0.com/docs/users/references/bulk-import-database-schema-examples">formatted file</a> into a connection via a long-running job. When importing users, with or without upsert, the `email_verified` is set to `false` when the email address is added or updated. Users must verify their email address. To avoid this behavior, set `email_verified` to `true` in the imported data.
   *
   * @param {Management.CreateImportUsersRequestContent} request
   * @param {UsersImportsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ContentTooLargeError}
   * @throws {@link Management.TooManyRequestsError}
   * @throws {@link Management.InternalServerError}
   *
   * @example
   *     import { createReadStream } from "fs";
   *     await client.jobs.usersImports.create({
   *         users: fs.createReadStream("/path/to/your/file"),
   *         connection_id: "connection_id"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter68(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _request = yield newFormData();
      yield _request.appendFile("users", request.users);
      _request.append("connection_id", request.connection_id);
      if (request.upsert != null) {
        _request.append("upsert", request.upsert.toString());
      }
      if (request.external_id != null) {
        _request.append("external_id", request.external_id);
      }
      if (request.send_completion_email != null) {
        _request.append("send_completion_email", request.send_completion_email.toString());
      }
      const _maybeEncodedRequest = yield _request.getRequest();
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, _maybeEncodedRequest.headers)), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "jobs/users-imports"),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "file",
        duplex: _maybeEncodedRequest.duplex,
        body: _maybeEncodedRequest.body,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 413:
            throw new ContentTooLargeError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          case 500:
            throw new InternalServerError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/jobs/users-imports");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/resources/verificationEmail/client/Client.mjs
var __awaiter69 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var VerificationEmailClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Send an email to the specified user that asks them to click a link to <a href="https://auth0.com/docs/email/custom#verification-email">verify their email address</a>.
   *
   * Note: You must have the `Status` toggle enabled for the verification email template for the email to be sent.
   *
   * @param {Management.CreateVerificationEmailRequestContent} request
   * @param {VerificationEmailClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.jobs.verificationEmail.create({
   *         user_id: "user_id"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter69(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "jobs/verification-email"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/jobs/verification-email");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/jobs/client/Client.mjs
var __awaiter70 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var JobsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get usersExports() {
    var _a;
    return (_a = this._usersExports) !== null && _a !== void 0 ? _a : this._usersExports = new UsersExportsClient(this._options);
  }
  get usersImports() {
    var _a;
    return (_a = this._usersImports) !== null && _a !== void 0 ? _a : this._usersImports = new UsersImportsClient(this._options);
  }
  get verificationEmail() {
    var _a;
    return (_a = this._verificationEmail) !== null && _a !== void 0 ? _a : this._verificationEmail = new VerificationEmailClient(this._options);
  }
  get errors() {
    var _a;
    return (_a = this._errors) !== null && _a !== void 0 ? _a : this._errors = new ErrorsClient(this._options);
  }
  /**
   * Retrieves a job. Useful to check its status.
   *
   * @param {string} id - ID of the job.
   * @param {JobsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.jobs.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter70(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `jobs/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/jobs/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/keys/resources/customSigning/client/Client.mjs
var __awaiter71 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CustomSigningClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Get entire jwks representation of custom signing keys.
   *
   * @param {CustomSigningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.customSigning.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter71(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "keys/custom-signing"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/keys/custom-signing");
    });
  }
  /**
   * Create or replace entire jwks representation of custom signing keys.
   *
   * @param {Management.SetCustomSigningKeysRequestContent} request
   * @param {CustomSigningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.customSigning.set({
   *         keys: [{
   *                 kty: "EC"
   *             }]
   *     })
   */
  set(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(request, requestOptions));
  }
  __set(request, requestOptions) {
    return __awaiter71(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "keys/custom-signing"),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/keys/custom-signing");
    });
  }
  /**
   * Delete entire jwks representation of custom signing keys.
   *
   * @param {CustomSigningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.customSigning.delete()
   */
  delete(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(requestOptions));
  }
  __delete(requestOptions) {
    return __awaiter71(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "keys/custom-signing"),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/keys/custom-signing");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/keys/resources/encryption/client/Client.mjs
var __awaiter72 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EncryptionClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details of all the encryption keys associated with your tenant.
   *
   * @param {Management.ListEncryptionKeysRequestParameters} request
   * @param {EncryptionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.encryption.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list() {
    return __awaiter72(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter72(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, "keys/encryption"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/keys/encryption");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.keys) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.keys) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create the new, pre-activated encryption key, without the key material.
   *
   * @param {Management.CreateEncryptionKeyRequestContent} request
   * @param {EncryptionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.encryption.create({
   *         type: "customer-provided-root-key"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter72(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "keys/encryption"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/keys/encryption");
    });
  }
  /**
   * Perform rekeying operation on the key hierarchy.
   *
   * @param {EncryptionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.encryption.rekey()
   */
  rekey(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__rekey(requestOptions));
  }
  __rekey(requestOptions) {
    return __awaiter72(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "keys/encryption/rekey"),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/keys/encryption/rekey");
    });
  }
  /**
   * Retrieve details of the encryption key with the given ID.
   *
   * @param {string} kid - Encryption key ID
   * @param {EncryptionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.encryption.get("kid")
   */
  get(kid, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(kid, requestOptions));
  }
  __get(kid, requestOptions) {
    return __awaiter72(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `keys/encryption/${url_exports.encodePathParam(kid)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/keys/encryption/{kid}");
    });
  }
  /**
   * Import wrapped key material and activate encryption key.
   *
   * @param {string} kid - Encryption key ID
   * @param {Management.ImportEncryptionKeyRequestContent} request
   * @param {EncryptionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.encryption.import("kid", {
   *         wrapped_key: "wrapped_key"
   *     })
   */
  import(kid, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__import(kid, request, requestOptions));
  }
  __import(kid, request, requestOptions) {
    return __awaiter72(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `keys/encryption/${url_exports.encodePathParam(kid)}`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/keys/encryption/{kid}");
    });
  }
  /**
   * Delete the custom provided encryption key with the given ID and move back to using native encryption key.
   *
   * @param {string} kid - Encryption key ID
   * @param {EncryptionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.encryption.delete("kid")
   */
  delete(kid, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(kid, requestOptions));
  }
  __delete(kid, requestOptions) {
    return __awaiter72(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `keys/encryption/${url_exports.encodePathParam(kid)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/keys/encryption/{kid}");
    });
  }
  /**
   * Create the public wrapping key to wrap your own encryption key material.
   *
   * @param {string} kid - Encryption key ID
   * @param {EncryptionClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.encryption.createPublicWrappingKey("kid")
   */
  createPublicWrappingKey(kid, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__createPublicWrappingKey(kid, requestOptions));
  }
  __createPublicWrappingKey(kid, requestOptions) {
    return __awaiter72(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `keys/encryption/${url_exports.encodePathParam(kid)}/wrapping-key`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/keys/encryption/{kid}/wrapping-key");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/keys/resources/signing/client/Client.mjs
var __awaiter73 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SigningClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details of all the application signing keys associated with your tenant.
   *
   * @param {SigningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.signing.list()
   */
  list(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter73(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "keys/signing"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/keys/signing");
    });
  }
  /**
   * Rotate the application signing key of your tenant.
   *
   * @param {SigningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.signing.rotate()
   */
  rotate(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__rotate(requestOptions));
  }
  __rotate(requestOptions) {
    return __awaiter73(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "keys/signing/rotate"),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/keys/signing/rotate");
    });
  }
  /**
   * Retrieve details of the application signing key with the given ID.
   *
   * @param {string} kid - Key id of the key to retrieve
   * @param {SigningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.signing.get("kid")
   */
  get(kid, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(kid, requestOptions));
  }
  __get(kid, requestOptions) {
    return __awaiter73(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `keys/signing/${url_exports.encodePathParam(kid)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/keys/signing/{kid}");
    });
  }
  /**
   * Revoke the application signing key with the given ID.
   *
   * @param {string} kid - Key id of the key to revoke
   * @param {SigningClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.keys.signing.revoke("kid")
   */
  revoke(kid, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__revoke(kid, requestOptions));
  }
  __revoke(kid, requestOptions) {
    return __awaiter73(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `keys/signing/${url_exports.encodePathParam(kid)}/revoke`),
        method: "PUT",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/keys/signing/{kid}/revoke");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/keys/client/Client.mjs
var KeysClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get customSigning() {
    var _a;
    return (_a = this._customSigning) !== null && _a !== void 0 ? _a : this._customSigning = new CustomSigningClient(this._options);
  }
  get encryption() {
    var _a;
    return (_a = this._encryption) !== null && _a !== void 0 ? _a : this._encryption = new EncryptionClient(this._options);
  }
  get signing() {
    var _a;
    return (_a = this._signing) !== null && _a !== void 0 ? _a : this._signing = new SigningClient(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/logs/client/Client.mjs
var __awaiter74 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LogsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve log entries that match the specified search criteria (or all log entries if no criteria specified).
   *
   * Set custom search criteria using the <code>q</code> parameter, or search from a specific log ID (<i>"search from checkpoint"</i>).
   *
   * For more information on all possible event types, their respective acronyms, and descriptions, see <a href="https://auth0.com/docs/logs/log-event-type-codes">Log Event Type Codes</a>.
   *
   * <h5>To set custom search criteria, use the following parameters:</h5>
   *
   * <ul>
   *     <li><b>q:</b> Search Criteria using <a href="https://auth0.com/docs/logs/log-search-query-syntax">Query String Syntax</a></li>
   *     <li><b>page:</b> Page index of the results to return. First page is 0.</li>
   *     <li><b>per_page:</b> Number of results per page.</li>
   *     <li><b>sort:</b> Field to use for sorting appended with `:1` for ascending and `:-1` for descending. e.g. `date:-1`</li>
   *     <li><b>fields:</b> Comma-separated list of fields to include or exclude (depending on include_fields) from the result, empty to retrieve all fields.</li>
   *     <li><b>include_fields:</b> Whether specified fields are to be included (true) or excluded (false).</li>
   *     <li><b>include_totals:</b> Return results inside an object that contains the total result count (true) or as a direct array of results (false, default). <b>Deprecated:</b> this field is deprecated and should be removed from use. See <a href="https://auth0.com/docs/product-lifecycle/deprecations-and-migrations/migrate-to-tenant-log-search-v3#pagination">Search Engine V3 Breaking Changes</a></li>
   * </ul>
   *
   * For more information on the list of fields that can be used in <code>fields</code> and <code>sort</code>, see <a href="https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields">Searchable Fields</a>.
   *
   * Auth0 <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations">limits the number of logs</a> you can return by search criteria to 100 logs per request. Furthermore, you may paginate only through 1,000 search results. If you exceed this threshold, please redefine your search or use the <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#retrieve-logs-by-checkpoint">get logs by checkpoint method</a>.
   *
   * <h5>To search from a checkpoint log ID, use the following parameters:</h5>
   * <ul>
   *     <li><b>from:</b> Log Event ID from which to start retrieving logs. You can limit the number of logs returned using the <code>take</code> parameter. If you use <code>from</code> at the same time as <code>q</code>, <code>from</code> takes precedence and <code>q</code> is ignored.</li>
   *     <li><b>take:</b> Number of entries to retrieve when using the <code>from</code> parameter.</li>
   * </ul>
   *
   * <strong>Important:</strong> When fetching logs from a checkpoint log ID, any parameter other than <code>from</code> and <code>take</code> will be ignored, and date ordering is not guaranteed.
   *
   * @param {Management.ListLogsRequestParameters} request
   * @param {LogsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.logs.list({
   *         page: 1,
   *         per_page: 1,
   *         sort: "sort",
   *         fields: "fields",
   *         include_fields: true,
   *         include_totals: true,
   *         search: "search"
   *     })
   */
  list() {
    return __awaiter74(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter74(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const { page = 0, per_page: perPage = 50, sort, fields, include_fields: includeFields, include_totals: includeTotals = true, search } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (sort !== void 0) {
          _queryParams["sort"] = sort;
        }
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_c = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_d = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _d !== void 0 ? _d : null;
        }
        if (search !== void 0) {
          _queryParams["search"] = search;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_e = this._options) === null || _e === void 0 ? void 0 : _e.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_f = this._options.fetcher) !== null && _f !== void 0 ? _f : fetcher)({
          url: url_exports.join((_h = (_g = yield Supplier.get(this._options.baseUrl)) !== null && _g !== void 0 ? _g : yield Supplier.get(this._options.environment)) !== null && _h !== void 0 ? _h : ManagementEnvironment.Default, "logs"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_l = (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.timeoutInSeconds) !== null && _l !== void 0 ? _l : 60) * 1e3,
          maxRetries: (_m = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _m !== void 0 ? _m : (_o = this._options) === null || _o === void 0 ? void 0 : _o.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_p = this._options) === null || _p === void 0 ? void 0 : _p.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/logs");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.logs) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.logs) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Retrieve an individual log event.
   *
   * @param {string} id - log_id of the log to retrieve.
   * @param {LogsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.logs.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter74(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `logs/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/logs/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/logStreams/client/Client.mjs
var __awaiter75 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LogStreamsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details on <a href="https://auth0.com/docs/logs/streams">log streams</a>.
   * <h5>Sample Response</h5><pre><code>[{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "eventbridge",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"awsAccountId": "string",
   * 		"awsRegion": "string",
   * 		"awsPartnerEventSource": "string"
   * 	}
   * }, {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "http",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"httpContentFormat": "JSONLINES|JSONARRAY",
   * 		"httpContentType": "string",
   * 		"httpEndpoint": "string",
   * 		"httpAuthorization": "string"
   * 	}
   * },
   * {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "eventgrid",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"azureSubscriptionId": "string",
   * 		"azureResourceGroup": "string",
   * 		"azureRegion": "string",
   * 		"azurePartnerTopic": "string"
   * 	}
   * },
   * {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "splunk",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"splunkDomain": "string",
   * 		"splunkToken": "string",
   * 		"splunkPort": "string",
   * 		"splunkSecure": "boolean"
   * 	}
   * },
   * {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "sumo",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"sumoSourceAddress": "string",
   * 	}
   * },
   * {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "datadog",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   * 	}
   * }]</code></pre>
   *
   * @param {LogStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.logStreams.list()
   */
  list(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter75(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "log-streams"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/log-streams");
    });
  }
  /**
   * Create a log stream.
   * <h5>Log Stream Types</h5> The <code>type</code> of log stream being created determines the properties required in the <code>sink</code> payload.
   * <h5>HTTP Stream</h5> For an <code>http</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "http",
   * 	"sink": {
   * 		"httpEndpoint": "string",
   * 		"httpContentType": "string",
   * 		"httpContentFormat": "JSONLINES|JSONARRAY",
   * 		"httpAuthorization": "string"
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "http",
   * 	"status": "active",
   * 	"sink": {
   * 		"httpEndpoint": "string",
   * 		"httpContentType": "string",
   * 		"httpContentFormat": "JSONLINES|JSONARRAY",
   * 		"httpAuthorization": "string"
   * 	}
   * }</code></pre>
   * <h5>Amazon EventBridge Stream</h5> For an <code>eventbridge</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "eventbridge",
   * 	"sink": {
   * 		"awsRegion": "string",
   * 		"awsAccountId": "string"
   * 	}
   * }</code></pre>
   * The response will include an additional field <code>awsPartnerEventSource</code> in the <code>sink</code>: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "eventbridge",
   * 	"status": "active",
   * 	"sink": {
   * 		"awsAccountId": "string",
   * 		"awsRegion": "string",
   * 		"awsPartnerEventSource": "string"
   * 	}
   * }</code></pre>
   * <h5>Azure Event Grid Stream</h5> For an <code>Azure Event Grid</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "eventgrid",
   * 	"sink": {
   * 		"azureSubscriptionId": "string",
   * 		"azureResourceGroup": "string",
   * 		"azureRegion": "string"
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "http",
   * 	"status": "active",
   * 	"sink": {
   * 		"azureSubscriptionId": "string",
   * 		"azureResourceGroup": "string",
   * 		"azureRegion": "string",
   * 		"azurePartnerTopic": "string"
   * 	}
   * }</code></pre>
   * <h5>Datadog Stream</h5> For a <code>Datadog</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "datadog",
   * 	"sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "datadog",
   * 	"status": "active",
   * 	"sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   * 	}
   * }</code></pre>
   * <h5>Splunk Stream</h5> For a <code>Splunk</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "splunk",
   * 	"sink": {
   * 		"splunkDomain": "string",
   * 		"splunkToken": "string",
   * 		"splunkPort": "string",
   * 		"splunkSecure": "boolean"
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "splunk",
   * 	"status": "active",
   * 	"sink": {
   * 		"splunkDomain": "string",
   * 		"splunkToken": "string",
   * 		"splunkPort": "string",
   * 		"splunkSecure": "boolean"
   * 	}
   * }</code></pre>
   * <h5>Sumo Logic Stream</h5> For a <code>Sumo Logic</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "sumo",
   * 	"sink": {
   * 		"sumoSourceAddress": "string",
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "sumo",
   * 	"status": "active",
   * 	"sink": {
   * 		"sumoSourceAddress": "string",
   * 	}
   * }</code></pre>
   *
   * @param {Management.CreateLogStreamRequestContent} request
   * @param {LogStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.logStreams.create({
   *         type: "http",
   *         sink: {
   *             httpEndpoint: "httpEndpoint"
   *         }
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter75(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "log-streams"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/log-streams");
    });
  }
  /**
   * Retrieve a log stream configuration and status.
   * <h5>Sample responses</h5><h5>Amazon EventBridge Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "eventbridge",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"awsAccountId": "string",
   * 		"awsRegion": "string",
   * 		"awsPartnerEventSource": "string"
   * 	}
   * }</code></pre> <h5>HTTP Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "http",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"httpContentFormat": "JSONLINES|JSONARRAY",
   * 		"httpContentType": "string",
   * 		"httpEndpoint": "string",
   * 		"httpAuthorization": "string"
   * 	}
   * }</code></pre> <h5>Datadog Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "datadog",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   * 	}
   *
   * }</code></pre><h5>Mixpanel</h5>
   *
   * 	Request: <pre><code>{
   * 	  "name": "string",
   * 	  "type": "mixpanel",
   * 	  "sink": {
   * 		"mixpanelRegion": "string", // "us" | "eu",
   * 		"mixpanelProjectId": "string",
   * 		"mixpanelServiceAccountUsername": "string",
   * 		"mixpanelServiceAccountPassword": "string"
   * 	  }
   * 	} </code></pre>
   *
   *
   * 	Response: <pre><code>{
   * 		"id": "string",
   * 		"name": "string",
   * 		"type": "mixpanel",
   * 		"status": "active",
   * 		"sink": {
   * 		  "mixpanelRegion": "string", // "us" | "eu",
   * 		  "mixpanelProjectId": "string",
   * 		  "mixpanelServiceAccountUsername": "string",
   * 		  "mixpanelServiceAccountPassword": "string" // the following is redacted on return
   * 		}
   * 	  } </code></pre>
   *
   * 	<h5>Segment</h5>
   *
   * 	Request: <pre><code> {
   * 	  "name": "string",
   * 	  "type": "segment",
   * 	  "sink": {
   * 		"segmentWriteKey": "string"
   * 	  }
   * 	}</code></pre>
   *
   * 	Response: <pre><code>{
   * 	  "id": "string",
   * 	  "name": "string",
   * 	  "type": "segment",
   * 	  "status": "active",
   * 	  "sink": {
   * 		"segmentWriteKey": "string"
   * 	  }
   * 	} </code></pre>
   *
   * <h5>Splunk Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "splunk",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"splunkDomain": "string",
   * 		"splunkToken": "string",
   * 		"splunkPort": "string",
   * 		"splunkSecure": "boolean"
   * 	}
   * }</code></pre> <h5>Sumo Logic Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "sumo",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"sumoSourceAddress": "string",
   * 	}
   * }</code></pre> <h5>Status</h5> The <code>status</code> of a log stream maybe any of the following:
   * 1. <code>active</code> - Stream is currently enabled.
   * 2. <code>paused</code> - Stream is currently user disabled and will not attempt log delivery.
   * 3. <code>suspended</code> - Stream is currently disabled because of errors and will not attempt log delivery.
   *
   * @param {string} id - The id of the log stream to get
   * @param {LogStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.logStreams.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter75(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `log-streams/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/log-streams/{id}");
    });
  }
  /**
   * Delete a log stream.
   *
   * @param {string} id - The id of the log stream to delete
   * @param {LogStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.logStreams.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter75(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `log-streams/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/log-streams/{id}");
    });
  }
  /**
   * Update a log stream.
   * <h4>Examples of how to use the PATCH endpoint.</h4> The following fields may be updated in a PATCH operation: <ul><li>name</li><li>status</li><li>sink</li></ul> Note: For log streams of type <code>eventbridge</code> and <code>eventgrid</code>, updating the <code>sink</code> is not permitted.
   * <h5>Update the status of a log stream</h5><pre><code>{
   * 	"status": "active|paused"
   * }</code></pre>
   * <h5>Update the name of a log stream</h5><pre><code>{
   * 	"name": "string"
   * }</code></pre>
   * <h5>Update the sink properties of a stream of type <code>http</code></h5><pre><code>{
   *   "sink": {
   *     "httpEndpoint": "string",
   *     "httpContentType": "string",
   *     "httpContentFormat": "JSONARRAY|JSONLINES",
   *     "httpAuthorization": "string"
   *   }
   * }</code></pre>
   * <h5>Update the sink properties of a stream of type <code>datadog</code></h5><pre><code>{
   *   "sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   *   }
   * }</code></pre>
   * <h5>Update the sink properties of a stream of type <code>splunk</code></h5><pre><code>{
   *   "sink": {
   *     "splunkDomain": "string",
   *     "splunkToken": "string",
   *     "splunkPort": "string",
   *     "splunkSecure": "boolean"
   *   }
   * }</code></pre>
   * <h5>Update the sink properties of a stream of type <code>sumo</code></h5><pre><code>{
   *   "sink": {
   *     "sumoSourceAddress": "string"
   *   }
   * }</code></pre>
   *
   * @param {string} id - The id of the log stream to get
   * @param {Management.UpdateLogStreamRequestContent} request
   * @param {LogStreamsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.logStreams.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter75(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `log-streams/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/log-streams/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/networkAcls/client/Client.mjs
var __awaiter76 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var NetworkAclsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Get all access control list entries for your client.
   *
   * @param {Management.ListNetworkAclsRequestParameters} request
   * @param {NetworkAclsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.networkAcls.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list() {
    return __awaiter76(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter76(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, "network-acls"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/network-acls");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.network_acls) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.network_acls) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create a new access control list for your client.
   *
   * @param {Management.CreateNetworkAclRequestContent} request
   * @param {NetworkAclsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   * @throws {@link Management.InternalServerError}
   *
   * @example
   *     await client.networkAcls.create({
   *         description: "description",
   *         active: true,
   *         priority: 1.1,
   *         rule: {
   *             action: {},
   *             scope: "management"
   *         }
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter76(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "network-acls"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          case 500:
            throw new InternalServerError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/network-acls");
    });
  }
  /**
   * Get a specific access control list entry for your client.
   *
   * @param {string} id - The id of the access control list to retrieve.
   * @param {NetworkAclsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.networkAcls.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter76(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `network-acls/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/network-acls/{id}");
    });
  }
  /**
   * Update existing access control list for your client.
   *
   * @param {string} id - The id of the ACL to update.
   * @param {Management.SetNetworkAclRequestContent} request
   * @param {NetworkAclsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.networkAcls.set("id", {
   *         description: "description",
   *         active: true,
   *         priority: 1.1,
   *         rule: {
   *             action: {},
   *             scope: "management"
   *         }
   *     })
   */
  set(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(id, request, requestOptions));
  }
  __set(id, request, requestOptions) {
    return __awaiter76(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `network-acls/${url_exports.encodePathParam(id)}`),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/network-acls/{id}");
    });
  }
  /**
   * Delete existing access control list for your client.
   *
   * @param {string} id - The id of the ACL to delete
   * @param {NetworkAclsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.networkAcls.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter76(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `network-acls/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/network-acls/{id}");
    });
  }
  /**
   * Update existing access control list for your client.
   *
   * @param {string} id - The id of the ACL to update.
   * @param {Management.UpdateNetworkAclRequestContent} request
   * @param {NetworkAclsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.networkAcls.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter76(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `network-acls/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/network-acls/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/clientGrants/client/Client.mjs
var __awaiter77 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClientGrantsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * @param {string} id - Organization identifier.
   * @param {Management.ListOrganizationClientGrantsRequestParameters} request
   * @param {ClientGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.clientGrants.list("id", {
   *         audience: "audience",
   *         client_id: "client_id",
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list(id_1) {
    return __awaiter77(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter77(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { audience, client_id: clientId, grant_ids: grantIds, page = 0, per_page: perPage = 50, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (audience !== void 0) {
          _queryParams["audience"] = audience;
        }
        if (clientId !== void 0) {
          _queryParams["client_id"] = clientId;
        }
        if (grantIds !== void 0) {
          if (Array.isArray(grantIds)) {
            _queryParams["grant_ids"] = grantIds.map((item) => item);
          } else {
            _queryParams["grant_ids"] = grantIds;
          }
        }
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/client-grants`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}/client-grants");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.client_grants) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.client_grants) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * @param {string} id - Organization identifier.
   * @param {Management.AssociateOrganizationClientGrantRequestContent} request
   * @param {ClientGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.clientGrants.create("id", {
   *         grant_id: "grant_id"
   *     })
   */
  create(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id, request, requestOptions) {
    return __awaiter77(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/client-grants`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/organizations/{id}/client-grants");
    });
  }
  /**
   * @param {string} id - Organization identifier.
   * @param {string} grant_id - The Client Grant ID to remove from the organization
   * @param {ClientGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.clientGrants.delete("id", "grant_id")
   */
  delete(id, grant_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, grant_id, requestOptions));
  }
  __delete(id, grant_id, requestOptions) {
    return __awaiter77(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/client-grants/${url_exports.encodePathParam(grant_id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/organizations/{id}/client-grants/{grant_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/discoveryDomains/client/Client.mjs
var __awaiter78 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DiscoveryDomainsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve list of all organization discovery domains associated with the specified organization.
   *
   * @param {string} id - ID of the organization.
   * @param {Management.ListOrganizationDiscoveryDomainsRequestParameters} request
   * @param {DiscoveryDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.discoveryDomains.list("id", {
   *         from: "from",
   *         take: 1
   *     })
   */
  list(id_1) {
    return __awaiter78(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter78(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/discovery-domains`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}/discovery-domains");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.domains) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Update the verification status and/or use_for_organization_discovery for an organization discovery domain. The <code>status</code> field must be either <code>pending</code> or <code>verified</code>. The <code>use_for_organization_discovery</code> field can be <code>true</code> or <code>false</code> (default: <code>true</code>).
   *
   * @param {string} id - ID of the organization.
   * @param {Management.CreateOrganizationDiscoveryDomainRequestContent} request
   * @param {DiscoveryDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.discoveryDomains.create("id", {
   *         domain: "domain"
   *     })
   */
  create(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id, request, requestOptions) {
    return __awaiter78(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/discovery-domains`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/organizations/{id}/discovery-domains");
    });
  }
  /**
   * Retrieve details about a single organization discovery domain specified by ID.
   *
   * @param {string} id - ID of the organization.
   * @param {string} discovery_domain_id - ID of the discovery domain.
   * @param {DiscoveryDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.discoveryDomains.get("id", "discovery_domain_id")
   */
  get(id, discovery_domain_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, discovery_domain_id, requestOptions));
  }
  __get(id, discovery_domain_id, requestOptions) {
    return __awaiter78(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/discovery-domains/${url_exports.encodePathParam(discovery_domain_id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}/discovery-domains/{discovery_domain_id}");
    });
  }
  /**
   * Remove a discovery domain from an organization. This action cannot be undone.
   *
   * @param {string} id - ID of the organization.
   * @param {string} discovery_domain_id - ID of the discovery domain.
   * @param {DiscoveryDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.discoveryDomains.delete("id", "discovery_domain_id")
   */
  delete(id, discovery_domain_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, discovery_domain_id, requestOptions));
  }
  __delete(id, discovery_domain_id, requestOptions) {
    return __awaiter78(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/discovery-domains/${url_exports.encodePathParam(discovery_domain_id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/organizations/{id}/discovery-domains/{discovery_domain_id}");
    });
  }
  /**
   * Update the verification status and/or use_for_organization_discovery for an organization discovery domain. The <code>status</code> field must be either <code>pending</code> or <code>verified</code>. The <code>use_for_organization_discovery</code> field can be <code>true</code> or <code>false</code> (default: <code>true</code>).
   *
   * @param {string} id - ID of the organization.
   * @param {string} discovery_domain_id - ID of the discovery domain to update.
   * @param {Management.UpdateOrganizationDiscoveryDomainRequestContent} request
   * @param {DiscoveryDomainsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.organizations.discoveryDomains.update("id", "discovery_domain_id")
   */
  update(id, discovery_domain_id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, discovery_domain_id, request, requestOptions));
  }
  __update(id_1, discovery_domain_id_1) {
    return __awaiter78(this, arguments, void 0, function* (id, discovery_domain_id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/discovery-domains/${url_exports.encodePathParam(discovery_domain_id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/organizations/{id}/discovery-domains/{discovery_domain_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/enabledConnections/client/Client.mjs
var __awaiter79 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EnabledConnectionsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details about a specific connection currently enabled for an Organization. Information returned includes details such as connection ID, name, strategy, and whether the connection automatically grants membership upon login.
   *
   * @param {string} id - Organization identifier.
   * @param {Management.ListOrganizationConnectionsRequestParameters} request
   * @param {EnabledConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.enabledConnections.list("id", {
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list(id_1) {
    return __awaiter79(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter79(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/enabled_connections`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}/enabled_connections");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.enabled_connections) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.enabled_connections) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Enable a specific connection for a given Organization. To enable a connection, it must already exist within your tenant; connections cannot be created through this action.
   *
   * <a href="https://auth0.com/docs/authenticate/identity-providers">Connections</a> represent the relationship between Auth0 and a source of users. Available types of connections include database, enterprise, and social.
   *
   * @param {string} id - Organization identifier.
   * @param {Management.AddOrganizationConnectionRequestContent} request
   * @param {EnabledConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.enabledConnections.add("id", {
   *         connection_id: "connection_id"
   *     })
   */
  add(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__add(id, request, requestOptions));
  }
  __add(id, request, requestOptions) {
    return __awaiter79(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/enabled_connections`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/organizations/{id}/enabled_connections");
    });
  }
  /**
   * Retrieve details about a specific connection currently enabled for an Organization. Information returned includes details such as connection ID, name, strategy, and whether the connection automatically grants membership upon login.
   *
   * @param {string} id - Organization identifier.
   * @param {string} connectionId - Connection identifier.
   * @param {EnabledConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.enabledConnections.get("id", "connectionId")
   */
  get(id, connectionId, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, connectionId, requestOptions));
  }
  __get(id, connectionId, requestOptions) {
    return __awaiter79(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/enabled_connections/${url_exports.encodePathParam(connectionId)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}/enabled_connections/{connectionId}");
    });
  }
  /**
   * Disable a specific connection for an Organization. Once disabled, Organization members can no longer use that connection to authenticate.
   *
   * <b>Note</b>: This action does not remove the connection from your tenant.
   *
   * @param {string} id - Organization identifier.
   * @param {string} connectionId - Connection identifier.
   * @param {EnabledConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.enabledConnections.delete("id", "connectionId")
   */
  delete(id, connectionId, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, connectionId, requestOptions));
  }
  __delete(id, connectionId, requestOptions) {
    return __awaiter79(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/enabled_connections/${url_exports.encodePathParam(connectionId)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/organizations/{id}/enabled_connections/{connectionId}");
    });
  }
  /**
   * Modify the details of a specific connection currently enabled for an Organization.
   *
   * @param {string} id - Organization identifier.
   * @param {string} connectionId - Connection identifier.
   * @param {Management.UpdateOrganizationConnectionRequestContent} request
   * @param {EnabledConnectionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.enabledConnections.update("id", "connectionId")
   */
  update(id, connectionId, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, connectionId, request, requestOptions));
  }
  __update(id_1, connectionId_1) {
    return __awaiter79(this, arguments, void 0, function* (id, connectionId, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/enabled_connections/${url_exports.encodePathParam(connectionId)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/organizations/{id}/enabled_connections/{connectionId}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/invitations/client/Client.mjs
var __awaiter80 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var InvitationsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve a detailed list of invitations sent to users for a specific Organization. The list includes details such as inviter and invitee information, invitation URLs, and dates of creation and expiration. To learn more about Organization invitations, review <a href="https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members">Invite Organization Members</a>.
   *
   * @param {string} id - Organization identifier.
   * @param {Management.ListOrganizationInvitationsRequestParameters} request
   * @param {InvitationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.invitations.list("id", {
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true,
   *         fields: "fields",
   *         include_fields: true,
   *         sort: "sort"
   *     })
   */
  list(id_1) {
    return __awaiter80(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter80(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true, fields, include_fields: includeFields, sort } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_d = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _d !== void 0 ? _d : null;
        }
        if (sort !== void 0) {
          _queryParams["sort"] = sort;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_e = this._options) === null || _e === void 0 ? void 0 : _e.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_f = this._options.fetcher) !== null && _f !== void 0 ? _f : fetcher)({
          url: url_exports.join((_h = (_g = yield Supplier.get(this._options.baseUrl)) !== null && _g !== void 0 ? _g : yield Supplier.get(this._options.environment)) !== null && _h !== void 0 ? _h : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/invitations`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_l = (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.timeoutInSeconds) !== null && _l !== void 0 ? _l : 60) * 1e3,
          maxRetries: (_m = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _m !== void 0 ? _m : (_o = this._options) === null || _o === void 0 ? void 0 : _o.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_p = this._options) === null || _p === void 0 ? void 0 : _p.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}/invitations");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.invitations) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.invitations) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create a user invitation for a specific Organization. Upon creation, the listed user receives an email inviting them to join the Organization. To learn more about Organization invitations, review <a href="https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members">Invite Organization Members</a>.
   *
   * @param {string} id - Organization identifier.
   * @param {Management.CreateOrganizationInvitationRequestContent} request
   * @param {InvitationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.invitations.create("id", {
   *         inviter: {
   *             name: "name"
   *         },
   *         invitee: {
   *             email: "email"
   *         },
   *         client_id: "client_id"
   *     })
   */
  create(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id, request, requestOptions) {
    return __awaiter80(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/invitations`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/organizations/{id}/invitations");
    });
  }
  /**
   * @param {string} id - Organization identifier.
   * @param {string} invitation_id - The id of the user invitation.
   * @param {Management.GetOrganizationInvitationRequestParameters} request
   * @param {InvitationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.invitations.get("id", "invitation_id", {
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  get(id, invitation_id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, invitation_id, request, requestOptions));
  }
  __get(id_1, invitation_id_1) {
    return __awaiter80(this, arguments, void 0, function* (id, invitation_id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { fields, include_fields: includeFields } = request;
      const _queryParams = {};
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/invitations/${url_exports.encodePathParam(invitation_id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}/invitations/{invitation_id}");
    });
  }
  /**
   * @param {string} id - Organization identifier.
   * @param {string} invitation_id - The id of the user invitation.
   * @param {InvitationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.invitations.delete("id", "invitation_id")
   */
  delete(id, invitation_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, invitation_id, requestOptions));
  }
  __delete(id, invitation_id, requestOptions) {
    return __awaiter80(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/invitations/${url_exports.encodePathParam(invitation_id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/organizations/{id}/invitations/{invitation_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/members/resources/roles/client/Client.mjs
var __awaiter81 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RolesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve detailed list of roles assigned to a given user within the context of a specific Organization.
   *
   * Users can be members of multiple Organizations with unique roles assigned for each membership. This action only returns the roles associated with the specified Organization; any roles assigned to the user within other Organizations are not included.
   *
   * @param {string} id - Organization identifier.
   * @param {string} user_id - ID of the user to associate roles with.
   * @param {Management.ListOrganizationMemberRolesRequestParameters} request
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.members.roles.list("id", "user_id", {
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list(id_1, user_id_1) {
    return __awaiter81(this, arguments, void 0, function* (id, user_id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter81(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/members/${url_exports.encodePathParam(user_id)}/roles`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}/members/{user_id}/roles");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.roles) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.roles) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Assign one or more <a href="https://auth0.com/docs/manage-users/access-control/rbac">roles</a> to a user to determine their access for a specific Organization.
   *
   * Users can be members of multiple Organizations with unique roles assigned for each membership. This action assigns roles to a user only for the specified Organization. Roles cannot be assigned to a user across multiple Organizations in the same call.
   *
   * @param {string} id - Organization identifier.
   * @param {string} user_id - ID of the user to associate roles with.
   * @param {Management.AssignOrganizationMemberRolesRequestContent} request
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.members.roles.assign("id", "user_id", {
   *         roles: ["roles"]
   *     })
   */
  assign(id, user_id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__assign(id, user_id, request, requestOptions));
  }
  __assign(id, user_id, request, requestOptions) {
    return __awaiter81(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/members/${url_exports.encodePathParam(user_id)}/roles`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/organizations/{id}/members/{user_id}/roles");
    });
  }
  /**
   * Remove one or more Organization-specific <a href="https://auth0.com/docs/manage-users/access-control/rbac">roles</a> from a given user.
   *
   * Users can be members of multiple Organizations with unique roles assigned for each membership. This action removes roles from a user in relation to the specified Organization. Roles assigned to the user within a different Organization cannot be managed in the same call.
   *
   * @param {string} id - Organization identifier.
   * @param {string} user_id - User ID of the organization member to remove roles from.
   * @param {Management.DeleteOrganizationMemberRolesRequestContent} request
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.members.roles.delete("id", "user_id", {
   *         roles: ["roles"]
   *     })
   */
  delete(id, user_id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, user_id, request, requestOptions));
  }
  __delete(id, user_id, request, requestOptions) {
    return __awaiter81(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/members/${url_exports.encodePathParam(user_id)}/roles`),
        method: "DELETE",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/organizations/{id}/members/{user_id}/roles");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/resources/members/client/Client.mjs
var __awaiter82 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MembersClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get roles() {
    var _a;
    return (_a = this._roles) !== null && _a !== void 0 ? _a : this._roles = new RolesClient(this._options);
  }
  /**
   * List organization members.
   * This endpoint is subject to eventual consistency. New users may not be immediately included in the response and deleted users may not be immediately removed from it.
   *
   * <ul>
   *   <li>
   *     Use the <code>fields</code> parameter to optionally define the specific member details retrieved. If <code>fields</code> is left blank, all fields (except roles) are returned.
   *   </li>
   *   <li>
   *     Member roles are not sent by default. Use <code>fields=roles</code> to retrieve the roles assigned to each listed member. To use this parameter, you must include the <code>read:organization_member_roles</code> scope in the token.
   *   </li>
   * </ul>
   *
   * This endpoint supports two types of pagination:
   *
   * - Offset pagination
   * - Checkpoint pagination
   *
   * Checkpoint pagination must be used if you need to retrieve more than 1000 organization members.
   *
   * <h2>Checkpoint Pagination</h2>
   *
   * To search by checkpoint, use the following parameters: - from: Optional id from which to start selection. - take: The total amount of entries to retrieve when using the from parameter. Defaults to 50. Note: The first time you call this endpoint using Checkpoint Pagination, you should omit the <code>from</code> parameter. If there are more results, a <code>next</code> value will be included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, this indicates there are no more pages remaining.
   *
   * @param {string} id - Organization identifier.
   * @param {Management.ListOrganizationMembersRequestParameters} request
   * @param {MembersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.members.list("id", {
   *         from: "from",
   *         take: 1,
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  list(id_1) {
    return __awaiter82(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter82(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const { from: from_, take = 50, fields, include_fields: includeFields } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_b = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _b !== void 0 ? _b : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_c = this._options) === null || _c === void 0 ? void 0 : _c.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_d = this._options.fetcher) !== null && _d !== void 0 ? _d : fetcher)({
          url: url_exports.join((_f = (_e = yield Supplier.get(this._options.baseUrl)) !== null && _e !== void 0 ? _e : yield Supplier.get(this._options.environment)) !== null && _f !== void 0 ? _f : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/members`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_j = (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.timeoutInSeconds) !== null && _j !== void 0 ? _j : 60) * 1e3,
          maxRetries: (_k = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _k !== void 0 ? _k : (_l = this._options) === null || _l === void 0 ? void 0 : _l.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_m = this._options) === null || _m === void 0 ? void 0 : _m.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}/members");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.members) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Set one or more existing users as members of a specific <a href="https://auth0.com/docs/manage-users/organizations">Organization</a>.
   *
   * To add a user to an Organization through this action, the user must already exist in your tenant. If a user does not yet exist, you can <a href="https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members">invite them to create an account</a>, manually create them through the Auth0 Dashboard, or use the Management API.
   *
   * @param {string} id - Organization identifier.
   * @param {Management.CreateOrganizationMemberRequestContent} request
   * @param {MembersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.members.create("id", {
   *         members: ["members"]
   *     })
   */
  create(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id, request, requestOptions) {
    return __awaiter82(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/members`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/organizations/{id}/members");
    });
  }
  /**
   * @param {string} id - Organization identifier.
   * @param {Management.DeleteOrganizationMembersRequestContent} request
   * @param {MembersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.members.delete("id", {
   *         members: ["members"]
   *     })
   */
  delete(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, request, requestOptions));
  }
  __delete(id, request, requestOptions) {
    return __awaiter82(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}/members`),
        method: "DELETE",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/organizations/{id}/members");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/organizations/client/Client.mjs
var __awaiter83 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OrganizationsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get clientGrants() {
    var _a;
    return (_a = this._clientGrants) !== null && _a !== void 0 ? _a : this._clientGrants = new ClientGrantsClient2(this._options);
  }
  get discoveryDomains() {
    var _a;
    return (_a = this._discoveryDomains) !== null && _a !== void 0 ? _a : this._discoveryDomains = new DiscoveryDomainsClient(this._options);
  }
  get enabledConnections() {
    var _a;
    return (_a = this._enabledConnections) !== null && _a !== void 0 ? _a : this._enabledConnections = new EnabledConnectionsClient(this._options);
  }
  get invitations() {
    var _a;
    return (_a = this._invitations) !== null && _a !== void 0 ? _a : this._invitations = new InvitationsClient(this._options);
  }
  get members() {
    var _a;
    return (_a = this._members) !== null && _a !== void 0 ? _a : this._members = new MembersClient(this._options);
  }
  /**
   * Retrieve detailed list of all Organizations available in your tenant. For more information, see Auth0 Organizations.
   *
   * This endpoint supports two types of pagination:
   * <ul>
   * <li>Offset pagination</li>
   * <li>Checkpoint pagination</li>
   * </ul>
   *
   * Checkpoint pagination must be used if you need to retrieve more than 1000 organizations.
   *
   * <h2>Checkpoint Pagination</h2>
   *
   * To search by checkpoint, use the following parameters:
   * <ul>
   * <li><code>from</code>: Optional id from which to start selection.</li>
   * <li><code>take</code>: The total number of entries to retrieve when using the <code>from</code> parameter. Defaults to 50.</li>
   * </ul>
   *
   * <b>Note</b>: The first time you call this endpoint using checkpoint pagination, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no pages are remaining.
   *
   * @param {Management.ListOrganizationsRequestParameters} request
   * @param {OrganizationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.list({
   *         from: "from",
   *         take: 1,
   *         sort: "sort"
   *     })
   */
  list() {
    return __awaiter83(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter83(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50, sort } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (sort !== void 0) {
          _queryParams["sort"] = sort;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "organizations"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.organizations) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Create a new Organization within your tenant.  To learn more about Organization settings, behavior, and configuration options, review <a href="https://auth0.com/docs/manage-users/organizations/create-first-organization">Create Your First Organization</a>.
   *
   * @param {Management.CreateOrganizationRequestContent} request
   * @param {OrganizationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.create({
   *         name: "name"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter83(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "organizations"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/organizations");
    });
  }
  /**
   * Retrieve details about a single Organization specified by name.
   *
   * @param {string} name - name of the organization to retrieve.
   * @param {OrganizationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.getByName("name")
   */
  getByName(name, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getByName(name, requestOptions));
  }
  __getByName(name, requestOptions) {
    return __awaiter83(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/name/${url_exports.encodePathParam(name)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/name/{name}");
    });
  }
  /**
   * Retrieve details about a single Organization specified by ID.
   *
   * @param {string} id - ID of the organization to retrieve.
   * @param {OrganizationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter83(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/organizations/{id}");
    });
  }
  /**
   * Remove an Organization from your tenant.  This action cannot be undone.
   *
   * <b>Note</b>: Members are automatically disassociated from an Organization when it is deleted. However, this action does <b>not</b> delete these users from your tenant.
   *
   * @param {string} id - Organization identifier.
   * @param {OrganizationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter83(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/organizations/{id}");
    });
  }
  /**
   * Update the details of a specific <a href="https://auth0.com/docs/manage-users/organizations/configure-organizations/create-organizations">Organization</a>, such as name and display name, branding options, and metadata.
   *
   * @param {string} id - ID of the organization to update.
   * @param {Management.UpdateOrganizationRequestContent} request
   * @param {OrganizationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.organizations.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter83(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `organizations/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/organizations/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/prompts/resources/customText/client/Client.mjs
var __awaiter84 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CustomTextClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve custom text for a specific prompt and language.
   *
   * @param {Management.PromptGroupNameEnum} prompt - Name of the prompt.
   * @param {Management.PromptLanguageEnum} language - Language to update.
   * @param {CustomTextClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.customText.get("login", "am")
   */
  get(prompt, language, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(prompt, language, requestOptions));
  }
  __get(prompt, language, requestOptions) {
    return __awaiter84(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `prompts/${url_exports.encodePathParam(prompt)}/custom-text/${url_exports.encodePathParam(language)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/prompts/{prompt}/custom-text/{language}");
    });
  }
  /**
   * Set custom text for a specific prompt. Existing texts will be overwritten.
   *
   * @param {Management.PromptGroupNameEnum} prompt - Name of the prompt.
   * @param {Management.PromptLanguageEnum} language - Language to update.
   * @param {Management.SetsCustomTextsByLanguageRequestContent} request
   * @param {CustomTextClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.customText.set("login", "am", {
   *         "key": "value"
   *     })
   */
  set(prompt, language, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(prompt, language, request, requestOptions));
  }
  __set(prompt, language, request, requestOptions) {
    return __awaiter84(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `prompts/${url_exports.encodePathParam(prompt)}/custom-text/${url_exports.encodePathParam(language)}`),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/prompts/{prompt}/custom-text/{language}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/prompts/resources/partials/client/Client.mjs
var __awaiter85 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PartialsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Get template partials for a prompt
   *
   * @param {Management.PartialGroupsEnum} prompt - Name of the prompt.
   * @param {PartialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.partials.get("login")
   */
  get(prompt, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(prompt, requestOptions));
  }
  __get(prompt, requestOptions) {
    return __awaiter85(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `prompts/${url_exports.encodePathParam(prompt)}/partials`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/prompts/{prompt}/partials");
    });
  }
  /**
   * Set template partials for a prompt
   *
   * @param {Management.PartialGroupsEnum} prompt - Name of the prompt.
   * @param {Management.SetPartialsRequestContent} request
   * @param {PartialsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.partials.set("login", {
   *         "key": "value"
   *     })
   */
  set(prompt, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(prompt, request, requestOptions));
  }
  __set(prompt, request, requestOptions) {
    return __awaiter85(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `prompts/${url_exports.encodePathParam(prompt)}/partials`),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/prompts/{prompt}/partials");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/prompts/resources/rendering/client/Client.mjs
var __awaiter86 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RenderingClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Get render setting configurations for all screens.
   *
   * @param {Management.ListAculsRequestParameters} request
   * @param {RenderingClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.PaymentRequiredError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.rendering.list({
   *         fields: "fields",
   *         include_fields: true,
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true,
   *         prompt: "prompt",
   *         screen: "screen",
   *         rendering_mode: "advanced"
   *     })
   */
  list() {
    return __awaiter86(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter86(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const { fields, include_fields: includeFields, page = 0, per_page: perPage = 50, include_totals: includeTotals = true, prompt, screen, rendering_mode: renderingMode } = request2;
        const _queryParams = {};
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (page !== void 0) {
          _queryParams["page"] = (_b = page === null || page === void 0 ? void 0 : page.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_c = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_d = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _d !== void 0 ? _d : null;
        }
        if (prompt !== void 0) {
          _queryParams["prompt"] = prompt;
        }
        if (screen !== void 0) {
          _queryParams["screen"] = screen;
        }
        if (renderingMode !== void 0) {
          _queryParams["rendering_mode"] = renderingMode;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_e = this._options) === null || _e === void 0 ? void 0 : _e.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_f = this._options.fetcher) !== null && _f !== void 0 ? _f : fetcher)({
          url: url_exports.join((_h = (_g = yield Supplier.get(this._options.baseUrl)) !== null && _g !== void 0 ? _g : yield Supplier.get(this._options.environment)) !== null && _h !== void 0 ? _h : ManagementEnvironment.Default, "prompts/rendering"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_l = (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.timeoutInSeconds) !== null && _l !== void 0 ? _l : 60) * 1e3,
          maxRetries: (_m = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _m !== void 0 ? _m : (_o = this._options) === null || _o === void 0 ? void 0 : _o.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_p = this._options) === null || _p === void 0 ? void 0 : _p.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 402:
              throw new PaymentRequiredError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/prompts/rendering");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.configs) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.configs) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Learn more about <a href='https://auth0.com/docs/customize/login-pages/advanced-customizations/getting-started/configure-acul-screens'>configuring render settings</a> for advanced customization.
   *
   * @param {Management.BulkUpdateAculRequestContent} request
   * @param {RenderingClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.PaymentRequiredError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.rendering.bulkUpdate({
   *         configs: [{
   *                 prompt: "login",
   *                 screen: "login"
   *             }]
   *     })
   */
  bulkUpdate(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__bulkUpdate(request, requestOptions));
  }
  __bulkUpdate(request, requestOptions) {
    return __awaiter86(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "prompts/rendering"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 402:
            throw new PaymentRequiredError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/prompts/rendering");
    });
  }
  /**
   * Get render settings for a screen.
   *
   * @param {Management.PromptGroupNameEnum} prompt - Name of the prompt
   * @param {Management.ScreenGroupNameEnum} screen - Name of the screen
   * @param {RenderingClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.PaymentRequiredError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.rendering.get("login", "login")
   */
  get(prompt, screen, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(prompt, screen, requestOptions));
  }
  __get(prompt, screen, requestOptions) {
    return __awaiter86(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `prompts/${url_exports.encodePathParam(prompt)}/screen/${url_exports.encodePathParam(screen)}/rendering`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 402:
            throw new PaymentRequiredError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/prompts/{prompt}/screen/{screen}/rendering");
    });
  }
  /**
   * Learn more about <a href='https://auth0.com/docs/customize/login-pages/advanced-customizations/getting-started/configure-acul-screens'>configuring render settings</a> for advanced customization.
   *
   * @param {Management.PromptGroupNameEnum} prompt - Name of the prompt
   * @param {Management.ScreenGroupNameEnum} screen - Name of the screen
   * @param {Management.UpdateAculRequestContent} request
   * @param {RenderingClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.PaymentRequiredError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.rendering.update("login", "login")
   */
  update(prompt, screen, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(prompt, screen, request, requestOptions));
  }
  __update(prompt_1, screen_1) {
    return __awaiter86(this, arguments, void 0, function* (prompt, screen, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `prompts/${url_exports.encodePathParam(prompt)}/screen/${url_exports.encodePathParam(screen)}/rendering`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 402:
            throw new PaymentRequiredError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/prompts/{prompt}/screen/{screen}/rendering");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/prompts/client/Client.mjs
var __awaiter87 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PromptsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get rendering() {
    var _a;
    return (_a = this._rendering) !== null && _a !== void 0 ? _a : this._rendering = new RenderingClient(this._options);
  }
  get customText() {
    var _a;
    return (_a = this._customText) !== null && _a !== void 0 ? _a : this._customText = new CustomTextClient(this._options);
  }
  get partials() {
    var _a;
    return (_a = this._partials) !== null && _a !== void 0 ? _a : this._partials = new PartialsClient(this._options);
  }
  /**
   * Retrieve details of the Universal Login configuration of your tenant. This includes the <a href="https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first">Identifier First Authentication</a> and <a href="https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa">WebAuthn with Device Biometrics for MFA</a> features.
   *
   * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.getSettings()
   */
  getSettings(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getSettings(requestOptions));
  }
  __getSettings(requestOptions) {
    return __awaiter87(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "prompts"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/prompts");
    });
  }
  /**
   * Update the Universal Login configuration of your tenant. This includes the <a href="https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first">Identifier First Authentication</a> and <a href="https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa">WebAuthn with Device Biometrics for MFA</a> features.
   *
   * @param {Management.UpdateSettingsRequestContent} request
   * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.prompts.updateSettings()
   */
  updateSettings(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__updateSettings(request, requestOptions));
  }
  __updateSettings() {
    return __awaiter87(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "prompts"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/prompts");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/refreshTokens/client/Client.mjs
var __awaiter88 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RefreshTokensClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve refresh token information.
   *
   * @param {string} id - ID refresh token to retrieve
   * @param {RefreshTokensClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.refreshTokens.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter88(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `refresh-tokens/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/refresh-tokens/{id}");
    });
  }
  /**
   * Delete a refresh token by its ID.
   *
   * @param {string} id - ID of the refresh token to delete.
   * @param {RefreshTokensClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.refreshTokens.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter88(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `refresh-tokens/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/refresh-tokens/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/resourceServers/client/Client.mjs
var __awaiter89 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ResourceServersClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details of all APIs associated with your tenant.
   *
   * @param {Management.ListResourceServerRequestParameters} request
   * @param {ResourceServersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.resourceServers.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true,
   *         include_fields: true
   *     })
   */
  list() {
    return __awaiter89(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter89(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const { identifiers, page = 0, per_page: perPage = 50, include_totals: includeTotals = true, include_fields: includeFields } = request2;
        const _queryParams = {};
        if (identifiers !== void 0) {
          if (Array.isArray(identifiers)) {
            _queryParams["identifiers"] = identifiers.map((item) => item);
          } else {
            _queryParams["identifiers"] = identifiers;
          }
        }
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_d = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _d !== void 0 ? _d : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_e = this._options) === null || _e === void 0 ? void 0 : _e.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_f = this._options.fetcher) !== null && _f !== void 0 ? _f : fetcher)({
          url: url_exports.join((_h = (_g = yield Supplier.get(this._options.baseUrl)) !== null && _g !== void 0 ? _g : yield Supplier.get(this._options.environment)) !== null && _h !== void 0 ? _h : ManagementEnvironment.Default, "resource-servers"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_l = (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.timeoutInSeconds) !== null && _l !== void 0 ? _l : 60) * 1e3,
          maxRetries: (_m = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _m !== void 0 ? _m : (_o = this._options) === null || _o === void 0 ? void 0 : _o.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_p = this._options) === null || _p === void 0 ? void 0 : _p.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/resource-servers");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.resource_servers) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.resource_servers) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create a new API associated with your tenant. Note that all new APIs must be registered with Auth0. For more information, read <a href="https://www.auth0.com/docs/get-started/apis"> APIs</a>.
   *
   * @param {Management.CreateResourceServerRequestContent} request
   * @param {ResourceServersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.resourceServers.create({
   *         identifier: "identifier"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter89(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "resource-servers"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/resource-servers");
    });
  }
  /**
   * Retrieve <a href="https://auth0.com/docs/apis">API</a> details with the given ID.
   *
   * @param {string} id - ID or audience of the resource server to retrieve.
   * @param {Management.GetResourceServerRequestParameters} request
   * @param {ResourceServersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.resourceServers.get("id", {
   *         include_fields: true
   *     })
   */
  get(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
  }
  __get(id_1) {
    return __awaiter89(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { include_fields: includeFields } = request;
      const _queryParams = {};
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `resource-servers/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/resource-servers/{id}");
    });
  }
  /**
   * Delete an existing API by ID. For more information, read <a href="https://www.auth0.com/docs/get-started/apis/api-settings">API Settings</a>.
   *
   * @param {string} id - ID or the audience of the resource server to delete.
   * @param {ResourceServersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.resourceServers.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter89(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `resource-servers/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/resource-servers/{id}");
    });
  }
  /**
   * Change an existing API setting by resource server ID. For more information, read <a href="https://www.auth0.com/docs/get-started/apis/api-settings">API Settings</a>.
   *
   * @param {string} id - ID or audience of the resource server to update.
   * @param {Management.UpdateResourceServerRequestContent} request
   * @param {ResourceServersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.resourceServers.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter89(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `resource-servers/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/resource-servers/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/riskAssessments/resources/settings/resources/newDevice/client/Client.mjs
var __awaiter90 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var NewDeviceClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Gets the risk assessment settings for the new device assessor
   *
   * @param {NewDeviceClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.riskAssessments.settings.newDevice.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter90(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "risk-assessments/settings/new-device"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/risk-assessments/settings/new-device");
    });
  }
  /**
   * Updates the risk assessment settings for the new device assessor
   *
   * @param {Management.UpdateRiskAssessmentsSettingsNewDeviceRequestContent} request
   * @param {NewDeviceClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.riskAssessments.settings.newDevice.update({
   *         remember_for: 1
   *     })
   */
  update(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update(request, requestOptions) {
    return __awaiter90(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "risk-assessments/settings/new-device"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/risk-assessments/settings/new-device");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/riskAssessments/resources/settings/client/Client.mjs
var __awaiter91 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SettingsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get newDevice() {
    var _a;
    return (_a = this._newDevice) !== null && _a !== void 0 ? _a : this._newDevice = new NewDeviceClient(this._options);
  }
  /**
   * Gets the tenant settings for risk assessments
   *
   * @param {SettingsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.riskAssessments.settings.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter91(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "risk-assessments/settings"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/risk-assessments/settings");
    });
  }
  /**
   * Updates the tenant settings for risk assessments
   *
   * @param {Management.UpdateRiskAssessmentsSettingsRequestContent} request
   * @param {SettingsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.riskAssessments.settings.update({
   *         enabled: true
   *     })
   */
  update(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update(request, requestOptions) {
    return __awaiter91(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "risk-assessments/settings"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/risk-assessments/settings");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/riskAssessments/client/Client.mjs
var RiskAssessmentsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get settings() {
    var _a;
    return (_a = this._settings) !== null && _a !== void 0 ? _a : this._settings = new SettingsClient2(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/roles/resources/permissions/client/Client.mjs
var __awaiter92 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PermissionsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve detailed list (name, description, resource server) of permissions granted by a specified user role.
   *
   * @param {string} id - ID of the role to list granted permissions.
   * @param {Management.ListRolePermissionsRequestParameters} request
   * @param {PermissionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.permissions.list("id", {
   *         per_page: 1,
   *         page: 1,
   *         include_totals: true
   *     })
   */
  list(id_1) {
    return __awaiter92(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter92(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { per_page: perPage = 50, page = 0, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_a = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (page !== void 0) {
          _queryParams["page"] = (_b = page === null || page === void 0 ? void 0 : page.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, `roles/${url_exports.encodePathParam(id)}/permissions`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/roles/{id}/permissions");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.permissions) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.permissions) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Add one or more <a href="https://auth0.com/docs/manage-users/access-control/configure-core-rbac/manage-permissions">permissions</a> to a specified user role.
   *
   * @param {string} id - ID of the role to add permissions to.
   * @param {Management.AddRolePermissionsRequestContent} request
   * @param {PermissionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.permissions.add("id", {
   *         permissions: [{
   *                 resource_server_identifier: "resource_server_identifier",
   *                 permission_name: "permission_name"
   *             }]
   *     })
   */
  add(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__add(id, request, requestOptions));
  }
  __add(id, request, requestOptions) {
    return __awaiter92(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `roles/${url_exports.encodePathParam(id)}/permissions`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/roles/{id}/permissions");
    });
  }
  /**
   * Remove one or more <a href="https://auth0.com/docs/manage-users/access-control/configure-core-rbac/manage-permissions">permissions</a> from a specified user role.
   *
   * @param {string} id - ID of the role to remove permissions from.
   * @param {Management.DeleteRolePermissionsRequestContent} request
   * @param {PermissionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.permissions.delete("id", {
   *         permissions: [{
   *                 resource_server_identifier: "resource_server_identifier",
   *                 permission_name: "permission_name"
   *             }]
   *     })
   */
  delete(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, request, requestOptions));
  }
  __delete(id, request, requestOptions) {
    return __awaiter92(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `roles/${url_exports.encodePathParam(id)}/permissions`),
        method: "DELETE",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/roles/{id}/permissions");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/roles/resources/users/client/Client.mjs
var __awaiter93 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UsersClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve list of users associated with a specific role. For Dashboard instructions, review <a href="https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/view-users-assigned-to-roles">View Users Assigned to Roles</a>.
   *
   * This endpoint supports two types of pagination:
   * <ul>
   * <li>Offset pagination</li>
   * <li>Checkpoint pagination</li>
   * </ul>
   *
   * Checkpoint pagination must be used if you need to retrieve more than 1000 organization members.
   *
   * <h2>Checkpoint Pagination</h2>
   *
   * To search by checkpoint, use the following parameters:
   * <ul>
   * <li><code>from</code>: Optional id from which to start selection.</li>
   * <li><code>take</code>: The total amount of entries to retrieve when using the from parameter. Defaults to 50.</li>
   * </ul>
   *
   * <b>Note</b>: The first time you call this endpoint using checkpoint pagination, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no pages are remaining.
   *
   * @param {string} id - ID of the role to retrieve a list of users associated with.
   * @param {Management.ListRoleUsersRequestParameters} request
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.users.list("id", {
   *         from: "from",
   *         take: 1
   *     })
   */
  list(id_1) {
    return __awaiter93(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter93(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `roles/${url_exports.encodePathParam(id)}/users`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/roles/{id}/users");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.users) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Assign one or more users to an existing user role. To learn more, review <a href="https://auth0.com/docs/manage-users/access-control/rbac">Role-Based Access Control</a>.
   *
   * <b>Note</b>: New roles cannot be created through this action.
   *
   * @param {string} id - ID of the role to assign users to.
   * @param {Management.AssignRoleUsersRequestContent} request
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.users.assign("id", {
   *         users: ["users"]
   *     })
   */
  assign(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__assign(id, request, requestOptions));
  }
  __assign(id, request, requestOptions) {
    return __awaiter93(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `roles/${url_exports.encodePathParam(id)}/users`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/roles/{id}/users");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/roles/client/Client.mjs
var __awaiter94 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RolesClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get permissions() {
    var _a;
    return (_a = this._permissions) !== null && _a !== void 0 ? _a : this._permissions = new PermissionsClient(this._options);
  }
  get users() {
    var _a;
    return (_a = this._users) !== null && _a !== void 0 ? _a : this._users = new UsersClient2(this._options);
  }
  /**
   * Retrieve detailed list of user roles created in your tenant.
   *
   * <b>Note</b>: The returned list does not include standard roles available for tenant members, such as Admin or Support Access.
   *
   * @param {Management.ListRolesRequestParameters} request
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.list({
   *         per_page: 1,
   *         page: 1,
   *         include_totals: true,
   *         name_filter: "name_filter"
   *     })
   */
  list() {
    return __awaiter94(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter94(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { per_page: perPage = 50, page = 0, include_totals: includeTotals = true, name_filter: nameFilter } = request2;
        const _queryParams = {};
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_a = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (page !== void 0) {
          _queryParams["page"] = (_b = page === null || page === void 0 ? void 0 : page.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (nameFilter !== void 0) {
          _queryParams["name_filter"] = nameFilter;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, "roles"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/roles");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.roles) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.roles) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create a user role for <a href="https://auth0.com/docs/manage-users/access-control/rbac">Role-Based Access Control</a>.
   *
   * <b>Note</b>: New roles are not associated with any permissions by default. To assign existing permissions to your role, review Associate Permissions with a Role. To create new permissions, review Add API Permissions.
   *
   * @param {Management.CreateRoleRequestContent} request
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.create({
   *         name: "name"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter94(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "roles"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/roles");
    });
  }
  /**
   * Retrieve details about a specific <a href="https://auth0.com/docs/manage-users/access-control/rbac">user role</a> specified by ID.
   *
   * @param {string} id - ID of the role to retrieve.
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter94(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `roles/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/roles/{id}");
    });
  }
  /**
   * Delete a specific <a href="https://auth0.com/docs/manage-users/access-control/rbac">user role</a> from your tenant. Once deleted, it is removed from any user who was previously assigned that role. This action cannot be undone.
   *
   * @param {string} id - ID of the role to delete.
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter94(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `roles/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/roles/{id}");
    });
  }
  /**
   * Modify the details of a specific <a href="https://auth0.com/docs/manage-users/access-control/rbac">user role</a> specified by ID.
   *
   * @param {string} id - ID of the role to update.
   * @param {Management.UpdateRoleRequestContent} request
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.roles.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter94(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `roles/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/roles/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/rules/client/Client.mjs
var __awaiter95 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RulesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve a filtered list of <a href="https://auth0.com/docs/rules">rules</a>. Accepts a list of fields to include or exclude.
   *
   * @param {Management.ListRulesRequestParameters} request
   * @param {RulesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.rules.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true,
   *         enabled: true,
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  list() {
    return __awaiter95(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter95(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true, enabled, fields, include_fields: includeFields } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (enabled !== void 0) {
          _queryParams["enabled"] = (_d = enabled === null || enabled === void 0 ? void 0 : enabled.toString()) !== null && _d !== void 0 ? _d : null;
        }
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_e = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _e !== void 0 ? _e : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_f = this._options) === null || _f === void 0 ? void 0 : _f.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_g = this._options.fetcher) !== null && _g !== void 0 ? _g : fetcher)({
          url: url_exports.join((_j = (_h = yield Supplier.get(this._options.baseUrl)) !== null && _h !== void 0 ? _h : yield Supplier.get(this._options.environment)) !== null && _j !== void 0 ? _j : ManagementEnvironment.Default, "rules"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_m = (_k = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _k !== void 0 ? _k : (_l = this._options) === null || _l === void 0 ? void 0 : _l.timeoutInSeconds) !== null && _m !== void 0 ? _m : 60) * 1e3,
          maxRetries: (_o = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _o !== void 0 ? _o : (_p = this._options) === null || _p === void 0 ? void 0 : _p.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_q = this._options) === null || _q === void 0 ? void 0 : _q.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/rules");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.rules) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.rules) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create a <a href="https://auth0.com/docs/rules#create-a-new-rule-using-the-management-api">new rule</a>.
   *
   * Note: Changing a rule's stage of execution from the default <code>login_success</code> can change the rule's function signature to have user omitted.
   *
   * @param {Management.CreateRuleRequestContent} request
   * @param {RulesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.rules.create({
   *         name: "name",
   *         script: "script"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter95(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "rules"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/rules");
    });
  }
  /**
   * Retrieve <a href="https://auth0.com/docs/rules">rule</a> details. Accepts a list of fields to include or exclude in the result.
   *
   * @param {string} id - ID of the rule to retrieve.
   * @param {Management.GetRuleRequestParameters} request
   * @param {RulesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.rules.get("id", {
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  get(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
  }
  __get(id_1) {
    return __awaiter95(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { fields, include_fields: includeFields } = request;
      const _queryParams = {};
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `rules/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/rules/{id}");
    });
  }
  /**
   * Delete a rule.
   *
   * @param {string} id - ID of the rule to delete.
   * @param {RulesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.rules.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter95(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `rules/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/rules/{id}");
    });
  }
  /**
   * Update an existing rule.
   *
   * @param {string} id - ID of the rule to retrieve.
   * @param {Management.UpdateRuleRequestContent} request
   * @param {RulesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.rules.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter95(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `rules/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/rules/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/rulesConfigs/client/Client.mjs
var __awaiter96 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RulesConfigsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve rules config variable keys.
   *
   *     Note: For security, config variable values cannot be retrieved outside rule execution.
   *
   * @param {RulesConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.rulesConfigs.list()
   */
  list(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(requestOptions));
  }
  __list(requestOptions) {
    return __awaiter96(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "rules-configs"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/rules-configs");
    });
  }
  /**
   * Sets a rules config variable.
   *
   * @param {string} key - Key of the rules config variable to set (max length: 127 characters).
   * @param {Management.SetRulesConfigRequestContent} request
   * @param {RulesConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.rulesConfigs.set("key", {
   *         value: "value"
   *     })
   */
  set(key, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(key, request, requestOptions));
  }
  __set(key, request, requestOptions) {
    return __awaiter96(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `rules-configs/${url_exports.encodePathParam(key)}`),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/rules-configs/{key}");
    });
  }
  /**
   * Delete a rules config variable identified by its key.
   *
   * @param {string} key - Key of the rules config variable to delete.
   * @param {RulesConfigsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.rulesConfigs.delete("key")
   */
  delete(key, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(key, requestOptions));
  }
  __delete(key, requestOptions) {
    return __awaiter96(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `rules-configs/${url_exports.encodePathParam(key)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/rules-configs/{key}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/selfServiceProfiles/resources/customText/client/Client.mjs
var __awaiter97 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CustomTextClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieves text customizations for a given self-service profile, language and Self Service SSO Flow page.
   *
   * @param {string} id - The id of the self-service profile.
   * @param {Management.SelfServiceProfileCustomTextLanguageEnum} language - The language of the custom text.
   * @param {Management.SelfServiceProfileCustomTextPageEnum} page - The page where the custom text is shown.
   * @param {CustomTextClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.selfServiceProfiles.customText.list("id", "en", "get-started")
   */
  list(id, language, page, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(id, language, page, requestOptions));
  }
  __list(id, language, page, requestOptions) {
    return __awaiter97(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `self-service-profiles/${url_exports.encodePathParam(id)}/custom-text/${url_exports.encodePathParam(language)}/${url_exports.encodePathParam(page)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/self-service-profiles/{id}/custom-text/{language}/{page}");
    });
  }
  /**
   * Updates text customizations for a given self-service profile, language and Self Service SSO Flow page.
   *
   * @param {string} id - The id of the self-service profile.
   * @param {Management.SelfServiceProfileCustomTextLanguageEnum} language - The language of the custom text.
   * @param {Management.SelfServiceProfileCustomTextPageEnum} page - The page where the custom text is shown.
   * @param {Management.SetSelfServiceProfileCustomTextRequestContent} request
   * @param {CustomTextClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.selfServiceProfiles.customText.set("id", "en", "get-started", {
   *         "key": "value"
   *     })
   */
  set(id, language, page, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(id, language, page, request, requestOptions));
  }
  __set(id, language, page, request, requestOptions) {
    return __awaiter97(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `self-service-profiles/${url_exports.encodePathParam(id)}/custom-text/${url_exports.encodePathParam(language)}/${url_exports.encodePathParam(page)}`),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/self-service-profiles/{id}/custom-text/{language}/{page}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/selfServiceProfiles/resources/ssoTicket/client/Client.mjs
var __awaiter98 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SsoTicketClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Creates an SSO access ticket to initiate the Self Service SSO Flow using a self-service profile.
   *
   * @param {string} id - The id of the self-service profile to retrieve
   * @param {Management.CreateSelfServiceProfileSsoTicketRequestContent} request
   * @param {SsoTicketClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.selfServiceProfiles.ssoTicket.create("id")
   */
  create(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id_1) {
    return __awaiter98(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `self-service-profiles/${url_exports.encodePathParam(id)}/sso-ticket`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/self-service-profiles/{id}/sso-ticket");
    });
  }
  /**
   * Revokes an SSO access ticket and invalidates associated sessions. The ticket will no longer be accepted to initiate a Self-Service SSO session. If any users have already started a session through this ticket, their session will be terminated. Clients should expect a `202 Accepted` response upon successful processing, indicating that the request has been acknowledged and that the revocation is underway but may not be fully completed at the time of response. If the specified ticket does not exist, a `202 Accepted` response is also returned, signaling that no further action is required.
   * Clients should treat these `202` responses as an acknowledgment that the request has been accepted and is in progress, even if the ticket was not found.
   *
   * @param {string} profileId - The id of the self-service profile
   * @param {string} id - The id of the ticket to revoke
   * @param {SsoTicketClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.selfServiceProfiles.ssoTicket.revoke("profileId", "id")
   */
  revoke(profileId, id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__revoke(profileId, id, requestOptions));
  }
  __revoke(profileId, id, requestOptions) {
    return __awaiter98(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `self-service-profiles/${url_exports.encodePathParam(profileId)}/sso-ticket/${url_exports.encodePathParam(id)}/revoke`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/self-service-profiles/{profileId}/sso-ticket/{id}/revoke");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/selfServiceProfiles/client/Client.mjs
var __awaiter99 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SelfServiceProfilesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get customText() {
    var _a;
    return (_a = this._customText) !== null && _a !== void 0 ? _a : this._customText = new CustomTextClient2(this._options);
  }
  get ssoTicket() {
    var _a;
    return (_a = this._ssoTicket) !== null && _a !== void 0 ? _a : this._ssoTicket = new SsoTicketClient(this._options);
  }
  /**
   * Retrieves self-service profiles.
   *
   * @param {Management.ListSelfServiceProfilesRequestParameters} request
   * @param {SelfServiceProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   * @throws {@link Management.InternalServerError}
   *
   * @example
   *     await client.selfServiceProfiles.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list() {
    return __awaiter99(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter99(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, "self-service-profiles"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            case 500:
              throw new InternalServerError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/self-service-profiles");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.self_service_profiles) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.self_service_profiles) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Creates a self-service profile.
   *
   * @param {Management.CreateSelfServiceProfileRequestContent} request
   * @param {SelfServiceProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   * @throws {@link Management.InternalServerError}
   *
   * @example
   *     await client.selfServiceProfiles.create({
   *         name: "name"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter99(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "self-service-profiles"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          case 500:
            throw new InternalServerError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/self-service-profiles");
    });
  }
  /**
   * Retrieves a self-service profile by Id.
   *
   * @param {string} id - The id of the self-service profile to retrieve
   * @param {SelfServiceProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   * @throws {@link Management.InternalServerError}
   *
   * @example
   *     await client.selfServiceProfiles.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter99(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `self-service-profiles/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          case 500:
            throw new InternalServerError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/self-service-profiles/{id}");
    });
  }
  /**
   * Deletes a self-service profile by Id.
   *
   * @param {string} id - The id of the self-service profile to delete
   * @param {SelfServiceProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   * @throws {@link Management.InternalServerError}
   *
   * @example
   *     await client.selfServiceProfiles.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter99(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `self-service-profiles/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          case 500:
            throw new InternalServerError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/self-service-profiles/{id}");
    });
  }
  /**
   * Updates a self-service profile.
   *
   * @param {string} id - The id of the self-service profile to update
   * @param {Management.UpdateSelfServiceProfileRequestContent} request
   * @param {SelfServiceProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   * @throws {@link Management.InternalServerError}
   *
   * @example
   *     await client.selfServiceProfiles.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter99(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `self-service-profiles/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          case 500:
            throw new InternalServerError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/self-service-profiles/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/sessions/client/Client.mjs
var __awaiter100 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SessionsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve session information.
   *
   * @param {string} id - ID of session to retrieve
   * @param {SessionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.sessions.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter100(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `sessions/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/sessions/{id}");
    });
  }
  /**
   * Delete a session by ID.
   *
   * @param {string} id - ID of the session to delete.
   * @param {SessionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.sessions.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter100(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `sessions/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/sessions/{id}");
    });
  }
  /**
   * Update session information.
   *
   * @param {string} id - ID of the session to update.
   * @param {Management.UpdateSessionRequestContent} request
   * @param {SessionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.sessions.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter100(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `sessions/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/sessions/{id}");
    });
  }
  /**
   * Revokes a session by ID and all associated refresh tokens.
   *
   * @param {string} id - ID of the session to revoke.
   * @param {SessionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.sessions.revoke("id")
   */
  revoke(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__revoke(id, requestOptions));
  }
  __revoke(id, requestOptions) {
    return __awaiter100(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `sessions/${url_exports.encodePathParam(id)}/revoke`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/sessions/{id}/revoke");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/stats/client/Client.mjs
var __awaiter101 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StatsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve the number of active users that logged in during the last 30 days.
   *
   * @param {StatsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.stats.getActiveUsersCount()
   */
  getActiveUsersCount(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getActiveUsersCount(requestOptions));
  }
  __getActiveUsersCount(requestOptions) {
    return __awaiter101(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "stats/active-users"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/stats/active-users");
    });
  }
  /**
   * Retrieve the number of logins, signups and breached-password detections (subscription required) that occurred each day within a specified date range.
   *
   * @param {Management.GetDailyStatsRequestParameters} request
   * @param {StatsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.stats.getDaily({
   *         from: "from",
   *         to: "to"
   *     })
   */
  getDaily(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getDaily(request, requestOptions));
  }
  __getDaily() {
    return __awaiter101(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const { from: from_, to } = request;
      const _queryParams = {};
      if (from_ !== void 0) {
        _queryParams["from"] = from_;
      }
      if (to !== void 0) {
        _queryParams["to"] = to;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "stats/daily"),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/stats/daily");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/supplementalSignals/client/Client.mjs
var __awaiter102 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SupplementalSignalsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Get the supplemental signals configuration for a tenant.
   *
   * @param {SupplementalSignalsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.supplementalSignals.get()
   */
  get(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(requestOptions));
  }
  __get(requestOptions) {
    return __awaiter102(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "supplemental-signals"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/supplemental-signals");
    });
  }
  /**
   * Update the supplemental signals configuration for a tenant.
   *
   * @param {Management.UpdateSupplementalSignalsRequestContent} request
   * @param {SupplementalSignalsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.supplementalSignals.patch({
   *         akamai_enabled: true
   *     })
   */
  patch(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__patch(request, requestOptions));
  }
  __patch(request, requestOptions) {
    return __awaiter102(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "supplemental-signals"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/supplemental-signals");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/tenants/resources/settings/client/Client.mjs
var __awaiter103 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SettingsClient3 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve tenant settings. A list of fields to include or exclude may also be specified.
   *
   * @param {Management.GetTenantSettingsRequestParameters} request
   * @param {SettingsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.tenants.settings.get({
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  get(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(request, requestOptions));
  }
  __get() {
    return __awaiter103(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { fields, include_fields: includeFields } = request;
      const _queryParams = {};
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "tenants/settings"),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/tenants/settings");
    });
  }
  /**
   * Update settings for a tenant.
   *
   * @param {Management.UpdateTenantSettingsRequestContent} request
   * @param {SettingsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.tenants.settings.update()
   */
  update(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
  }
  __update() {
    return __awaiter103(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "tenants/settings"),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/tenants/settings");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/tenants/client/Client.mjs
var TenantsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get settings() {
    var _a;
    return (_a = this._settings) !== null && _a !== void 0 ? _a : this._settings = new SettingsClient3(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/tickets/client/Client.mjs
var __awaiter104 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TicketsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Create an email verification ticket for a given user. An email verification ticket is a generated URL that the user can consume to verify their email address.
   *
   * @param {Management.VerifyEmailTicketRequestContent} request
   * @param {TicketsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.tickets.verifyEmail({
   *         user_id: "user_id"
   *     })
   */
  verifyEmail(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__verifyEmail(request, requestOptions));
  }
  __verifyEmail(request, requestOptions) {
    return __awaiter104(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "tickets/email-verification"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/tickets/email-verification");
    });
  }
  /**
   * Create a password change ticket for a given user. A password change ticket is a generated URL that the user can consume to start a reset password flow.
   *
   * Note: This endpoint does not verify the given users identity. If you call this endpoint within your application, you must design your application to verify the users identity.
   *
   * @param {Management.ChangePasswordTicketRequestContent} request
   * @param {TicketsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.tickets.changePassword()
   */
  changePassword(request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__changePassword(request, requestOptions));
  }
  __changePassword() {
    return __awaiter104(this, arguments, void 0, function* (request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "tickets/password-change"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/tickets/password-change");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/tokenExchangeProfiles/client/Client.mjs
var __awaiter105 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TokenExchangeProfilesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve a list of all Token Exchange Profiles available in your tenant.
   *
   * By using this feature, you agree to the applicable Free Trial terms in <a href="https://www.okta.com/legal/">Oktas Master Subscription Agreement</a>. It is your responsibility to securely validate the users subject_token. See <a href="https://auth0.com/docs/authenticate/custom-token-exchange">User Guide</a> for more details.
   *
   * This endpoint supports Checkpoint pagination. To search by checkpoint, use the following parameters:
   * <ul>
   * <li><code>from</code>: Optional id from which to start selection.</li>
   * <li><code>take</code>: The total amount of entries to retrieve when using the from parameter. Defaults to 50.</li>
   * </ul>
   *
   * <b>Note</b>: The first time you call this endpoint using checkpoint pagination, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no pages are remaining.
   *
   * @param {Management.TokenExchangeProfilesListRequest} request
   * @param {TokenExchangeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.tokenExchangeProfiles.list({
   *         from: "from",
   *         take: 1
   *     })
   */
  list() {
    return __awaiter105(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter105(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "token-exchange-profiles"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/token-exchange-profiles");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.token_exchange_profiles) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Create a new Token Exchange Profile within your tenant.
   *
   * By using this feature, you agree to the applicable Free Trial terms in <a href="https://www.okta.com/legal/">Oktas Master Subscription Agreement</a>. It is your responsibility to securely validate the users subject_token. See <a href="https://auth0.com/docs/authenticate/custom-token-exchange">User Guide</a> for more details.
   *
   * @param {Management.CreateTokenExchangeProfileRequestContent} request
   * @param {TokenExchangeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.tokenExchangeProfiles.create({
   *         name: "name",
   *         subject_token_type: "subject_token_type",
   *         action_id: "action_id"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter105(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "token-exchange-profiles"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: Object.assign(Object.assign({}, request), { type: "custom_authentication" }),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/token-exchange-profiles");
    });
  }
  /**
   * Retrieve details about a single Token Exchange Profile specified by ID.
   *
   * By using this feature, you agree to the applicable Free Trial terms in <a href="https://www.okta.com/legal/">Oktas Master Subscription Agreement</a>. It is your responsibility to securely validate the users subject_token. See <a href="https://auth0.com/docs/authenticate/custom-token-exchange">User Guide</a> for more details.
   *
   * @param {string} id - ID of the Token Exchange Profile to retrieve.
   * @param {TokenExchangeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.tokenExchangeProfiles.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter105(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `token-exchange-profiles/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/token-exchange-profiles/{id}");
    });
  }
  /**
   * Delete a Token Exchange Profile within your tenant.
   *
   * By using this feature, you agree to the applicable Free Trial terms in <a href="https://www.okta.com/legal/">Okta's Master Subscription Agreement</a>. It is your responsibility to securely validate the user's subject_token. See <a href="https://auth0.com/docs/authenticate/custom-token-exchange">User Guide</a> for more details.
   *
   *
   * @param {string} id - ID of the Token Exchange Profile to delete.
   * @param {TokenExchangeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.tokenExchangeProfiles.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter105(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `token-exchange-profiles/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/token-exchange-profiles/{id}");
    });
  }
  /**
   * Update a Token Exchange Profile within your tenant.
   *
   * By using this feature, you agree to the applicable Free Trial terms in <a href="https://www.okta.com/legal/">Okta's Master Subscription Agreement</a>. It is your responsibility to securely validate the user's subject_token. See <a href="https://auth0.com/docs/authenticate/custom-token-exchange">User Guide</a> for more details.
   *
   *
   * @param {string} id - ID of the Token Exchange Profile to update.
   * @param {Management.UpdateTokenExchangeProfileRequestContent} request
   * @param {TokenExchangeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.tokenExchangeProfiles.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter105(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `token-exchange-profiles/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/token-exchange-profiles/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/userAttributeProfiles/client/Client.mjs
var __awaiter106 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UserAttributeProfilesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve a list of User Attribute Profiles. This endpoint supports Checkpoint pagination.
   *
   * @param {Management.ListUserAttributeProfileRequestParameters} request
   * @param {UserAttributeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userAttributeProfiles.list({
   *         from: "from",
   *         take: 1
   *     })
   */
  list() {
    return __awaiter106(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter106(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "user-attribute-profiles"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/user-attribute-profiles");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.user_attribute_profiles) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Retrieve details about a single User Attribute Profile specified by ID.
   *
   * @param {Management.CreateUserAttributeProfileRequestContent} request
   * @param {UserAttributeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userAttributeProfiles.create({
   *         name: "name",
   *         user_attributes: {
   *             "key": {
   *                 description: "description",
   *                 label: "label",
   *                 profile_required: true,
   *                 auth0_mapping: "auth0_mapping"
   *             }
   *         }
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter106(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "user-attribute-profiles"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/user-attribute-profiles");
    });
  }
  /**
   * Retrieve a list of User Attribute Profile Templates.
   *
   * @param {UserAttributeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userAttributeProfiles.listTemplates()
   */
  listTemplates(requestOptions) {
    return HttpResponsePromise.fromPromise(this.__listTemplates(requestOptions));
  }
  __listTemplates(requestOptions) {
    return __awaiter106(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "user-attribute-profiles/templates"),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/user-attribute-profiles/templates");
    });
  }
  /**
   * Retrieve a User Attribute Profile Template.
   *
   * @param {string} id - ID of the user-attribute-profile-template to retrieve.
   * @param {UserAttributeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userAttributeProfiles.getTemplate("id")
   */
  getTemplate(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__getTemplate(id, requestOptions));
  }
  __getTemplate(id, requestOptions) {
    return __awaiter106(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `user-attribute-profiles/templates/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/user-attribute-profiles/templates/{id}");
    });
  }
  /**
   * Retrieve details about a single User Attribute Profile specified by ID.
   *
   * @param {string} id - ID of the user-attribute-profile to retrieve.
   * @param {UserAttributeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userAttributeProfiles.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter106(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `user-attribute-profiles/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/user-attribute-profiles/{id}");
    });
  }
  /**
   * Delete a single User Attribute Profile specified by ID.
   *
   * @param {string} id - ID of the user-attribute-profile to delete.
   * @param {UserAttributeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userAttributeProfiles.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter106(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `user-attribute-profiles/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/user-attribute-profiles/{id}");
    });
  }
  /**
   * Update the details of a specific User attribute profile, such as name, user_id and user_attributes.
   *
   * @param {string} id - ID of the user attribute profile to update.
   * @param {Management.UpdateUserAttributeProfileRequestContent} request
   * @param {UserAttributeProfilesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userAttributeProfiles.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter106(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `user-attribute-profiles/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/user-attribute-profiles/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/userBlocks/client/Client.mjs
var __awaiter107 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UserBlocksClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details of all <a href="https://auth0.com/docs/secure/attack-protection/brute-force-protection">Brute-force Protection</a> blocks for a user with the given identifier (username, phone number, or email).
   *
   * @param {Management.ListUserBlocksByIdentifierRequestParameters} request
   * @param {UserBlocksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userBlocks.listByIdentifier({
   *         identifier: "identifier",
   *         consider_brute_force_enablement: true
   *     })
   */
  listByIdentifier(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__listByIdentifier(request, requestOptions));
  }
  __listByIdentifier(request, requestOptions) {
    return __awaiter107(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { identifier, consider_brute_force_enablement: considerBruteForceEnablement } = request;
      const _queryParams = {};
      _queryParams["identifier"] = identifier;
      if (considerBruteForceEnablement !== void 0) {
        _queryParams["consider_brute_force_enablement"] = (_a = considerBruteForceEnablement === null || considerBruteForceEnablement === void 0 ? void 0 : considerBruteForceEnablement.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "user-blocks"),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/user-blocks");
    });
  }
  /**
   * Remove all <a href="https://auth0.com/docs/secure/attack-protection/brute-force-protection">Brute-force Protection</a> blocks for the user with the given identifier (username, phone number, or email).
   *
   * Note: This endpoint does not unblock users that were <a href="https://auth0.com/docs/user-profile#block-and-unblock-a-user">blocked by a tenant administrator</a>.
   *
   * @param {Management.DeleteUserBlocksByIdentifierRequestParameters} request
   * @param {UserBlocksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userBlocks.deleteByIdentifier({
   *         identifier: "identifier"
   *     })
   */
  deleteByIdentifier(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__deleteByIdentifier(request, requestOptions));
  }
  __deleteByIdentifier(request, requestOptions) {
    return __awaiter107(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const { identifier } = request;
      const _queryParams = {};
      _queryParams["identifier"] = identifier;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "user-blocks"),
        method: "DELETE",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/user-blocks");
    });
  }
  /**
   * Retrieve details of all <a href="https://auth0.com/docs/secure/attack-protection/brute-force-protection">Brute-force Protection</a> blocks for the user with the given ID.
   *
   * @param {string} id - user_id of the user blocks to retrieve.
   * @param {Management.ListUserBlocksRequestParameters} request
   * @param {UserBlocksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userBlocks.list("id", {
   *         consider_brute_force_enablement: true
   *     })
   */
  list(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(id, request, requestOptions));
  }
  __list(id_1) {
    return __awaiter107(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { consider_brute_force_enablement: considerBruteForceEnablement } = request;
      const _queryParams = {};
      if (considerBruteForceEnablement !== void 0) {
        _queryParams["consider_brute_force_enablement"] = (_a = considerBruteForceEnablement === null || considerBruteForceEnablement === void 0 ? void 0 : considerBruteForceEnablement.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `user-blocks/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/user-blocks/{id}");
    });
  }
  /**
   * Remove all <a href="https://auth0.com/docs/secure/attack-protection/brute-force-protection">Brute-force Protection</a> blocks for the user with the given ID.
   *
   * Note: This endpoint does not unblock users that were <a href="https://auth0.com/docs/user-profile#block-and-unblock-a-user">blocked by a tenant administrator</a>.
   *
   * @param {string} id - The user_id of the user to update.
   * @param {UserBlocksClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userBlocks.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter107(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `user-blocks/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/user-blocks/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/userGrants/client/Client.mjs
var __awaiter108 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UserGrantsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve the <a href="https://auth0.com/docs/api-auth/which-oauth-flow-to-use">grants</a> associated with your account.
   *
   * @param {Management.ListUserGrantsRequestParameters} request
   * @param {UserGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userGrants.list({
   *         per_page: 1,
   *         page: 1,
   *         include_totals: true,
   *         user_id: "user_id",
   *         client_id: "client_id",
   *         audience: "audience"
   *     })
   */
  list() {
    return __awaiter108(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter108(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { per_page: perPage = 50, page = 0, include_totals: includeTotals = true, user_id: userId, client_id: clientId, audience } = request2;
        const _queryParams = {};
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_a = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (page !== void 0) {
          _queryParams["page"] = (_b = page === null || page === void 0 ? void 0 : page.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (userId !== void 0) {
          _queryParams["user_id"] = userId;
        }
        if (clientId !== void 0) {
          _queryParams["client_id"] = clientId;
        }
        if (audience !== void 0) {
          _queryParams["audience"] = audience;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, "grants"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/grants");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.grants) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.grants) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Delete a grant associated with your account.
   *
   * @param {Management.DeleteUserGrantByUserIdRequestParameters} request
   * @param {UserGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userGrants.deleteByUserId({
   *         user_id: "user_id"
   *     })
   */
  deleteByUserId(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__deleteByUserId(request, requestOptions));
  }
  __deleteByUserId(request, requestOptions) {
    return __awaiter108(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const { user_id: userId } = request;
      const _queryParams = {};
      _queryParams["user_id"] = userId;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "grants"),
        method: "DELETE",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/grants");
    });
  }
  /**
   * Delete a grant associated with your account.
   *
   * @param {string} id - ID of the grant to delete.
   * @param {UserGrantsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.userGrants.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter108(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `grants/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/grants/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/authenticationMethods/client/Client.mjs
var __awaiter109 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AuthenticationMethodsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve detailed list of authentication methods associated with a specified user.
   *
   * @param {string} id - The ID of the user in question.
   * @param {Management.ListUserAuthenticationMethodsRequestParameters} request
   * @param {AuthenticationMethodsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.authenticationMethods.list("id", {
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list(id_1) {
    return __awaiter109(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter109(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/authentication-methods`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/authentication-methods");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.authenticators) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.authenticators) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create an authentication method. Authentication methods created via this endpoint will be auto confirmed and should already have verification completed.
   *
   * @param {string} id - The ID of the user to whom the new authentication method will be assigned.
   * @param {Management.CreateUserAuthenticationMethodRequestContent} request
   * @param {AuthenticationMethodsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.authenticationMethods.create("id", {
   *         type: "phone"
   *     })
   */
  create(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id, request, requestOptions) {
    return __awaiter109(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/authentication-methods`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/users/{id}/authentication-methods");
    });
  }
  /**
   * Replace the specified user <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors"> authentication methods</a> with supplied values.
   *
   *     <b>Note</b>: Authentication methods supplied through this action do not iterate on existing methods. Instead, any methods passed will overwrite the user&#8217s existing settings.
   *
   * @param {string} id - The ID of the user in question.
   * @param {Management.SetUserAuthenticationMethodsRequestContent} request
   * @param {AuthenticationMethodsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.authenticationMethods.set("id", [{
   *             type: "phone"
   *         }])
   */
  set(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__set(id, request, requestOptions));
  }
  __set(id, request, requestOptions) {
    return __awaiter109(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/authentication-methods`),
        method: "PUT",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/users/{id}/authentication-methods");
    });
  }
  /**
   * Remove all authentication methods (i.e., enrolled MFA factors) from the specified user account. This action cannot be undone.
   *
   * @param {string} id - The ID of the user in question.
   * @param {AuthenticationMethodsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.authenticationMethods.deleteAll("id")
   */
  deleteAll(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__deleteAll(id, requestOptions));
  }
  __deleteAll(id, requestOptions) {
    return __awaiter109(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/authentication-methods`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{id}/authentication-methods");
    });
  }
  /**
   * @param {string} id - The ID of the user in question.
   * @param {string} authentication_method_id - The ID of the authentication methods in question.
   * @param {AuthenticationMethodsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.authenticationMethods.get("id", "authentication_method_id")
   */
  get(id, authentication_method_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, authentication_method_id, requestOptions));
  }
  __get(id, authentication_method_id, requestOptions) {
    return __awaiter109(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/authentication-methods/${url_exports.encodePathParam(authentication_method_id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/authentication-methods/{authentication_method_id}");
    });
  }
  /**
   * Remove the authentication method with the given ID from the specified user. For more information, review <a href="https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api">Manage Authentication Methods with Management API</a>.
   *
   * @param {string} id - The ID of the user in question.
   * @param {string} authentication_method_id - The ID of the authentication method to delete.
   * @param {AuthenticationMethodsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.authenticationMethods.delete("id", "authentication_method_id")
   */
  delete(id, authentication_method_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, authentication_method_id, requestOptions));
  }
  __delete(id, authentication_method_id, requestOptions) {
    return __awaiter109(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/authentication-methods/${url_exports.encodePathParam(authentication_method_id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{id}/authentication-methods/{authentication_method_id}");
    });
  }
  /**
   * Modify the authentication method with the given ID from the specified user. For more information, review <a href="https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api">Manage Authentication Methods with Management API</a>.
   *
   * @param {string} id - The ID of the user in question.
   * @param {string} authentication_method_id - The ID of the authentication method to update.
   * @param {Management.UpdateUserAuthenticationMethodRequestContent} request
   * @param {AuthenticationMethodsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.authenticationMethods.update("id", "authentication_method_id")
   */
  update(id, authentication_method_id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, authentication_method_id, request, requestOptions));
  }
  __update(id_1, authentication_method_id_1) {
    return __awaiter109(this, arguments, void 0, function* (id, authentication_method_id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/authentication-methods/${url_exports.encodePathParam(authentication_method_id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/users/{id}/authentication-methods/{authentication_method_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/authenticators/client/Client.mjs
var __awaiter110 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AuthenticatorsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Remove all authenticators registered to a given user ID, such as OTP, email, phone, and push-notification. This action cannot be undone. For more information, review <a href="https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api">Manage Authentication Methods with Management API</a>.
   *
   * @param {string} id - ID of the user to delete.
   * @param {AuthenticatorsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.authenticators.deleteAll("id")
   */
  deleteAll(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__deleteAll(id, requestOptions));
  }
  __deleteAll(id, requestOptions) {
    return __awaiter110(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/authenticators`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{id}/authenticators");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/connectedAccounts/client/Client.mjs
var __awaiter111 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ConnectedAccountsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve all connected accounts associated with the user.
   *
   * @param {string} id - ID of the user to list connected accounts for.
   * @param {Management.GetUserConnectedAccountsRequestParameters} request
   * @param {ConnectedAccountsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.connectedAccounts.list("id", {
   *         from: "from",
   *         take: 1
   *     })
   */
  list(id_1) {
    return __awaiter111(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter111(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/connected-accounts`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/connected-accounts");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.connected_accounts) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/enrollments/client/Client.mjs
var __awaiter112 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var EnrollmentsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve the first <a href="https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors">multi-factor authentication</a> enrollment that a specific user has confirmed.
   *
   * @param {string} id - ID of the user to list enrollments for.
   * @param {EnrollmentsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.enrollments.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter112(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/enrollments`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/enrollments");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/federatedConnectionsTokensets/client/Client.mjs
var __awaiter113 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FederatedConnectionsTokensetsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * List active federated connections tokensets for a provided user
   *
   * @param {string} id - User identifier
   * @param {FederatedConnectionsTokensetsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.federatedConnectionsTokensets.list("id")
   */
  list(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__list(id, requestOptions));
  }
  __list(id, requestOptions) {
    return __awaiter113(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/federated-connections-tokensets`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/federated-connections-tokensets");
    });
  }
  /**
   * @param {string} id - Id of the user that owns the tokenset
   * @param {string} tokenset_id - The tokenset id
   * @param {FederatedConnectionsTokensetsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.federatedConnectionsTokensets.delete("id", "tokenset_id")
   */
  delete(id, tokenset_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, tokenset_id, requestOptions));
  }
  __delete(id, tokenset_id, requestOptions) {
    return __awaiter113(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/federated-connections-tokensets/${url_exports.encodePathParam(tokenset_id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{id}/federated-connections-tokensets/{tokenset_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/identities/client/Client.mjs
var __awaiter114 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IdentitiesClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Link two user accounts together forming a primary and secondary relationship. On successful linking, the endpoint returns the new array of the primary account identities.
   *
   * Note: There are two ways of invoking the endpoint:
   *
   * <ul>
   *   <li>With the authenticated primary account's JWT in the Authorization header, which has the <code>update:current_user_identities</code> scope:
   *     <pre>
   *       POST /api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities
   *       Authorization: "Bearer PRIMARY_ACCOUNT_JWT"
   *       {
   *         "link_with": "SECONDARY_ACCOUNT_JWT"
   *       }
   *     </pre>
   *     In this case, only the <code>link_with</code> param is required in the body, which also contains the JWT obtained upon the secondary account's authentication.
   *   </li>
   *   <li>With a token generated by the API V2 containing the <code>update:users</code> scope:
   *     <pre>
   *     POST /api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities
   *     Authorization: "Bearer YOUR_API_V2_TOKEN"
   *     {
   *       "provider": "SECONDARY_ACCOUNT_PROVIDER",
   *       "connection_id": "SECONDARY_ACCOUNT_CONNECTION_ID(OPTIONAL)",
   *       "user_id": "SECONDARY_ACCOUNT_USER_ID"
   *     }
   *     </pre>
   *     In this case you need to send <code>provider</code> and <code>user_id</code> in the body. Optionally you can also send the <code>connection_id</code> param which is suitable for identifying a particular database connection for the 'auth0' provider.
   *   </li>
   * </ul>
   *
   * @param {string} id - ID of the primary user account to link a second user account to.
   * @param {Management.LinkUserIdentityRequestContent} request
   * @param {IdentitiesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.identities.link("id")
   */
  link(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__link(id, request, requestOptions));
  }
  __link(id_1) {
    return __awaiter114(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/identities`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/users/{id}/identities");
    });
  }
  /**
   * Unlink a specific secondary account from a target user. This action requires the ID of both the target user and the secondary account.
   *
   * Unlinking the secondary account removes it from the identities array of the target user and creates a new standalone profile for the secondary account. To learn more, review <a href="https://auth0.com/docs/manage-users/user-accounts/user-account-linking/unlink-user-accounts">Unlink User Accounts</a>.
   *
   * @param {string} id - ID of the primary user account.
   * @param {Management.UserIdentityProviderEnum} provider - Identity provider name of the secondary linked account (e.g. `google-oauth2`).
   * @param {string} user_id - ID of the secondary linked account (e.g. `123456789081523216417` part after the `|` in `google-oauth2|123456789081523216417`).
   * @param {IdentitiesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.identities.delete("id", "ad", "user_id")
   */
  delete(id, provider, user_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, provider, user_id, requestOptions));
  }
  __delete(id, provider, user_id, requestOptions) {
    return __awaiter114(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/identities/${url_exports.encodePathParam(provider)}/${url_exports.encodePathParam(user_id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{id}/identities/{provider}/{user_id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/logs/client/Client.mjs
var __awaiter115 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LogsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve log events for a specific user.
   *
   * Note: For more information on all possible event types, their respective acronyms and descriptions, see <a href="https://auth0.com/docs/logs/log-event-type-codes">Log Event Type Codes</a>.
   *
   * For more information on the list of fields that can be used in `sort`, see <a href="https://auth0.com/docs/logs/log-search-query-syntax#searchable-fields">Searchable Fields</a>.
   *
   * Auth0 <a href="https://auth0.com/docs/logs/retrieve-log-events-using-mgmt-api#limitations">limits the number of logs</a> you can return by search criteria to 100 logs per request. Furthermore, you may only paginate through up to 1,000 search results. If you exceed this threshold, please redefine your search.
   *
   * @param {string} id - ID of the user of the logs to retrieve
   * @param {Management.ListUserLogsRequestParameters} request
   * @param {LogsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.logs.list("id", {
   *         page: 1,
   *         per_page: 1,
   *         sort: "sort",
   *         include_totals: true
   *     })
   */
  list(id_1) {
    return __awaiter115(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter115(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, sort, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (sort !== void 0) {
          _queryParams["sort"] = sort;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/logs`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/logs");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.logs) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.logs) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/multifactor/client/Client.mjs
var __awaiter116 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MultifactorClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Invalidate all remembered browsers across all <a href="https://auth0.com/docs/multifactor-authentication">authentication factors</a> for a user.
   *
   * @param {string} id - ID of the user to invalidate all remembered browsers and authentication factors for.
   * @param {MultifactorClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   *
   * @example
   *     await client.users.multifactor.invalidateRememberBrowser("id")
   */
  invalidateRememberBrowser(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__invalidateRememberBrowser(id, requestOptions));
  }
  __invalidateRememberBrowser(id, requestOptions) {
    return __awaiter116(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/multifactor/actions/invalidate-remember-browser`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/users/{id}/multifactor/actions/invalidate-remember-browser");
    });
  }
  /**
   * Remove a <a href="https://auth0.com/docs/multifactor-authentication">multifactor</a> authentication configuration from a user's account. This forces the user to manually reconfigure the multi-factor provider.
   *
   * @param {string} id - ID of the user to remove a multifactor configuration from.
   * @param {Management.UserMultifactorProviderEnum} provider - The multi-factor provider. Supported values 'duo' or 'google-authenticator'
   * @param {MultifactorClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.multifactor.deleteProvider("id", "duo")
   */
  deleteProvider(id, provider, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__deleteProvider(id, provider, requestOptions));
  }
  __deleteProvider(id, provider, requestOptions) {
    return __awaiter116(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/multifactor/${url_exports.encodePathParam(provider)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{id}/multifactor/{provider}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/organizations/client/Client.mjs
var __awaiter117 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OrganizationsClient3 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve list of the specified user's current Organization memberships. User must be specified by user ID. For more information, review <a href="https://auth0.com/docs/manage-users/organizations">Auth0 Organizations</a>.
   *
   * @param {string} id - ID of the user to retrieve the organizations for.
   * @param {Management.ListUserOrganizationsRequestParameters} request
   * @param {OrganizationsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.organizations.list("id", {
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true
   *     })
   */
  list(id_1) {
    return __awaiter117(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter117(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/organizations`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/organizations");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.organizations) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.organizations) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/permissions/client/Client.mjs
var __awaiter118 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PermissionsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve all permissions associated with the user.
   *
   * @param {string} id - ID of the user to retrieve the permissions for.
   * @param {Management.ListUserPermissionsRequestParameters} request
   * @param {PermissionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.permissions.list("id", {
   *         per_page: 1,
   *         page: 1,
   *         include_totals: true
   *     })
   */
  list(id_1) {
    return __awaiter118(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter118(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { per_page: perPage = 50, page = 0, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_a = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (page !== void 0) {
          _queryParams["page"] = (_b = page === null || page === void 0 ? void 0 : page.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/permissions`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/permissions");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.permissions) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.permissions) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Assign permissions to a user.
   *
   * @param {string} id - ID of the user to assign permissions to.
   * @param {Management.CreateUserPermissionsRequestContent} request
   * @param {PermissionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.permissions.create("id", {
   *         permissions: [{
   *                 resource_server_identifier: "resource_server_identifier",
   *                 permission_name: "permission_name"
   *             }]
   *     })
   */
  create(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(id, request, requestOptions));
  }
  __create(id, request, requestOptions) {
    return __awaiter118(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/permissions`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/users/{id}/permissions");
    });
  }
  /**
   * Remove permissions from a user.
   *
   * @param {string} id - ID of the user to remove permissions from.
   * @param {Management.DeleteUserPermissionsRequestContent} request
   * @param {PermissionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.permissions.delete("id", {
   *         permissions: [{
   *                 resource_server_identifier: "resource_server_identifier",
   *                 permission_name: "permission_name"
   *             }]
   *     })
   */
  delete(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, request, requestOptions));
  }
  __delete(id, request, requestOptions) {
    return __awaiter118(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/permissions`),
        method: "DELETE",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{id}/permissions");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/refreshToken/client/Client.mjs
var __awaiter119 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RefreshTokenClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details for a user's refresh tokens.
   *
   * @param {string} user_id - ID of the user to get refresh tokens for
   * @param {Management.ListRefreshTokensRequestParameters} request
   * @param {RefreshTokenClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.refreshToken.list("user_id", {
   *         from: "from",
   *         take: 1
   *     })
   */
  list(user_id_1) {
    return __awaiter119(this, arguments, void 0, function* (user_id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter119(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(user_id)}/refresh-tokens`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{user_id}/refresh-tokens");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.tokens) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Delete all refresh tokens for a user.
   *
   * @param {string} user_id - ID of the user to get remove refresh tokens for
   * @param {RefreshTokenClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.refreshToken.delete("user_id")
   */
  delete(user_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(user_id, requestOptions));
  }
  __delete(user_id, requestOptions) {
    return __awaiter119(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(user_id)}/refresh-tokens`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{user_id}/refresh-tokens");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/riskAssessments/client/Client.mjs
var __awaiter120 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RiskAssessmentsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Clear risk assessment assessors for a specific user
   *
   * @param {string} id - ID of the user to clear assessors for.
   * @param {Management.ClearAssessorsRequestContent} request
   * @param {RiskAssessmentsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.riskAssessments.clear("id", {
   *         connection: "connection",
   *         assessors: ["new-device"]
   *     })
   */
  clear(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__clear(id, request, requestOptions));
  }
  __clear(id, request, requestOptions) {
    return __awaiter120(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/risk-assessments/clear`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/users/{id}/risk-assessments/clear");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/roles/client/Client.mjs
var __awaiter121 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RolesClient3 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve detailed list of all user roles currently assigned to a user.
   *
   * <b>Note</b>: This action retrieves all roles assigned to a user in the context of your whole tenant. To retrieve Organization-specific roles, use the following endpoint: <a href="https://auth0.com/docs/api/management/v2/organizations/get-organization-member-roles">Get user roles assigned to an Organization member</a>.
   *
   * @param {string} id - ID of the user to list roles for.
   * @param {Management.ListUserRolesRequestParameters} request
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.roles.list("id", {
   *         per_page: 1,
   *         page: 1,
   *         include_totals: true
   *     })
   */
  list(id_1) {
    return __awaiter121(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter121(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { per_page: perPage = 50, page = 0, include_totals: includeTotals = true } = request2;
        const _queryParams = {};
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_a = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (page !== void 0) {
          _queryParams["page"] = (_b = page === null || page === void 0 ? void 0 : page.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_d = this._options) === null || _d === void 0 ? void 0 : _d.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_e = this._options.fetcher) !== null && _e !== void 0 ? _e : fetcher)({
          url: url_exports.join((_g = (_f = yield Supplier.get(this._options.baseUrl)) !== null && _f !== void 0 ? _f : yield Supplier.get(this._options.environment)) !== null && _g !== void 0 ? _g : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/roles`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_k = (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.timeoutInSeconds) !== null && _k !== void 0 ? _k : 60) * 1e3,
          maxRetries: (_l = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _l !== void 0 ? _l : (_m = this._options) === null || _m === void 0 ? void 0 : _m.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_o = this._options) === null || _o === void 0 ? void 0 : _o.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}/roles");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.roles) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.roles) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Assign one or more existing user roles to a user. For more information, review <a href="https://auth0.com/docs/manage-users/access-control/rbac">Role-Based Access Control</a>.
   *
   * <b>Note</b>: New roles cannot be created through this action. Additionally, this action is used to assign roles to a user in the context of your whole tenant. To assign roles in the context of a specific Organization, use the following endpoint: <a href="https://auth0.com/docs/api/management/v2/organizations/post-organization-member-roles">Assign user roles to an Organization member</a>.
   *
   * @param {string} id - ID of the user to associate roles with.
   * @param {Management.AssignUserRolesRequestContent} request
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.roles.assign("id", {
   *         roles: ["roles"]
   *     })
   */
  assign(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__assign(id, request, requestOptions));
  }
  __assign(id, request, requestOptions) {
    return __awaiter121(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/roles`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/users/{id}/roles");
    });
  }
  /**
   * Remove one or more specified user roles assigned to a user.
   *
   * <b>Note</b>: This action removes a role from a user in the context of your whole tenant. If you want to unassign a role from a user in the context of a specific Organization, use the following endpoint: <a href="https://auth0.com/docs/api/management/v2/organizations/delete-organization-member-roles">Delete user roles from an Organization member</a>.
   *
   * @param {string} id - ID of the user to remove roles from.
   * @param {Management.DeleteUserRolesRequestContent} request
   * @param {RolesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.roles.delete("id", {
   *         roles: ["roles"]
   *     })
   */
  delete(id, request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, request, requestOptions));
  }
  __delete(id, request, requestOptions) {
    return __awaiter121(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/roles`),
        method: "DELETE",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{id}/roles");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/resources/sessions/client/Client.mjs
var __awaiter122 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SessionsClient2 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * Retrieve details for a user's sessions.
   *
   * @param {string} user_id - ID of the user to get sessions for
   * @param {Management.ListUserSessionsRequestParameters} request
   * @param {SessionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.sessions.list("user_id", {
   *         from: "from",
   *         take: 1
   *     })
   */
  list(user_id_1) {
    return __awaiter122(this, arguments, void 0, function* (user_id, request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter122(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(user_id)}/sessions`),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 404:
              throw new NotFoundError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{user_id}/sessions");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.sessions) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Delete all sessions for a user.
   *
   * @param {string} user_id - ID of the user to get sessions for
   * @param {SessionsClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.sessions.delete("user_id")
   */
  delete(user_id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(user_id, requestOptions));
  }
  __delete(user_id, requestOptions) {
    return __awaiter122(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(user_id)}/sessions`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{user_id}/sessions");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/users/client/Client.mjs
var __awaiter123 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UsersClient3 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get authenticationMethods() {
    var _a;
    return (_a = this._authenticationMethods) !== null && _a !== void 0 ? _a : this._authenticationMethods = new AuthenticationMethodsClient(this._options);
  }
  get authenticators() {
    var _a;
    return (_a = this._authenticators) !== null && _a !== void 0 ? _a : this._authenticators = new AuthenticatorsClient(this._options);
  }
  get connectedAccounts() {
    var _a;
    return (_a = this._connectedAccounts) !== null && _a !== void 0 ? _a : this._connectedAccounts = new ConnectedAccountsClient(this._options);
  }
  get enrollments() {
    var _a;
    return (_a = this._enrollments) !== null && _a !== void 0 ? _a : this._enrollments = new EnrollmentsClient2(this._options);
  }
  get federatedConnectionsTokensets() {
    var _a;
    return (_a = this._federatedConnectionsTokensets) !== null && _a !== void 0 ? _a : this._federatedConnectionsTokensets = new FederatedConnectionsTokensetsClient(this._options);
  }
  get identities() {
    var _a;
    return (_a = this._identities) !== null && _a !== void 0 ? _a : this._identities = new IdentitiesClient(this._options);
  }
  get logs() {
    var _a;
    return (_a = this._logs) !== null && _a !== void 0 ? _a : this._logs = new LogsClient2(this._options);
  }
  get multifactor() {
    var _a;
    return (_a = this._multifactor) !== null && _a !== void 0 ? _a : this._multifactor = new MultifactorClient(this._options);
  }
  get organizations() {
    var _a;
    return (_a = this._organizations) !== null && _a !== void 0 ? _a : this._organizations = new OrganizationsClient3(this._options);
  }
  get permissions() {
    var _a;
    return (_a = this._permissions) !== null && _a !== void 0 ? _a : this._permissions = new PermissionsClient2(this._options);
  }
  get riskAssessments() {
    var _a;
    return (_a = this._riskAssessments) !== null && _a !== void 0 ? _a : this._riskAssessments = new RiskAssessmentsClient2(this._options);
  }
  get roles() {
    var _a;
    return (_a = this._roles) !== null && _a !== void 0 ? _a : this._roles = new RolesClient3(this._options);
  }
  get refreshToken() {
    var _a;
    return (_a = this._refreshToken) !== null && _a !== void 0 ? _a : this._refreshToken = new RefreshTokenClient(this._options);
  }
  get sessions() {
    var _a;
    return (_a = this._sessions) !== null && _a !== void 0 ? _a : this._sessions = new SessionsClient2(this._options);
  }
  /**
   * Retrieve details of users. It is possible to:
   *
   * - Specify a search criteria for users
   * - Sort the users to be returned
   * - Select the fields to be returned
   * - Specify the number of users to retrieve per page and the page index
   *  <!-- only v3 is available -->
   * The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a>
   *
   * <a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a>
   *
   * Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.
   *
   * Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.
   *
   * @param {Management.ListUsersRequestParameters} request
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   * @throws {@link Management.ServiceUnavailableError}
   *
   * @example
   *     await client.users.list({
   *         page: 1,
   *         per_page: 1,
   *         include_totals: true,
   *         sort: "sort",
   *         connection: "connection",
   *         fields: "fields",
   *         include_fields: true,
   *         q: "q",
   *         search_engine: "v1",
   *         primary_order: true
   *     })
   */
  list() {
    return __awaiter123(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter123(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true, sort, connection, fields, include_fields: includeFields, q, search_engine: searchEngine, primary_order: primaryOrder } = request2;
        const _queryParams = {};
        if (page !== void 0) {
          _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
        }
        if (perPage !== void 0) {
          _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
        }
        if (includeTotals !== void 0) {
          _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
        }
        if (sort !== void 0) {
          _queryParams["sort"] = sort;
        }
        if (connection !== void 0) {
          _queryParams["connection"] = connection;
        }
        if (fields !== void 0) {
          _queryParams["fields"] = fields;
        }
        if (includeFields !== void 0) {
          _queryParams["include_fields"] = (_d = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _d !== void 0 ? _d : null;
        }
        if (q !== void 0) {
          _queryParams["q"] = q;
        }
        if (searchEngine !== void 0) {
          _queryParams["search_engine"] = searchEngine;
        }
        if (primaryOrder !== void 0) {
          _queryParams["primary_order"] = (_e = primaryOrder === null || primaryOrder === void 0 ? void 0 : primaryOrder.toString()) !== null && _e !== void 0 ? _e : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_f = this._options) === null || _f === void 0 ? void 0 : _f.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_g = this._options.fetcher) !== null && _g !== void 0 ? _g : fetcher)({
          url: url_exports.join((_j = (_h = yield Supplier.get(this._options.baseUrl)) !== null && _h !== void 0 ? _h : yield Supplier.get(this._options.environment)) !== null && _j !== void 0 ? _j : ManagementEnvironment.Default, "users"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_m = (_k = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _k !== void 0 ? _k : (_l = this._options) === null || _l === void 0 ? void 0 : _l.timeoutInSeconds) !== null && _m !== void 0 ? _m : 60) * 1e3,
          maxRetries: (_o = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _o !== void 0 ? _o : (_p = this._options) === null || _p === void 0 ? void 0 : _p.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_q = this._options) === null || _q === void 0 ? void 0 : _q.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            case 503:
              throw new ServiceUnavailableError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users");
      }));
      let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => {
          var _a, _b;
          return ((_a = response === null || response === void 0 ? void 0 : response.users) !== null && _a !== void 0 ? _a : []).length >= Math.floor((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 50);
        },
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.users) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (_response) => {
          _offset += 1;
          return list(setObjectProperty(request, "page", _offset));
        }
      });
    });
  }
  /**
   * Create a new user for a given <a href="https://auth0.com/docs/connections/database">database</a> or <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connection.
   *
   * Note: <code>connection</code> is required but other parameters such as <code>email</code> and <code>password</code> are dependent upon the type of connection.
   *
   * @param {Management.CreateUserRequestContent} request
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.create({
   *         connection: "connection"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter123(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "users"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/users");
    });
  }
  /**
   * Find users by email. If Auth0 is the identity provider (idP), the email address associated with a user is saved in lower case, regardless of how you initially provided it.
   *
   * For example, if you register a user as JohnSmith@example.com, Auth0 saves the user's email as johnsmith@example.com.
   *
   * Therefore, when using this endpoint, make sure that you are searching for users via email addresses using the correct case.
   *
   * @param {Management.ListUsersByEmailRequestParameters} request
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.listUsersByEmail({
   *         fields: "fields",
   *         include_fields: true,
   *         email: "email"
   *     })
   */
  listUsersByEmail(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__listUsersByEmail(request, requestOptions));
  }
  __listUsersByEmail(request, requestOptions) {
    return __awaiter123(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { fields, include_fields: includeFields, email } = request;
      const _queryParams = {};
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      _queryParams["email"] = email;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "users-by-email"),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users-by-email");
    });
  }
  /**
   * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
   *
   * @param {string} id - ID of the user to retrieve.
   * @param {Management.GetUserRequestParameters} request
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.get("id", {
   *         fields: "fields",
   *         include_fields: true
   *     })
   */
  get(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
  }
  __get(id_1) {
    return __awaiter123(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      const { fields, include_fields: includeFields } = request;
      const _queryParams = {};
      if (fields !== void 0) {
        _queryParams["fields"] = fields;
      }
      if (includeFields !== void 0) {
        _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
      }
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
        url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
        timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
        maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/users/{id}");
    });
  }
  /**
   * Delete a user by user ID. This action cannot be undone. For Auth0 Dashboard instructions, see <a href="https://auth0.com/docs/manage-users/user-accounts/delete-users">Delete Users</a>.
   *
   * @param {string} id - ID of the user to delete.
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter123(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/users/{id}");
    });
  }
  /**
   * Update a user.
   *
   * These are the attributes that can be updated at the root level:
   *
   * <ul>
   *     <li>app_metadata</li>
   *     <li>blocked</li>
   *     <li>email</li>
   *     <li>email_verified</li>
   *     <li>family_name</li>
   *     <li>given_name</li>
   *     <li>name</li>
   *     <li>nickname</li>
   *     <li>password</li>
   *     <li>phone_number</li>
   *     <li>phone_verified</li>
   *     <li>picture</li>
   *     <li>username</li>
   *     <li>user_metadata</li>
   *     <li>verify_email</li>
   * </ul>
   *
   * Some considerations:
   * <ul>
   *     <li>The properties of the new object will replace the old ones.</li>
   *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
   *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
   *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
   *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
   *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the "Unblock a user" endpoint from the "User Blocks" API to change the user's state.</li>
   *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
   * </ul>
   *
   * <h5>Updating a field (non-metadata property)</h5>
   * To mark the email address of a user as verified, the body to send should be:
   * <pre><code>{ "email_verified": true }</code></pre>
   *
   * <h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
   * <pre><code>{ "user_metadata" : { "profileCode": 1479 } }</code></pre>
   *
   * To add the field <code>addresses</code> the body to send should be:
   * <pre><code>{ "user_metadata" : { "addresses": {"work_address": "100 Industrial Way"} }}</code></pre>
   *
   * The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
   *   "user_metadata": {
   *     "profileCode": 1479,
   *     "addresses": { "work_address": "100 Industrial Way" }
   *   }
   * }</code></pre>
   *
   * <h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>"home_address": "742 Evergreen Terrace"</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
   * <pre><code>{
   *   "user_metadata": {
   *     "addresses": {
   *       "work_address": "100 Industrial Way",
   *       "home_address": "742 Evergreen Terrace"
   *     }
   *   }
   * }</code></pre>
   *
   * The modified object ends up with the following <code>user_metadata</code> property:
   * <pre><code>{
   *   "user_metadata": {
   *     "profileCode": 1479,
   *     "addresses": {
   *       "work_address": "100 Industrial Way",
   *       "home_address": "742 Evergreen Terrace"
   *     }
   *   }
   * }</code></pre>
   *
   * @param {string} id - ID of the user to update.
   * @param {Management.UpdateUserRequestContent} request
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter123(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: _response.body, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/users/{id}");
    });
  }
  /**
   * Remove an existing multi-factor authentication (MFA) <a href="https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa">recovery code</a> and generate a new one. If a user cannot access the original device or account used for MFA enrollment, they can use a recovery code to authenticate.
   *
   * @param {string} id - ID of the user to regenerate a multi-factor authentication recovery code for.
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   *
   * @example
   *     await client.users.regenerateRecoveryCode("id")
   */
  regenerateRecoveryCode(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__regenerateRecoveryCode(id, requestOptions));
  }
  __regenerateRecoveryCode(id, requestOptions) {
    return __awaiter123(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/recovery-code-regeneration`),
        method: "POST",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/users/{id}/recovery-code-regeneration");
    });
  }
  /**
   * Revokes selected resources related to a user (sessions, refresh tokens, ...).
   *
   * @param {string} id - ID of the user.
   * @param {Management.RevokeUserAccessRequestContent} request
   * @param {UsersClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.users.revokeAccess("id")
   */
  revokeAccess(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__revokeAccess(id, request, requestOptions));
  }
  __revokeAccess(id_1) {
    return __awaiter123(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `users/${url_exports.encodePathParam(id)}/revoke-access`),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/users/{id}/revoke-access");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/verifiableCredentials/resources/verification/resources/templates/client/Client.mjs
var __awaiter124 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TemplatesClient3 = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  /**
   * List a verifiable credential templates.
   *
   * @param {Management.ListVerifiableCredentialTemplatesRequestParameters} request
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.verifiableCredentials.verification.templates.list({
   *         from: "from",
   *         take: 1
   *     })
   */
  list() {
    return __awaiter124(this, arguments, void 0, function* (request = {}, requestOptions) {
      const list = HttpResponsePromise.interceptFunction((request2) => __awaiter124(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { from: from_, take = 50 } = request2;
        const _queryParams = {};
        if (from_ !== void 0) {
          _queryParams["from"] = from_;
        }
        if (take !== void 0) {
          _queryParams["take"] = (_a = take === null || take === void 0 ? void 0 : take.toString()) !== null && _a !== void 0 ? _a : null;
        }
        const _authRequest = yield this._options.authProvider.getAuthRequest();
        let _headers = mergeHeaders(_authRequest.headers, (_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
        const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : fetcher)({
          url: url_exports.join((_e = (_d = yield Supplier.get(this._options.baseUrl)) !== null && _d !== void 0 ? _d : yield Supplier.get(this._options.environment)) !== null && _e !== void 0 ? _e : ManagementEnvironment.Default, "verifiable-credentials/verification/templates"),
          method: "GET",
          headers: _headers,
          queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
          timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1e3,
          maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
          abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
          fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
          logging: this._options.logging
        });
        if (_response.ok) {
          return {
            data: _response.body,
            rawResponse: _response.rawResponse
          };
        }
        if (_response.error.reason === "status-code") {
          switch (_response.error.statusCode) {
            case 400:
              throw new BadRequestError(_response.error.body, _response.rawResponse);
            case 401:
              throw new UnauthorizedError(_response.error.body, _response.rawResponse);
            case 403:
              throw new ForbiddenError(_response.error.body, _response.rawResponse);
            case 429:
              throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
            default:
              throw new ManagementError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse
              });
          }
        }
        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/verifiable-credentials/verification/templates");
      }));
      const dataWithRawResponse = yield list(request).withRawResponse();
      return new Page({
        response: dataWithRawResponse.data,
        rawResponse: dataWithRawResponse.rawResponse,
        hasNextPage: (response) => (response === null || response === void 0 ? void 0 : response.next) != null && !(typeof (response === null || response === void 0 ? void 0 : response.next) === "string" && (response === null || response === void 0 ? void 0 : response.next) === ""),
        getItems: (response) => {
          var _a;
          return (_a = response === null || response === void 0 ? void 0 : response.templates) !== null && _a !== void 0 ? _a : [];
        },
        loadPage: (response) => {
          return list(setObjectProperty(request, "from", response === null || response === void 0 ? void 0 : response.next));
        }
      });
    });
  }
  /**
   * Create a verifiable credential template.
   *
   * @param {Management.CreateVerifiableCredentialTemplateRequestContent} request
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.verifiableCredentials.verification.templates.create({
   *         name: "name",
   *         type: "type",
   *         dialect: "dialect",
   *         presentation: {
   *             "org.iso.18013.5.1.mDL": {
   *                 "org.iso.18013.5.1": {}
   *             }
   *         },
   *         well_known_trusted_issuers: "well_known_trusted_issuers"
   *     })
   */
  create(request, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
  }
  __create(request, requestOptions) {
    return __awaiter124(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, "verifiable-credentials/verification/templates"),
        method: "POST",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/verifiable-credentials/verification/templates");
    });
  }
  /**
   * Get a verifiable credential template.
   *
   * @param {string} id - ID of the template to retrieve.
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.NotFoundError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.verifiableCredentials.verification.templates.get("id")
   */
  get(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
  }
  __get(id, requestOptions) {
    return __awaiter124(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `verifiable-credentials/verification/templates/${url_exports.encodePathParam(id)}`),
        method: "GET",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 404:
            throw new NotFoundError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/verifiable-credentials/verification/templates/{id}");
    });
  }
  /**
   * Delete a verifiable credential template.
   *
   * @param {string} id - ID of the template to retrieve.
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.verifiableCredentials.verification.templates.delete("id")
   */
  delete(id, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
  }
  __delete(id, requestOptions) {
    return __awaiter124(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `verifiable-credentials/verification/templates/${url_exports.encodePathParam(id)}`),
        method: "DELETE",
        headers: _headers,
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return { data: void 0, rawResponse: _response.rawResponse };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/verifiable-credentials/verification/templates/{id}");
    });
  }
  /**
   * Update a verifiable credential template.
   *
   * @param {string} id - ID of the template to retrieve.
   * @param {Management.UpdateVerifiableCredentialTemplateRequestContent} request
   * @param {TemplatesClient.RequestOptions} requestOptions - Request-specific configuration.
   *
   * @throws {@link Management.BadRequestError}
   * @throws {@link Management.UnauthorizedError}
   * @throws {@link Management.ForbiddenError}
   * @throws {@link Management.ConflictError}
   * @throws {@link Management.TooManyRequestsError}
   *
   * @example
   *     await client.verifiableCredentials.verification.templates.update("id")
   */
  update(id, request = {}, requestOptions) {
    return HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
  }
  __update(id_1) {
    return __awaiter124(this, arguments, void 0, function* (id, request = {}, requestOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const _authRequest = yield this._options.authProvider.getAuthRequest();
      let _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
      const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : fetcher)({
        url: url_exports.join((_d = (_c = yield Supplier.get(this._options.baseUrl)) !== null && _c !== void 0 ? _c : yield Supplier.get(this._options.environment)) !== null && _d !== void 0 ? _d : ManagementEnvironment.Default, `verifiable-credentials/verification/templates/${url_exports.encodePathParam(id)}`),
        method: "PATCH",
        headers: _headers,
        contentType: "application/json",
        queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
        requestType: "json",
        body: request,
        timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1e3,
        maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
        abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
        fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
        logging: this._options.logging
      });
      if (_response.ok) {
        return {
          data: _response.body,
          rawResponse: _response.rawResponse
        };
      }
      if (_response.error.reason === "status-code") {
        switch (_response.error.statusCode) {
          case 400:
            throw new BadRequestError(_response.error.body, _response.rawResponse);
          case 401:
            throw new UnauthorizedError(_response.error.body, _response.rawResponse);
          case 403:
            throw new ForbiddenError(_response.error.body, _response.rawResponse);
          case 409:
            throw new ConflictError(_response.error.body, _response.rawResponse);
          case 429:
            throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
          default:
            throw new ManagementError({
              statusCode: _response.error.statusCode,
              body: _response.error.body,
              rawResponse: _response.rawResponse
            });
        }
      }
      return handleNonStatusCodeError(_response.error, _response.rawResponse, "PATCH", "/verifiable-credentials/verification/templates/{id}");
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/verifiableCredentials/resources/verification/client/Client.mjs
var VerificationClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get templates() {
    var _a;
    return (_a = this._templates) !== null && _a !== void 0 ? _a : this._templates = new TemplatesClient3(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/api/resources/verifiableCredentials/client/Client.mjs
var VerifiableCredentialsClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get verification() {
    var _a;
    return (_a = this._verification) !== null && _a !== void 0 ? _a : this._verification = new VerificationClient(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/Client.mjs
var ManagementClient = class {
  constructor(options) {
    this._options = normalizeClientOptionsWithAuth(options);
  }
  get actions() {
    var _a;
    return (_a = this._actions) !== null && _a !== void 0 ? _a : this._actions = new ActionsClient(this._options);
  }
  get branding() {
    var _a;
    return (_a = this._branding) !== null && _a !== void 0 ? _a : this._branding = new BrandingClient(this._options);
  }
  get clientGrants() {
    var _a;
    return (_a = this._clientGrants) !== null && _a !== void 0 ? _a : this._clientGrants = new ClientGrantsClient(this._options);
  }
  get clients() {
    var _a;
    return (_a = this._clients) !== null && _a !== void 0 ? _a : this._clients = new ClientsClient(this._options);
  }
  get connectionProfiles() {
    var _a;
    return (_a = this._connectionProfiles) !== null && _a !== void 0 ? _a : this._connectionProfiles = new ConnectionProfilesClient(this._options);
  }
  get connections() {
    var _a;
    return (_a = this._connections) !== null && _a !== void 0 ? _a : this._connections = new ConnectionsClient2(this._options);
  }
  get customDomains() {
    var _a;
    return (_a = this._customDomains) !== null && _a !== void 0 ? _a : this._customDomains = new CustomDomainsClient(this._options);
  }
  get deviceCredentials() {
    var _a;
    return (_a = this._deviceCredentials) !== null && _a !== void 0 ? _a : this._deviceCredentials = new DeviceCredentialsClient(this._options);
  }
  get emailTemplates() {
    var _a;
    return (_a = this._emailTemplates) !== null && _a !== void 0 ? _a : this._emailTemplates = new EmailTemplatesClient(this._options);
  }
  get eventStreams() {
    var _a;
    return (_a = this._eventStreams) !== null && _a !== void 0 ? _a : this._eventStreams = new EventStreamsClient(this._options);
  }
  get flows() {
    var _a;
    return (_a = this._flows) !== null && _a !== void 0 ? _a : this._flows = new FlowsClient(this._options);
  }
  get forms() {
    var _a;
    return (_a = this._forms) !== null && _a !== void 0 ? _a : this._forms = new FormsClient(this._options);
  }
  get userGrants() {
    var _a;
    return (_a = this._userGrants) !== null && _a !== void 0 ? _a : this._userGrants = new UserGrantsClient(this._options);
  }
  get hooks() {
    var _a;
    return (_a = this._hooks) !== null && _a !== void 0 ? _a : this._hooks = new HooksClient(this._options);
  }
  get jobs() {
    var _a;
    return (_a = this._jobs) !== null && _a !== void 0 ? _a : this._jobs = new JobsClient(this._options);
  }
  get logStreams() {
    var _a;
    return (_a = this._logStreams) !== null && _a !== void 0 ? _a : this._logStreams = new LogStreamsClient(this._options);
  }
  get logs() {
    var _a;
    return (_a = this._logs) !== null && _a !== void 0 ? _a : this._logs = new LogsClient(this._options);
  }
  get networkAcls() {
    var _a;
    return (_a = this._networkAcls) !== null && _a !== void 0 ? _a : this._networkAcls = new NetworkAclsClient(this._options);
  }
  get organizations() {
    var _a;
    return (_a = this._organizations) !== null && _a !== void 0 ? _a : this._organizations = new OrganizationsClient2(this._options);
  }
  get prompts() {
    var _a;
    return (_a = this._prompts) !== null && _a !== void 0 ? _a : this._prompts = new PromptsClient(this._options);
  }
  get refreshTokens() {
    var _a;
    return (_a = this._refreshTokens) !== null && _a !== void 0 ? _a : this._refreshTokens = new RefreshTokensClient(this._options);
  }
  get resourceServers() {
    var _a;
    return (_a = this._resourceServers) !== null && _a !== void 0 ? _a : this._resourceServers = new ResourceServersClient(this._options);
  }
  get roles() {
    var _a;
    return (_a = this._roles) !== null && _a !== void 0 ? _a : this._roles = new RolesClient2(this._options);
  }
  get rules() {
    var _a;
    return (_a = this._rules) !== null && _a !== void 0 ? _a : this._rules = new RulesClient(this._options);
  }
  get rulesConfigs() {
    var _a;
    return (_a = this._rulesConfigs) !== null && _a !== void 0 ? _a : this._rulesConfigs = new RulesConfigsClient(this._options);
  }
  get selfServiceProfiles() {
    var _a;
    return (_a = this._selfServiceProfiles) !== null && _a !== void 0 ? _a : this._selfServiceProfiles = new SelfServiceProfilesClient(this._options);
  }
  get sessions() {
    var _a;
    return (_a = this._sessions) !== null && _a !== void 0 ? _a : this._sessions = new SessionsClient(this._options);
  }
  get stats() {
    var _a;
    return (_a = this._stats) !== null && _a !== void 0 ? _a : this._stats = new StatsClient(this._options);
  }
  get supplementalSignals() {
    var _a;
    return (_a = this._supplementalSignals) !== null && _a !== void 0 ? _a : this._supplementalSignals = new SupplementalSignalsClient(this._options);
  }
  get tickets() {
    var _a;
    return (_a = this._tickets) !== null && _a !== void 0 ? _a : this._tickets = new TicketsClient(this._options);
  }
  get tokenExchangeProfiles() {
    var _a;
    return (_a = this._tokenExchangeProfiles) !== null && _a !== void 0 ? _a : this._tokenExchangeProfiles = new TokenExchangeProfilesClient(this._options);
  }
  get userAttributeProfiles() {
    var _a;
    return (_a = this._userAttributeProfiles) !== null && _a !== void 0 ? _a : this._userAttributeProfiles = new UserAttributeProfilesClient(this._options);
  }
  get userBlocks() {
    var _a;
    return (_a = this._userBlocks) !== null && _a !== void 0 ? _a : this._userBlocks = new UserBlocksClient(this._options);
  }
  get users() {
    var _a;
    return (_a = this._users) !== null && _a !== void 0 ? _a : this._users = new UsersClient3(this._options);
  }
  get anomaly() {
    var _a;
    return (_a = this._anomaly) !== null && _a !== void 0 ? _a : this._anomaly = new AnomalyClient(this._options);
  }
  get attackProtection() {
    var _a;
    return (_a = this._attackProtection) !== null && _a !== void 0 ? _a : this._attackProtection = new AttackProtectionClient(this._options);
  }
  get emails() {
    var _a;
    return (_a = this._emails) !== null && _a !== void 0 ? _a : this._emails = new EmailsClient(this._options);
  }
  get guardian() {
    var _a;
    return (_a = this._guardian) !== null && _a !== void 0 ? _a : this._guardian = new GuardianClient(this._options);
  }
  get keys() {
    var _a;
    return (_a = this._keys) !== null && _a !== void 0 ? _a : this._keys = new KeysClient2(this._options);
  }
  get riskAssessments() {
    var _a;
    return (_a = this._riskAssessments) !== null && _a !== void 0 ? _a : this._riskAssessments = new RiskAssessmentsClient(this._options);
  }
  get tenants() {
    var _a;
    return (_a = this._tenants) !== null && _a !== void 0 ? _a : this._tenants = new TenantsClient(this._options);
  }
  get verifiableCredentials() {
    var _a;
    return (_a = this._verifiableCredentials) !== null && _a !== void 0 ? _a : this._verifiableCredentials = new VerifiableCredentialsClient(this._options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/lib/models.mjs
var __awaiter125 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var JSONApiResponse = class _JSONApiResponse {
  constructor(data, headers, status, statusText) {
    this.data = data;
    this.headers = headers;
    this.status = status;
    this.statusText = statusText;
  }
  static fromResponse(raw) {
    return __awaiter125(this, void 0, void 0, function* () {
      const value = yield raw.json();
      return new _JSONApiResponse(value, raw.headers, raw.status, raw.statusText);
    });
  }
};
var VoidApiResponse = class _VoidApiResponse {
  constructor(headers, status, statusText) {
    this.headers = headers;
    this.status = status;
    this.statusText = statusText;
  }
  static fromResponse(raw) {
    return __awaiter125(this, void 0, void 0, function* () {
      return new _VoidApiResponse(raw.headers, raw.status, raw.statusText);
    });
  }
};
var TextApiResponse = class _TextApiResponse {
  constructor(data, headers, status, statusText) {
    this.data = data;
    this.headers = headers;
    this.status = status;
    this.statusText = statusText;
  }
  static fromResponse(raw) {
    return __awaiter125(this, void 0, void 0, function* () {
      const value = yield raw.text();
      return new _TextApiResponse(value, raw.headers, raw.status, raw.statusText);
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/lib/errors.mjs
var ResponseError = class extends Error {
  constructor(statusCode, body, headers, msg) {
    super(msg);
    this.statusCode = statusCode;
    this.body = body;
    this.headers = headers;
    this.name = "ResponseError";
  }
};
var TimeoutError = class extends Error {
  constructor() {
    super("The request was timed out.");
    this.name = "TimeoutError";
  }
};
var FetchError = class extends Error {
  constructor(cause, msg) {
    super(msg);
    this.cause = cause;
    this.name = "FetchError";
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/lib/retry.mjs
var __awaiter126 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MAX_REQUEST_RETRY_JITTER = 250;
var MAX_REQUEST_RETRY_DELAY = 1e4;
var DEFAULT_NUMBER_RETRIES = 3;
var MAX_NUMBER_RETRIES = 10;
var BASE_DELAY = 500;
function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min) + min);
}
function pause(delay) {
  return __awaiter126(this, void 0, void 0, function* () {
    return new Promise((resolve) => setTimeout(resolve, delay));
  });
}
function retry(action, { maxRetries, retryWhen }) {
  const nrOfTriesToAttempt = Math.min(MAX_NUMBER_RETRIES, maxRetries !== null && maxRetries !== void 0 ? maxRetries : DEFAULT_NUMBER_RETRIES);
  let nrOfTries = 0;
  const retryAndWait = () => __awaiter126(this, void 0, void 0, function* () {
    let result;
    result = yield action();
    if ((retryWhen || [429]).includes(result.status) && nrOfTries < nrOfTriesToAttempt) {
      nrOfTries++;
      let wait = BASE_DELAY * Math.pow(2, nrOfTries - 1);
      wait = getRandomInt(wait + 1, wait + MAX_REQUEST_RETRY_JITTER);
      wait = Math.min(wait, MAX_REQUEST_RETRY_DELAY);
      yield pause(wait);
      result = yield retryAndWait();
    }
    return result;
  });
  return retryAndWait();
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/lib/runtime.mjs
var __awaiter127 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BaseAPI = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.fetchWithTimeout = (url, init) => __awaiter127(this, void 0, void 0, function* () {
      const controller = new AbortController();
      const timeout = setTimeout(() => {
        controller.abort();
      }, this.timeoutDuration);
      try {
        return yield this.fetchApi(url, Object.assign({ signal: controller.signal }, init));
      } catch (e) {
        if (e.name === "AbortError") {
          throw new TimeoutError();
        }
        throw e;
      } finally {
        clearTimeout(timeout);
      }
    });
    this.fetch = (url, init) => __awaiter127(this, void 0, void 0, function* () {
      var _a;
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchWithTimeout }, fetchParams))) || fetchParams;
        }
      }
      let response = void 0;
      let error = void 0;
      try {
        response = ((_a = this.configuration.retry) === null || _a === void 0 ? void 0 : _a.enabled) !== false ? yield retry(() => this.fetchWithTimeout(fetchParams.url, fetchParams.init), Object.assign({}, this.configuration.retry)) : yield this.fetchWithTimeout(fetchParams.url, fetchParams.init);
      } catch (e) {
        error = e;
      }
      if (error || !response.ok) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = (yield middleware.onError(Object.assign(Object.assign({ fetch: this.fetchWithTimeout }, fetchParams), { error, response: response ? response.clone() : void 0 }))) || response;
          }
        }
        if (response === void 0) {
          throw new FetchError(error, "The request failed and the interceptors did not return an alternative response");
        }
      } else {
        for (const middleware of this.middleware) {
          if (middleware.post) {
            response = (yield middleware.post(Object.assign(Object.assign({ fetch: this.fetchApi }, fetchParams), { response: response.clone() }))) || response;
          }
        }
      }
      return response;
    });
    if (configuration.baseUrl === null || configuration.baseUrl === void 0) {
      throw new Error("Must provide a base URL for the API");
    }
    if ("string" !== typeof configuration.baseUrl || configuration.baseUrl.length === 0) {
      throw new Error("The provided base URL is invalid");
    }
    this.middleware = configuration.middleware || [];
    this.fetchApi = configuration.fetch || globalThis.fetch.bind(globalThis);
    this.parseError = configuration.parseError;
    this.timeoutDuration = typeof configuration.timeoutDuration === "number" ? configuration.timeoutDuration : 1e4;
  }
  request(context, initOverrides) {
    return __awaiter127(this, void 0, void 0, function* () {
      const { url, init } = yield this.createFetchParams(context, initOverrides);
      const response = yield this.fetch(url, init);
      if (response && response.status >= 200 && response.status < 300) {
        return response;
      }
      const error = yield this.parseError(response);
      throw error;
    });
  }
  createFetchParams(context, initOverrides) {
    return __awaiter127(this, void 0, void 0, function* () {
      let url = this.configuration.baseUrl + context.path;
      if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
        url += `?${querystring(context.query)}`;
      }
      const headers = Object.assign({}, this.configuration.headers, context.headers);
      Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
      const initOverrideFn = typeof initOverrides === "function" ? initOverrides : () => __awaiter127(this, void 0, void 0, function* () {
        return initOverrides;
      });
      const initParams = {
        method: context.method,
        headers,
        body: context.body,
        dispatcher: this.configuration.agent
      };
      const overriddenInit = Object.assign(Object.assign({}, initParams), yield initOverrideFn({
        init: initParams,
        context
      }));
      const init = Object.assign(Object.assign({}, overriddenInit), { body: overriddenInit.body instanceof FormData || overriddenInit.body instanceof URLSearchParams || overriddenInit.body instanceof Blob ? overriddenInit.body : JSON.stringify(overriddenInit.body) });
      return { url, init };
    });
  }
};
function querystring(params) {
  return Object.keys(params).map((key) => querystringSingleKey(key, params[key])).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey(key, value) {
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(key)}=`);
    return `${encodeURIComponent(key)}=${multiValue}`;
  }
  return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
}
function validateRequiredRequestParams(requestParameters, keys) {
  keys.forEach((key) => {
    if (requestParameters[key] === null || requestParameters[key] === void 0) {
      throw new RequiredError(key, `Required parameter requestParameters.${key} was null or undefined.`);
    }
  });
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
};
var decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch (_a) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/util/errors.js
var JOSEError = class extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message2) {
    var _a;
    super(message2);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
  }
};
var JWTClaimValidationFailed = class extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message2, claim = "unspecified", reason = "unspecified") {
    super(message2);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
};
var JWTExpired = class extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message2, claim = "unspecified", reason = "unspecified") {
    super(message2);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
};
var JOSEAlgNotAllowed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
var JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
};
var JWSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
};
var JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
};
var JWKSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_INVALID";
  }
  static get code() {
    return "ERR_JWKS_INVALID";
  }
};
var JWKSNoMatchingKey = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_NO_MATCHING_KEY";
    this.message = "no applicable key found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_NO_MATCHING_KEY";
  }
};
var JWKSMultipleMatchingKeys = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
    this.message = "multiple matching keys found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
};
var JWKSTimeout = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_TIMEOUT";
    this.message = "request timed out";
  }
  static get code() {
    return "ERR_JWKS_TIMEOUT";
  }
};
var JWSSignatureVerificationFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/random.js
var random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types2) => {
  return message("Key must be ", actual, ...types2);
};
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  return isCryptoKey(key);
};
var types = ["CryptoKey"];

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/asn1.js
var findOid = (keyData, oid, from = 0) => {
  if (from === 0) {
    oid.unshift(oid.length);
    oid.unshift(6);
  }
  let i = keyData.indexOf(oid[0], from);
  if (i === -1)
    return false;
  const sub = keyData.subarray(i, i + oid.length);
  if (sub.length !== oid.length)
    return false;
  return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
};
var getNamedCurve2 = (keyData) => {
  switch (true) {
    case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
      return "P-256";
    case findOid(keyData, [43, 129, 4, 0, 34]):
      return "P-384";
    case findOid(keyData, [43, 129, 4, 0, 35]):
      return "P-521";
    case findOid(keyData, [43, 101, 110]):
      return "X25519";
    case findOid(keyData, [43, 101, 111]):
      return "X448";
    case findOid(keyData, [43, 101, 112]):
      return "Ed25519";
    case findOid(keyData, [43, 101, 113]):
      return "Ed448";
    default:
      throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
  }
};
var genericImport = async (replace, keyFormat, pem, alg, options) => {
  var _a;
  let algorithm;
  let keyUsages;
  const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c) => c.charCodeAt(0)));
  const isPublic = keyFormat === "spki";
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
      };
      keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      const namedCurve = getNamedCurve2(keyData);
      algorithm = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
      keyUsages = isPublic ? [] : ["deriveBits"];
      break;
    }
    case "EdDSA":
      algorithm = { name: getNamedCurve2(keyData) };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
  }
  return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
};
var fromPKCS8 = (pem, alg, options) => {
  return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "oct": {
      switch (jwk.alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          algorithm = { name: "HMAC", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = ["sign", "verify"];
          break;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
          algorithm = { name: "AES-GCM" };
          keyUsages = ["encrypt", "decrypt"];
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
          algorithm = { name: "AES-KW" };
          keyUsages = ["wrapKey", "unwrapKey"];
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          algorithm = { name: "PBKDF2" };
          keyUsages = ["deriveBits"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse = async (jwk) => {
  var _a, _b;
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const rest = [
    algorithm,
    (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
    (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
  ];
  if (algorithm.name === "PBKDF2") {
    return webcrypto_default.subtle.importKey("raw", decode(jwk.k), ...rest);
  }
  const keyData = { ...jwk };
  delete keyData.alg;
  delete keyData.use;
  return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
};
var jwk_to_key_default = parse;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/key/import.js
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
  var _a;
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
      if (octAsKeyObject) {
        return jwk_to_key_default({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });
      }
      return decode(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck = (alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch (_a) {
    return false;
  }
};
var verify_default = verify;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch (_c) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = (date) => Math.floor(date.getTime() / 1e3);

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch (_a) {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  if (maxTokenAge !== void 0)
    requiredClaims.push("iat");
  if (audience !== void 0)
    requiredClaims.push("aud");
  if (subject !== void 0)
    requiredClaims.push("sub");
  if (issuer !== void 0)
    requiredClaims.push("iss");
  for (const claim of new Set(requiredClaims.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
  if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  return payload;
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/sign.js
var sign = async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign = class {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat(protectedHeader, encoder.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign = class {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === void 0) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jwt/produce.js
var ProduceJWT = class {
  constructor(payload) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jwt/sign.js
var SignJWT = class extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a;
    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject(key);
}
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
var LocalJWKSet = class {
  constructor(jwks) {
    this._cached = /* @__PURE__ */ new WeakMap();
    if (!isJWKSLike(jwks)) {
      throw new JWKSInvalid("JSON Web Key Set malformed");
    }
    this._jwks = clone(jwks);
  }
  async getKey(protectedHeader, token) {
    const { alg, kid } = { ...protectedHeader, ...token === null || token === void 0 ? void 0 : token.header };
    const kty = getKtyFromAlg(alg);
    const candidates = this._jwks.keys.filter((jwk2) => {
      let candidate = kty === jwk2.kty;
      if (candidate && typeof kid === "string") {
        candidate = kid === jwk2.kid;
      }
      if (candidate && typeof jwk2.alg === "string") {
        candidate = alg === jwk2.alg;
      }
      if (candidate && typeof jwk2.use === "string") {
        candidate = jwk2.use === "sig";
      }
      if (candidate && Array.isArray(jwk2.key_ops)) {
        candidate = jwk2.key_ops.includes("verify");
      }
      if (candidate && alg === "EdDSA") {
        candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
      }
      if (candidate) {
        switch (alg) {
          case "ES256":
            candidate = jwk2.crv === "P-256";
            break;
          case "ES256K":
            candidate = jwk2.crv === "secp256k1";
            break;
          case "ES384":
            candidate = jwk2.crv === "P-384";
            break;
          case "ES512":
            candidate = jwk2.crv === "P-521";
            break;
        }
      }
      return candidate;
    });
    const { 0: jwk, length } = candidates;
    if (length === 0) {
      throw new JWKSNoMatchingKey();
    } else if (length !== 1) {
      const error = new JWKSMultipleMatchingKeys();
      const { _cached } = this;
      error[Symbol.asyncIterator] = async function* () {
        for (const jwk2 of candidates) {
          try {
            yield await importWithAlgCache(_cached, jwk2, alg);
          } catch (_a) {
            continue;
          }
        }
      };
      throw error;
    }
    return importWithAlgCache(this._cached, jwk, alg);
  }
};
async function importWithAlgCache(cache, jwk, alg) {
  const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached[alg] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/fetch_jwks.js
var fetchJwks = async (url, timeout, options) => {
  let controller;
  let id;
  let timedOut = false;
  if (typeof AbortController === "function") {
    controller = new AbortController();
    id = setTimeout(() => {
      timedOut = true;
      controller.abort();
    }, timeout);
  }
  const response = await fetch(url.href, {
    signal: controller ? controller.signal : void 0,
    redirect: "manual",
    headers: options.headers
  }).catch((err) => {
    if (timedOut)
      throw new JWKSTimeout();
    throw err;
  });
  if (id !== void 0)
    clearTimeout(id);
  if (response.status !== 200) {
    throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
  }
  try {
    return await response.json();
  } catch (_a) {
    throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
  }
};
var fetch_jwks_default = fetchJwks;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
var RemoteJWKSet = class extends LocalJWKSet {
  constructor(url, options) {
    super({ keys: [] });
    this._jwks = void 0;
    if (!(url instanceof URL)) {
      throw new TypeError("url must be an instance of URL");
    }
    this._url = new URL(url.href);
    this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
    this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
    this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
    this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
  }
  coolingDown() {
    return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
  }
  fresh() {
    return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
  }
  async getKey(protectedHeader, token) {
    if (!this._jwks || !this.fresh()) {
      await this.reload();
    }
    try {
      return await super.getKey(protectedHeader, token);
    } catch (err) {
      if (err instanceof JWKSNoMatchingKey) {
        if (this.coolingDown() === false) {
          await this.reload();
          return super.getKey(protectedHeader, token);
        }
      }
      throw err;
    }
  }
  async reload() {
    if (this._pendingFetch && isCloudflareWorkers()) {
      this._pendingFetch = void 0;
    }
    this._pendingFetch || (this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json) => {
      if (!isJWKSLike(json)) {
        throw new JWKSInvalid("JSON Web Key Set malformed");
      }
      this._jwks = { keys: json.keys };
      this._jwksTimestamp = Date.now();
      this._pendingFetch = void 0;
    }).catch((err) => {
      this._pendingFetch = void 0;
      throw err;
    }));
    await this._pendingFetch;
  }
};
function createRemoteJWKSet(url, options) {
  const set = new RemoteJWKSet(url, options);
  return async function(protectedHeader, token) {
    return set.getKey(protectedHeader, token);
  };
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode2
});
var encode2 = encode;
var decode2 = decode;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/util/decode_protected_header.js
function decodeProtectedHeader(token) {
  let protectedB64u;
  if (typeof token === "string") {
    const parts = token.split(".");
    if (parts.length === 3 || parts.length === 5) {
      ;
      [protectedB64u] = parts;
    }
  } else if (typeof token === "object" && token) {
    if ("protected" in token) {
      protectedB64u = token.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error();
    }
    const result = JSON.parse(decoder.decode(decode2(protectedB64u)));
    if (!isObject(result)) {
      throw new Error();
    }
    return result;
  } catch (_a) {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch (_a) {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch (_b) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/parse.js
function parse2(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default = parse2;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if (namespace?.length !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL2;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default = sha1;

// node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL2;

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/auth/client-authentication.mjs
var __awaiter128 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var addClientAuthentication = (_a) => __awaiter128(void 0, [_a], void 0, function* ({ payload, domain, clientId, clientAssertionSigningKey, clientAssertionSigningAlg, clientSecret, useMTLS }) {
  const cid = payload.client_id || clientId;
  if (clientAssertionSigningKey && !payload.client_assertion) {
    const alg = clientAssertionSigningAlg || "RS256";
    const privateKey = yield importPKCS8(clientAssertionSigningKey, alg);
    payload.client_assertion = yield new SignJWT({}).setProtectedHeader({ alg }).setIssuedAt().setSubject(cid).setJti(v4_default()).setIssuer(cid).setAudience(`https://${domain}/`).setExpirationTime("2mins").sign(privateKey);
    payload.client_assertion_type = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer";
  } else if (clientSecret && !payload.client_secret) {
    payload.client_secret = clientSecret;
  }
  if ((!payload.client_secret || payload.client_secret.trim().length === 0) && (!payload.client_assertion || payload.client_assertion.trim().length === 0) && !useMTLS) {
    throw new Error("The client_secret or client_assertion field is required, or it should be mTLS request.");
  }
  return payload;
});

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/version.mjs
var SDK_VERSION = "5.2.0";

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/utils.mjs
var generateClientInfo = () => {
  var _a, _b;
  const runtimeType = (_a = RUNTIME === null || RUNTIME === void 0 ? void 0 : RUNTIME.type) !== null && _a !== void 0 ? _a : "unknown";
  const runtimeKey = runtimeType === "workerd" ? "cloudflare-workers" : runtimeType;
  const runtimeVersion = (_b = RUNTIME === null || RUNTIME === void 0 ? void 0 : RUNTIME.version) !== null && _b !== void 0 ? _b : "unknown";
  return {
    name: "node-auth0",
    version: SDK_VERSION,
    env: {
      [runtimeKey]: runtimeVersion
    }
  };
};
var mtlsPrefix = "mtls";

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/lib/middleware/auth0-client-telemetry.mjs
var __awaiter129 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Auth0ClientTelemetry = class {
  constructor(options) {
    this.clientInfo = options.clientInfo || generateClientInfo();
  }
  /**
   * Get the Auth0-Client header value for telemetry.
   * This method can be used when you need to manually add telemetry headers
   * instead of using the middleware system.
   */
  getAuth0ClientHeader() {
    if ("string" === typeof this.clientInfo.name && this.clientInfo.name.length > 0) {
      return base64url_exports2.encode(JSON.stringify(this.clientInfo));
    }
    return void 0;
  }
  pre(context) {
    return __awaiter129(this, void 0, void 0, function* () {
      const headerValue = this.getAuth0ClientHeader();
      if (headerValue) {
        context.init.headers = Object.assign(Object.assign({}, context.init.headers), { "Auth0-Client": headerValue });
      }
      return {
        url: context.url,
        init: context.init
      };
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/auth/base-auth-api.mjs
var __awaiter130 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AuthApiError = class extends Error {
  constructor(error, error_description, statusCode, body, headers) {
    super(error_description || error);
    this.error = error;
    this.error_description = error_description;
    this.statusCode = statusCode;
    this.body = body;
    this.headers = headers;
    this.name = "AuthApiError";
  }
};
function parseErrorBody(body) {
  const rawData = JSON.parse(body);
  let data;
  if (rawData.error) {
    data = rawData;
  } else {
    data = {
      error: rawData.code,
      error_description: rawData.description
    };
  }
  return data;
}
function parseError(response) {
  return __awaiter130(this, void 0, void 0, function* () {
    const body = yield response.text();
    try {
      const data = parseErrorBody(body);
      return new AuthApiError(data.error, data.error_description, response.status, body, response.headers);
    } catch (_a) {
      return new ResponseError(response.status, body, response.headers, "Response returned an error code");
    }
  });
}
var BaseAuthAPI = class extends BaseAPI {
  constructor(options) {
    super(Object.assign(Object.assign({}, options), { baseUrl: `https://${options.domain}`, middleware: options.telemetry !== false ? [new Auth0ClientTelemetry(options)] : [], parseError, retry: Object.assign({ enabled: false }, options.retry) }));
    this.domain = options.domain;
    this.clientId = options.clientId;
    this.clientSecret = options.clientSecret;
    this.clientAssertionSigningKey = options.clientAssertionSigningKey;
    this.clientAssertionSigningAlg = options.clientAssertionSigningAlg;
    this.useMTLS = options.useMTLS;
  }
  /**
   * @private
   */
  addClientAuthentication(payload) {
    return __awaiter130(this, void 0, void 0, function* () {
      return addClientAuthentication({
        payload,
        domain: this.domain,
        clientId: this.clientId,
        clientSecret: this.clientSecret,
        clientAssertionSigningKey: this.clientAssertionSigningKey,
        clientAssertionSigningAlg: this.clientAssertionSigningAlg,
        useMTLS: this.useMTLS
      });
    });
  }
};
function grant(grantType_1, bodyParameters_1) {
  return __awaiter130(this, arguments, void 0, function* (grantType, bodyParameters, { idTokenValidateOptions, initOverrides } = {}, clientId, idTokenValidator, request) {
    const response = yield request({
      path: "/oauth/token",
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams(Object.assign(Object.assign({ client_id: clientId }, bodyParameters), { grant_type: grantType }))
    }, initOverrides);
    const res = yield JSONApiResponse.fromResponse(response);
    if (res.data.id_token) {
      yield idTokenValidator.validate(res.data.id_token, idTokenValidateOptions);
    }
    return res;
  });
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/auth/backchannel.mjs
var __awaiter131 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var getLoginHint = (userId, domain) => {
  const trimmedDomain = domain.endsWith("/") ? domain.slice(0, -1) : domain;
  const loginHint = {
    format: "iss_sub",
    iss: `https://${trimmedDomain}/`,
    sub: `${userId}`
  };
  return JSON.stringify(loginHint);
};
var CIBA_GRANT_TYPE = "urn:openid:params:grant-type:ciba";
var CIBA_AUTHORIZE_URL = "/bc-authorize";
var CIBA_TOKEN_URL = "/oauth/token";
var Backchannel = class extends BaseAuthAPI {
  /**
   * Initiates a CIBA authorization request.
   *
   * @param {AuthorizeOptions} options - The options for the request.
   * @returns {Promise<AuthorizeResponse>} - The authorization response.
   *
   * @throws {Error} - If the request fails.
   */
  authorize(_a) {
    return __awaiter131(this, void 0, void 0, function* () {
      var { userId } = _a, options = __rest(_a, ["userId"]);
      const body = Object.assign(Object.assign({}, options), { login_hint: getLoginHint(userId, this.domain), client_id: this.clientId });
      const requestedExpiry = options.requested_expiry || options.request_expiry;
      if (requestedExpiry) {
        body.requested_expiry = requestedExpiry;
      }
      yield this.addClientAuthentication(body);
      const response = yield this.request.bind(this)({
        path: CIBA_AUTHORIZE_URL,
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams(body)
      }, {});
      const r = yield JSONApiResponse.fromResponse(response);
      return r.data;
    });
  }
  /**
   * Handles the backchannel grant flow for authentication. Client can poll this method at regular intervals to check if the backchannel auth request has been approved.
   *
   * @param {string} auth_req_id - The authorization request ID. This value is returned from the call to /bc-authorize. Once you have exchanged an auth_req_id for an ID and access token, it is no longer usable.
   * @returns {Promise<TokenResponse>} - A promise that resolves to the token response.
   *
   * @throws {Error} - Throws an error if the request fails.
   *
   * If the authorizing user has not yet approved or rejected the request, you will receive a response like this:
   * ```json
   * {
   *   "error": "authorization_pending",
   *   "error_description": "The end-user authorization is pending"
   * }
   * ```
   *
   * If the authorizing user rejects the request, you will receive a response like this:
   * ```json
   * {
   *   "error": "access_denied",
   *   "error_description": "The end-user denied the authorization request or it has been expired"
   * }
   * ```
   *
   * If you are polling too quickly (faster than the interval value returned from /bc-authorize), you will receive a response like this:
   * ```json
   * {
   *   "error": "slow_down",
   *   "error_description": "You are polling faster than allowed. Try again in 10 seconds."
   * }
   * ```
   */
  backchannelGrant(_a) {
    return __awaiter131(this, arguments, void 0, function* ({ auth_req_id }) {
      const body = {
        client_id: this.clientId,
        auth_req_id,
        grant_type: CIBA_GRANT_TYPE
      };
      yield this.addClientAuthentication(body);
      const response = yield this.request.bind(this)({
        path: CIBA_TOKEN_URL,
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams(body)
      }, {});
      const r = yield JSONApiResponse.fromResponse(response);
      return r.data;
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/auth/database.mjs
var __awaiter132 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Database = class extends BaseAuthAPI {
  /**
   * Given a user's credentials, and a connection, this endpoint will create a new user using active authentication.
   *
   * This endpoint only works for database connections.
   *
   * See: https://auth0.com/docs/api/authentication#signup
   *
   * @example
   * ```js
   * var data = {
   *   email: '{EMAIL}',
   *   password: '{PASSWORD}',
   *   connection: 'Username-Password-Authentication'
   * };
   *
   * await auth0.database.signUp(data);
   * ```
   */
  signUp(bodyParameters, initOverrides) {
    return __awaiter132(this, void 0, void 0, function* () {
      validateRequiredRequestParams(bodyParameters, ["email", "password", "connection"]);
      const response = yield this.request({
        path: "/dbconnections/signup",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: Object.assign({ client_id: this.clientId }, bodyParameters)
      }, initOverrides);
      const jsonResponse = yield JSONApiResponse.fromResponse(response);
      if (jsonResponse.data) {
        const data = jsonResponse.data;
        if (!data.id && (data._id || data.user_id)) {
          data.id = data._id || data.user_id;
        }
      }
      return jsonResponse;
    });
  }
  /**
   * Given a user's email address and a connection, Auth0 will send a change password email.
   *
   * This endpoint only works for database connections.
   *
   * See: https://auth0.com/docs/api/authentication#change-password
   *
   * @example
   * ```js
   * var data = {
   *   email: '{EMAIL}',
   *   connection: 'Username-Password-Authentication'
   * };
   *
   * await auth0.database.changePassword(data);
   * ```
   */
  changePassword(bodyParameters, initOverrides) {
    return __awaiter132(this, void 0, void 0, function* () {
      validateRequiredRequestParams(bodyParameters, ["email", "connection"]);
      const response = yield this.request({
        path: "/dbconnections/change_password",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: Object.assign({ client_id: this.clientId }, bodyParameters)
      }, initOverrides);
      return TextApiResponse.fromResponse(response);
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/auth/id-token-validator.mjs
var __awaiter133 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_CLOCK_TOLERANCE = 60;
var IdTokenValidatorError = class extends Error {
};
var IDTokenValidator = class {
  constructor({ domain, clientId, clientSecret, headers, timeoutDuration, idTokenSigningAlg = "RS256", clockTolerance = DEFAULT_CLOCK_TOLERANCE }) {
    this.jwks = createRemoteJWKSet(new URL(`https://${domain}/.well-known/jwks.json`), {
      timeoutDuration,
      headers
    });
    this.alg = idTokenSigningAlg;
    this.audience = clientId;
    this.secret = new TextEncoder().encode(clientSecret);
    this.issuer = `https://${domain}/`;
    this.clockTolerance = clockTolerance;
  }
  validate(idToken_1) {
    return __awaiter133(this, arguments, void 0, function* (idToken, { nonce, maxAge, organization } = {}) {
      const secret = this.alg === "HS256" ? this.secret : this.jwks;
      const header = decodeProtectedHeader(idToken);
      const payload = decodeJwt(idToken);
      if (header.alg !== "RS256" && header.alg !== "HS256") {
        throw new Error(`Signature algorithm of "${header.alg}" is not supported. Expected the ID token to be signed with "RS256" or "HS256".`);
      }
      if (!payload.iss || typeof payload.iss !== "string") {
        throw new IdTokenValidatorError("Issuer (iss) claim must be a string present in the ID token");
      }
      if (payload.iss !== this.issuer) {
        throw new IdTokenValidatorError(`Issuer (iss) claim mismatch in the ID token; expected "${this.issuer}", found "${payload.iss}"`);
      }
      if (!payload.sub || typeof payload.sub !== "string") {
        throw new IdTokenValidatorError("Subject (sub) claim must be a string present in the ID token");
      }
      if (!payload.aud || !(typeof payload.aud === "string" || Array.isArray(payload.aud))) {
        throw new IdTokenValidatorError("Audience (aud) claim must be a string or array of strings present in the ID token");
      }
      if (Array.isArray(payload.aud) && !payload.aud.includes(this.audience)) {
        throw new IdTokenValidatorError(`Audience (aud) claim mismatch in the ID token; expected "${this.audience}" but was not one of "${payload.aud.join(", ")}"`);
      } else if (typeof payload.aud === "string" && payload.aud !== this.audience) {
        throw new IdTokenValidatorError(`Audience (aud) claim mismatch in the ID token; expected "${this.audience}" but found "${payload.aud}"`);
      }
      if (organization) {
        if (organization.indexOf("org_") === 0) {
          if (!payload.org_id || typeof payload.org_id !== "string") {
            throw new Error("Organization Id (org_id) claim must be a string present in the ID token");
          }
        } else {
          if (!payload.org_name || typeof payload.org_name !== "string") {
            throw new Error("Organization Name (org_name) claim must be a string present in the ID token");
          }
        }
      }
      const now = Math.floor(Date.now() / 1e3);
      if (!payload.exp || typeof payload.exp !== "number") {
        throw new IdTokenValidatorError("Expiration Time (exp) claim must be a number present in the ID token");
      }
      const expTime = payload.exp + this.clockTolerance;
      if (now > expTime) {
        throw new IdTokenValidatorError(`Expiration Time (exp) claim error in the ID token; current time (${now}) is after expiration time (${expTime})`);
      }
      if (!payload.iat || typeof payload.iat !== "number") {
        throw new IdTokenValidatorError("Issued At (iat) claim must be a number present in the ID token");
      }
      if (nonce || payload.nonce) {
        if (!payload.nonce || typeof payload.nonce !== "string") {
          throw new IdTokenValidatorError("Nonce (nonce) claim must be a string present in the ID token");
        }
        if (payload.nonce !== nonce) {
          throw new IdTokenValidatorError(`Nonce (nonce) claim mismatch in the ID token; expected "${nonce}", found "${payload.nonce}"`);
        }
      }
      if (Array.isArray(payload.aud) && payload.aud.length > 1) {
        if (!payload.azp || typeof payload.azp !== "string") {
          throw new IdTokenValidatorError("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
        }
        if (payload.azp !== this.audience) {
          throw new IdTokenValidatorError(`Authorized Party (azp) claim mismatch in the ID token; expected "${this.audience}", found "${payload.azp}"`);
        }
      }
      if (maxAge) {
        if (!payload.auth_time || typeof payload.auth_time !== "number") {
          throw new IdTokenValidatorError("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
        }
        const authValidUntil = payload.auth_time + maxAge + this.clockTolerance;
        if (now > authValidUntil) {
          throw new IdTokenValidatorError(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Currrent time (${now}) is after last auth at ${authValidUntil}`);
        }
      }
      yield jwtVerify(idToken, secret, {
        issuer: this.issuer,
        audience: this.audience,
        clockTolerance: this.clockTolerance,
        maxTokenAge: maxAge,
        algorithms: ["HS256", "RS256"]
      });
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/auth/oauth.mjs
var __awaiter134 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SUBJECT_TOKEN_TYPES;
(function(SUBJECT_TOKEN_TYPES2) {
  SUBJECT_TOKEN_TYPES2["REFRESH_TOKEN"] = "urn:ietf:params:oauth:token-type:refresh_token";
  SUBJECT_TOKEN_TYPES2["ACCESS_TOKEN"] = "urn:ietf:params:oauth:token-type:access_token";
})(SUBJECT_TOKEN_TYPES || (SUBJECT_TOKEN_TYPES = {}));
var TOKEN_FOR_CONNECTION_GRANT_TYPE = "urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token";
var TOKEN_FOR_CONNECTION_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:refresh_token";
var TOKEN_FOR_CONNECTION_REQUESTED_TOKEN_TYPE = "http://auth0.com/oauth/token-type/federated-connection-access-token";
var TOKEN_URL = "/oauth/token";
var OAuth = class extends BaseAuthAPI {
  constructor(options) {
    super(Object.assign(Object.assign({}, options), { domain: options.useMTLS ? `${mtlsPrefix}.${options.domain}` : options.domain }));
    this.idTokenValidator = new IDTokenValidator(options);
  }
  /**
   * This is the flow that regular web apps use to access an API.
   *
   * Use this endpoint to exchange an Authorization Code for a Token.
   *
   * See: https://auth0.com/docs/api/authentication#authorization-code-flow44
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.authorizationCodeGrant({ code: 'mycode' });
   * ```
   */
  authorizationCodeGrant(bodyParameters_1) {
    return __awaiter134(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["code"]);
      return grant("authorization_code", yield this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
    });
  }
  /**
   * PKCE was originally designed to protect the authorization code flow in mobile apps,
   * but its ability to prevent authorization code injection makes it useful for every type of OAuth client,
   * even web apps that use client authentication.
   *
   * See: https://auth0.com/docs/api/authentication#authorization-code-flow-with-pkce45
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.authorizationCodeGrantWithPKCE({
   *   code: 'mycode',
   *   code_verifier: 'mycodeverifier'
   * });
   * ```
   */
  authorizationCodeGrantWithPKCE(bodyParameters_1) {
    return __awaiter134(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["code", "code_verifier"]);
      return grant("authorization_code", yield this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
    });
  }
  /**
   * This is the OAuth 2.0 grant that server processes use to access an API.
   *
   * Use this endpoint to directly request an Access Token by using the Client's credentials
   * (a Client ID and a Client Secret or a Client Assertion).
   *
   * See: https://auth0.com/docs/api/authentication#client-credentials-flow
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.clientCredentialsGrant({ audience: 'myaudience' });
   * ```
   */
  clientCredentialsGrant(bodyParameters_1) {
    return __awaiter134(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["audience"]);
      return grant("client_credentials", yield this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
    });
  }
  /**
   * This is the OAuth 2.0 extension that allows to initiate an OAuth flow from the backchannel instead of by building a URL.
   *
   *
   * See: https://www.rfc-editor.org/rfc/rfc9126.html
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.pushedAuthorization({ response_type: 'id_token', redirect_uri: 'http://localhost' });
   * ```
   */
  pushedAuthorization(bodyParameters_1) {
    return __awaiter134(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["client_id", "response_type", "redirect_uri"]);
      const bodyParametersWithClientAuthentication = yield this.addClientAuthentication(bodyParameters);
      const response = yield this.request({
        path: "/oauth/par",
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams(Object.assign({ client_id: this.clientId }, bodyParametersWithClientAuthentication))
      }, options.initOverrides);
      return JSONApiResponse.fromResponse(response);
    });
  }
  /**
   * This information is typically received from a highly trusted public client like a SPA*.
   * (<strong>*Note:</string> For single-page applications and native/mobile apps, we recommend using web flows instead.)
   *
   * See: https://auth0.com/docs/api/authentication#resource-owner-password
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId'
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.passwordGrant({
   *     username: 'myusername@example.com',
   *     password: 'mypassword'
   *   },
   *   { initOverrides: { headers: { 'auth0-forwarded-for': 'END.USER.IP.123' } } }
   * );
   * ```
   *
   * Set the'auth0-forwarded-for' header to the end-user IP as a string value if you want
   * brute-force protection to work in server-side scenarios.
   *
   * See https://auth0.com/docs/get-started/authentication-and-authorization-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection
   *
   */
  passwordGrant(bodyParameters_1) {
    return __awaiter134(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["username", "password"]);
      return grant(bodyParameters.realm ? "http://auth0.com/oauth/grant-type/password-realm" : "password", yield this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
    });
  }
  /**
   * Use this endpoint to refresh an Access Token using the Refresh Token you got during authorization.
   *
   * See: https://auth0.com/docs/api/authentication#refresh-token
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId'
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.refreshTokenGrant({ refresh_token: 'myrefreshtoken' })
   * ```
   */
  refreshTokenGrant(bodyParameters_1) {
    return __awaiter134(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["refresh_token"]);
      return grant("refresh_token", yield this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
    });
  }
  /**
   * Use this endpoint to invalidate a Refresh Token if it has been compromised.
   *
   * The behaviour of this endpoint depends on the state of the <a href="https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens#refresh-tokens-and-grants">Refresh Token Revocation Deletes Grant</a> toggle.
   * If this toggle is enabled, then each revocation request invalidates not only the specific token, but all other tokens based on the same authorization grant.
   * This means that all Refresh Tokens that have been issued for the same user, application, and audience will be revoked.
   * If this toggle is disabled, then only the refresh token is revoked, while the grant is left intact.
   *
   * See: https://auth0.com/docs/api/authentication#revoke-refresh-token
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId'
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.revokeRefreshToken({ token: 'myrefreshtoken' })
   * ```
   */
  revokeRefreshToken(bodyParameters_1) {
    return __awaiter134(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["token"]);
      const response = yield this.request({
        path: "/oauth/revoke",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: yield this.addClientAuthentication(Object.assign({ client_id: this.clientId }, bodyParameters))
      }, options.initOverrides);
      return VoidApiResponse.fromResponse(response);
    });
  }
  /**
   * Exchanges a subject token for an access token for the connection.
   *
   * The request body includes:
   * - client_id (and client_secret/client_assertion via addClientAuthentication)
   * - grant_type set to `urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token`
   * - subject_token: the token to exchange
   * - subject_token_type: the type of token being exchanged. Defaults to refresh tokens (`urn:ietf:params:oauth:token-type:refresh_token`).
   * - requested_token_type (`http://auth0.com/oauth/token-type/federated-connection-access-token`) indicating that a federated connection access token is desired
   * - connection name and an optional `login_hint` if provided
   *
   * @param bodyParameters - The options to retrieve a token for a connection.
   * @returns A promise with the token response data.
   * @throws An error if the exchange fails.
   */
  tokenForConnection(bodyParameters_1) {
    return __awaiter134(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["connection", "subject_token"]);
      const body = Object.assign(Object.assign({ subject_token_type: SUBJECT_TOKEN_TYPES.REFRESH_TOKEN }, bodyParameters), { grant_type: TOKEN_FOR_CONNECTION_GRANT_TYPE, requested_token_type: TOKEN_FOR_CONNECTION_REQUESTED_TOKEN_TYPE });
      yield this.addClientAuthentication(body);
      const response = yield this.request({
        path: TOKEN_URL,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams(body)
      }, options.initOverrides);
      return JSONApiResponse.fromResponse(response);
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/auth/passwordless.mjs
var __awaiter135 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Passwordless = class extends BaseAuthAPI {
  constructor(configuration) {
    super(configuration);
    this.idTokenValidator = new IDTokenValidator(configuration);
  }
  /**
   * Start passwordless flow sending an email.
   *
   * Given the user `email` address, it will send an email with:
   *
   * <ul>
   *   <li>A link (default, `send:"link"`). You can then authenticate with this
   *     user opening the link and he will be automatically logged in to the
   *     application. Optionally, you can append/override parameters to the link
   *     (like `scope`, `redirect_uri`, `protocol`, `response_type`, etc.) using
   *     `authParams` object.
   *   </li>
   *   <li>
   *     A verification code (`send:"code"`). You can then authenticate with
   *     this user using the `/oauth/token` endpoint specifying `email` as
   *     `username` and `code` as `password`.
   *   </li>
   * </ul>
   *
   * See: https://auth0.com/docs/api/authentication#get-code-or-link
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.passwordless.sendEmail({
   *   email: '{EMAIL}',
   *   send: 'link',
   *   authParams: {} // Optional auth params.
   * });
   * ```
   */
  sendEmail(bodyParameters, initOverrides) {
    return __awaiter135(this, void 0, void 0, function* () {
      validateRequiredRequestParams(bodyParameters, ["email"]);
      const response = yield this.request({
        path: "/passwordless/start",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: yield this.addClientAuthentication(Object.assign({ client_id: this.clientId, connection: "email" }, bodyParameters))
      }, initOverrides);
      return VoidApiResponse.fromResponse(response);
    });
  }
  /**
   * Start passwordless flow sending an SMS.
   *
   * Given the user `phone_number`, it will send a SMS message with a
   * verification code. You can then authenticate with this user using the
   * `/oauth/token` endpoint specifying `phone_number` as `username` and `code` as
   * `password`:
   *
   * See: https://auth0.com/docs/api/authentication#get-code-or-link
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.passwordless.sendSMS({
   *   phone_number: '{PHONE}'
   * });
   * ```
   */
  sendSMS(bodyParameters, initOverrides) {
    return __awaiter135(this, void 0, void 0, function* () {
      validateRequiredRequestParams(bodyParameters, ["phone_number"]);
      const response = yield this.request({
        path: "/passwordless/start",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: yield this.addClientAuthentication(Object.assign({ client_id: this.clientId, connection: "sms" }, bodyParameters))
      }, initOverrides);
      return VoidApiResponse.fromResponse(response);
    });
  }
  /**
   * Once you have a verification code, use this endpoint to login the user with their email and verification code.
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.passwordless.loginWithEmail({
   *   email: 'foo@example.com',
   *   code: 'ABC123'
   * });
   * ```
   */
  loginWithEmail(bodyParameters_1) {
    return __awaiter135(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["email", "code"]);
      const { email: username, code: otp } = bodyParameters, otherParams = __rest2(bodyParameters, ["email", "code"]);
      return grant("http://auth0.com/oauth/grant-type/passwordless/otp", yield this.addClientAuthentication(Object.assign({
        username,
        otp,
        realm: "email"
      }, otherParams)), options, this.clientId, this.idTokenValidator, this.request.bind(this));
    });
  }
  /**
   * Once you have a verification code, use this endpoint to login the user with their phone number and verification code.
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.passwordless.loginWithSMS({
   *   phone_number: '0777777777',
   *   code: 'ABC123'
   * });
   * ```
   */
  loginWithSMS(bodyParameters_1) {
    return __awaiter135(this, arguments, void 0, function* (bodyParameters, options = {}) {
      validateRequiredRequestParams(bodyParameters, ["phone_number", "code"]);
      const { phone_number: username, code: otp } = bodyParameters, otherParams = __rest2(bodyParameters, ["phone_number", "code"]);
      return grant("http://auth0.com/oauth/grant-type/passwordless/otp", yield this.addClientAuthentication(Object.assign({
        username,
        otp,
        realm: "sms"
      }, otherParams)), options, this.clientId, this.idTokenValidator, this.request.bind(this));
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/auth/tokenExchange.mjs
var __awaiter136 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TOKEN_EXCHANGE_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
var TOKEN_URL2 = "/oauth/token";
var CustomTokenExchange = class extends BaseAuthAPI {
  /**
   * Executes token exchange flow with security validations
   *
   * @param options - Exchange configuration parameters
   * @returns Auth0-issued tokens with requested claims
   *
   * @throws {Error} When:
   * - `subject_token_type` uses prohibited namespace
   * - Network failures occur
   * - Auth0 returns error responses (4xx/5xx)
   */
  exchangeToken(options) {
    return __awaiter136(this, void 0, void 0, function* () {
      const body = Object.assign(Object.assign({}, options), { grant_type: TOKEN_EXCHANGE_GRANT_TYPE, client_id: this.clientId });
      yield this.addClientAuthentication(body);
      const response = yield this.request({
        path: TOKEN_URL2,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams(body)
      }, {});
      const r = yield JSONApiResponse.fromResponse(response);
      return r.data;
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/auth/index.mjs
var AuthenticationClient = class {
  /**
   * Create a new Authentication API client
   * @param options - Configuration options for the client
   */
  constructor(options) {
    this.database = new Database(options);
    this.oauth = new OAuth(options);
    this.passwordless = new Passwordless(options);
    this.backchannel = new Backchannel(options);
    this.tokenExchange = new CustomTokenExchange(options);
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/wrapper/token-provider.mjs
var __awaiter137 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LEEWAY = 10 * 1e3;
var TokenProvider = class {
  constructor(options) {
    this.options = options;
    this.expiresAt = 0;
    this.accessToken = "";
    this.authenticationClient = new AuthenticationClient(Object.assign(Object.assign({}, options), { headers: void 0 }));
  }
  getAccessToken() {
    return __awaiter137(this, void 0, void 0, function* () {
      if (!this.accessToken || Date.now() > this.expiresAt - LEEWAY) {
        this.pending = this.pending || this.authenticationClient.oauth.clientCredentialsGrant({
          audience: this.options.audience
        });
        const { data: { access_token: accessToken, expires_in: expiresIn } } = yield this.pending.finally(() => {
          delete this.pending;
        });
        this.expiresAt = Date.now() + expiresIn * 1e3;
        this.accessToken = accessToken;
      }
      return this.accessToken;
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/request-options.mjs
var __awaiter138 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var WHITELISTED_PATTERNS = [
  "^/api/v2/jobs/verification-email$",
  "^/api/v2/tickets/email-verification$",
  "^/api/v2/tickets/password-change$",
  "^/api/v2/organizations/[^/]+/invitations$",
  "^/api/v2/users$",
  "^/api/v2/users/[^/]+$",
  "^/api/v2/guardian/enrollments/ticket$"
];
function compileWhitelistedPathPatterns() {
  return WHITELISTED_PATTERNS.map((pattern) => {
    try {
      return new RegExp(pattern);
    } catch (error) {
      console.warn(`[CustomDomainWhitelist] Invalid regex pattern: ${pattern}`, error);
      return /(?!)/;
    }
  });
}
var compiledWhitelistedPathRegexes = compileWhitelistedPathPatterns();
function isCustomDomainPathWhitelisted(path) {
  if (!path || typeof path !== "string") {
    return false;
  }
  return compiledWhitelistedPathRegexes.some((regex) => {
    try {
      return regex.test(path);
    } catch (error) {
      console.warn(`[CustomDomainWhitelist] Error testing regex against path: ${path}`, error);
      return false;
    }
  });
}
function CustomDomainHeader(domain) {
  return {
    headers: {
      "Auth0-Custom-Domain": domain
    }
  };
}
function withTimeout(seconds) {
  return {
    timeoutInSeconds: seconds
  };
}
function withRetries(retries) {
  return {
    maxRetries: retries
  };
}
function withHeaders(headers) {
  return {
    headers
  };
}
function withAbortSignal(signal) {
  return {
    abortSignal: signal
  };
}
function withCustomDomainHeader(domain, options) {
  if (!domain || typeof domain !== "string" || domain.trim().length === 0) {
    throw new Error("Domain parameter is required and must be a non-empty string");
  }
  const trimmedDomain = domain.trim();
  const originalFetcher = options.fetcher || fetcher;
  const customDomainFetcher = (args) => __awaiter138(this, void 0, void 0, function* () {
    if (!(args === null || args === void 0 ? void 0 : args.url)) {
      throw new Error("Invalid fetcher arguments: URL is required");
    }
    try {
      const url = new URL(args.url);
      const path = url.pathname;
      const formattedPath = path.startsWith("/api/v2/") ? path : `/api/v2${path}`;
      if (isCustomDomainPathWhitelisted(formattedPath)) {
        args = Object.assign(Object.assign({}, args), { headers: Object.assign(Object.assign({}, args.headers), { "Auth0-Custom-Domain": trimmedDomain }) });
      }
    } catch (error) {
      throw new Error(`Invalid URL provided to custom domain header: ${args.url}`);
    }
    return originalFetcher(args);
  });
  return Object.assign(Object.assign({}, options), { fetcher: customDomainFetcher });
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/wrapper/ManagementClient.mjs
var ManagementClient2 = class extends ManagementClient {
  /**
   * Creates a new Management API client instance.
   *
   * @param _options - Configuration options for the Management Client
   * @group Management API
   */
  constructor(_options) {
    const baseUrl = `https://${_options.domain}/api/v2`;
    const headers = createTelemetryHeaders(_options);
    const token = createTokenSupplier(_options);
    delete _options.fetcher;
    delete _options.fetch;
    let clientOptions = Object.assign(Object.assign({}, _options), {
      baseUrl,
      headers,
      token
    });
    if ("withCustomDomainHeader" in _options && _options.withCustomDomainHeader !== void 0) {
      clientOptions = withCustomDomainHeader(_options.withCustomDomainHeader, clientOptions);
    }
    super(clientOptions);
  }
};
function isClientOptionsWithToken(_options) {
  return "token" in _options;
}
function createTelemetryHeaders(_options) {
  var _a;
  const headers = Object.assign({}, (_a = _options.headers) !== null && _a !== void 0 ? _a : {});
  if (_options.telemetry !== false) {
    const telemetry = new Auth0ClientTelemetry({
      clientInfo: _options.clientInfo
    });
    const auth0ClientHeader = telemetry.getAuth0ClientHeader();
    if (auth0ClientHeader) {
      headers["Auth0-Client"] = auth0ClientHeader;
    }
  }
  return headers;
}
function hasClientSecret(_options) {
  return "clientSecret" in _options;
}
function createTokenSupplier(_options) {
  var _a;
  if (isClientOptionsWithToken(_options)) {
    return _options.token;
  }
  const baseOptions = Object.assign(Object.assign({}, _options), { audience: (_a = _options.audience) !== null && _a !== void 0 ? _a : `https://${_options.domain}/api/v2/`, clientId: _options.clientId, useMTLS: _options.useMTLS });
  if (hasClientSecret(_options)) {
    const tokenProviderOptions = Object.assign(Object.assign({}, baseOptions), { clientSecret: _options.clientSecret });
    const tokenProvider = new TokenProvider(tokenProviderOptions);
    return () => tokenProvider.getAccessToken();
  } else {
    const tokenProviderOptions = Object.assign(Object.assign({}, baseOptions), { clientAssertionSigningKey: _options.clientAssertionSigningKey, clientAssertionSigningAlg: _options.clientAssertionSigningAlg });
    const tokenProvider = new TokenProvider(tokenProviderOptions);
    return () => tokenProvider.getAccessToken();
  }
}

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/management/core/logging/exports.mjs
var logging;
(function(logging2) {
  logging2.LogLevel = LogLevel;
  logging2.ConsoleLogger = ConsoleLogger;
})(logging || (logging = {}));

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/userinfo/index.mjs
var __awaiter139 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UserInfoError = class extends Error {
  constructor(error, error_description, statusCode, body, headers) {
    super(error_description || error);
    this.error = error;
    this.error_description = error_description;
    this.statusCode = statusCode;
    this.body = body;
    this.headers = headers;
    this.name = "UserInfoError";
  }
};
function parseError2(response) {
  return __awaiter139(this, void 0, void 0, function* () {
    const body = yield response.text();
    let data;
    try {
      data = JSON.parse(body);
      return new UserInfoError(data.error, data.error_description, response.status, body, response.headers);
    } catch (_a) {
      return new ResponseError(response.status, body, response.headers, "Response returned an error code");
    }
  });
}
var UserInfoClient = class extends BaseAPI {
  /**
   * Create a new UserInfo API client
   * @param options - Configuration options including domain and client settings
   */
  constructor(options) {
    super(Object.assign(Object.assign({}, options), { baseUrl: `https://${options.domain}`, middleware: options.telemetry !== false ? [new Auth0ClientTelemetry(options)] : [], parseError: parseError2 }));
  }
  /**
     * Given an access token get the user profile linked to it.
     *
     * @example <caption>
     *   Get the user information based on the Auth0 access token (obtained during
     *   login). Find more information in the
     *   <a href="https://auth0.com/docs/auth-api#!#get--userinfo">API Docs</a>.
     * </caption>
     *
     * const userInfoClient = new UserInfoClient({
     *   domain: '...'
     * });
  
     * const userInfo = await userInfoClient.getUserInfo(accessToken);
     */
  getUserInfo(accessToken, initOverrides) {
    return __awaiter139(this, void 0, void 0, function* () {
      const response = yield this.request({
        path: `/userinfo`,
        method: "GET",
        headers: {
          Authorization: `Bearer ${accessToken}`
        }
      }, initOverrides);
      return JSONApiResponse.fromResponse(response);
    });
  }
};

// node_modules/.pnpm/auth0@5.2.0/node_modules/auth0/dist/esm/lib/httpResponseHeadersUtils.mjs
var HttpResponseHeadersUtils = class {
  /**
   * Gets the client token quota limits from the provided headers.
   *
   * @param headers the HTTP response headers.
   * @return a TokenQuotaBucket containing client rate limits, or null if not present.
   */
  static getClientQuotaLimit(headers) {
    const getHeaderValue = (key) => {
      if (headers instanceof Headers) {
        return headers.get(key);
      }
      return headers[key] || null;
    };
    const quotaHeader = getHeaderValue("auth0-client-quota-limit");
    return quotaHeader ? this.parseQuota(quotaHeader) : null;
  }
  /**
   * Gets the organization token quota limits from the provided headers.
   *
   * @param headers the HTTP response headers.
   * @return a TokenQuotaBucket containing organization rate limits, or null if not present.
   */
  static getOrganizationQuotaLimit(headers) {
    const getHeaderValue = (key) => {
      if (headers instanceof Headers) {
        return headers.get(key);
      }
      return headers[key] || null;
    };
    const quotaHeader = getHeaderValue("auth0-organization-quota-limit");
    return quotaHeader ? this.parseQuota(quotaHeader) : null;
  }
  /**
   * Parses a token quota string into a TokenQuotaBucket.
   *
   * @param tokenQuota the token quota string.
   * @return a TokenQuotaBucket containing parsed rate limits.
   */
  static parseQuota(tokenQuota) {
    let perHour;
    let perDay;
    const parts = tokenQuota.split(",");
    for (const part of parts) {
      const attributes = part.split(";");
      let quota = 0, remaining = 0, resetAfter = 0;
      for (const attribute of attributes) {
        const [key, value] = attribute.split("=").map((s) => s.trim());
        if (!key || !value)
          continue;
        switch (key) {
          case "q":
            quota = parseInt(value, 10);
            break;
          case "r":
            remaining = parseInt(value, 10);
            break;
          case "t":
            resetAfter = parseInt(value, 10);
            break;
        }
      }
      if (attributes.length > 0 && attributes[0].includes("per_hour")) {
        perHour = { quota, remaining, resetAfter };
      } else if (attributes.length > 0 && attributes[0].includes("per_day")) {
        perDay = { quota, remaining, resetAfter };
      }
    }
    return { perHour, perDay };
  }
};
export {
  AuthApiError,
  AuthenticationClient,
  CustomDomainHeader,
  CustomPager,
  Database,
  FetchError,
  HttpResponseHeadersUtils,
  IdTokenValidatorError,
  JSONApiResponse,
  api_exports as Management,
  ManagementClient2 as ManagementClient,
  ManagementEnvironment,
  ManagementError,
  ManagementTimeoutError,
  OAuth,
  Passwordless,
  RequiredError,
  ResponseError,
  SUBJECT_TOKEN_TYPES,
  TOKEN_FOR_CONNECTION_GRANT_TYPE,
  TOKEN_FOR_CONNECTION_REQUESTED_TOKEN_TYPE,
  TOKEN_FOR_CONNECTION_TOKEN_TYPE,
  TOKEN_URL,
  TextApiResponse,
  TimeoutError,
  UserInfoClient,
  UserInfoError,
  VoidApiResponse,
  logging,
  parseError2 as parseError,
  withAbortSignal,
  withHeaders,
  withRetries,
  withTimeout
};
//# sourceMappingURL=auth0.js.map
