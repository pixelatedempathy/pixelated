name: GKE Deployment Pipeline

permissions:
  contents: read
  id-token: write
  packages: write

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:

env:
  NODE_VERSION: "24"
  PNPM_VERSION: "10.28.1"
  PYTHON_VERSION: "3.11"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Validation stage - fast parallel validation
  validate:
    name: Validate
    runs-on: ubuntu-latest
    strategy:
      matrix:
        validation_type: [dependencies, lint, typecheck]
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Pre-install diagnostics
        if: runner.debug == '1'
        run: |
          echo "üîç CI Environment Diagnostics"
          echo "Node: $(node --version)"
          echo "pnpm: $(pnpm --version)"
          echo "Memory: $(free -h | grep Mem || echo 'N/A')"
          echo "Disk: $(df -h . | tail -1)"
          echo "Package manager in package.json: $(cat package.json | grep packageManager || echo 'not specified')"
          pnpm store path || echo "pnpm store not initialized"

      - name: Load environment from .env
        run: |
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading environment variables from .env file"
            # Export variables that might be in .env
            while IFS= read -r line; do
              if [[ $line =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                export "$line"
              fi
            done < .env
          fi

      - name: Validate package.json
        run: |
          echo "Validating package.json syntax..."
          node -e "JSON.parse(require('fs').readFileSync('package.json', 'utf8'))" && echo "‚úÖ package.json is valid JSON" || (echo "‚ùå package.json has JSON syntax errors" && exit 1)

      - name: Install dependencies
        run: |
          set -o pipefail
          # Enhanced retry logic for pnpm install with comprehensive error handling
          for i in {1..3}; do
            echo "üì¶ Attempt $i of 3: Installing dependencies..."
            ERROR_LOG=$(mktemp)
            
            if pnpm install --frozen-lockfile --prefer-offline 2>&1 | tee "$ERROR_LOG"; then
              echo "‚úÖ Dependencies installed successfully"
              rm -f "$ERROR_LOG"
              break
            else
              EXIT_CODE=$?
              echo "‚ùå Install failed with exit code: $EXIT_CODE"
              echo "üìù Full error output:"
              cat "$ERROR_LOG"
              
              # Check for lockfile mismatch
              if grep -qE "ERR_PNPM_LOCKFILE_CONFIG_MISMATCH|overrides.*doesn't match|lockfile.*not compatible" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Lockfile config mismatch detected, updating lockfile..."
                pnpm install --no-frozen-lockfile
                echo "‚úÖ Dependencies installed with updated lockfile"
                rm -f "$ERROR_LOG"
                break
              fi
              
              # Check for network errors
              if grep -qE "ENOTFOUND|ETIMEDOUT|ECONNRESET|fetch failed|network" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Network error detected"
                if [ $i -eq 3 ]; then
                  echo "‚ùå All install attempts failed due to network issues"
                  rm -f "$ERROR_LOG"
                  exit 1
                fi
              fi
              
              # Check for peer dependency issues
              if grep -qE "WARN.*peer dep|unmet peer" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Peer dependency warnings detected, trying with --no-strict-peer-dependencies..."
                if pnpm install --frozen-lockfile --no-strict-peer-dependencies 2>&1; then
                  echo "‚úÖ Dependencies installed with relaxed peer dependencies"
                  rm -f "$ERROR_LOG"
                  break
                fi
              fi
              
              rm -f "$ERROR_LOG"
              
              if [ $i -lt 3 ]; then
                DELAY=$((5 * i))
                echo "‚è≥ Retrying in $DELAY seconds..."
                sleep $DELAY
                
                # Clean up partial state
                echo "üßπ Cleaning up partial installation state..."
                rm -rf node_modules/.pnpm || true
                pnpm store prune || true
              else
                echo "‚ùå All install attempts failed"
                echo "üí° Debug information:"
                echo "  - Node version: $(node --version)"
                echo "  - pnpm version: $(pnpm --version)"
                echo "  - Package manager in package.json: $(cat package.json | grep packageManager || echo 'not specified')"
                exit 1
              fi
            fi
          done

      - name: Run ${{ matrix.validation_type }} validation
        run: |
          echo "üîç Running ${{ matrix.validation_type }} validation..."
          case "${{ matrix.validation_type }}" in
            dependencies)
              pnpm audit --audit-level moderate || echo "‚ö†Ô∏è Audit warnings found but continuing"
              ;;
            lint)
              pnpm lint:ci || echo "‚ö†Ô∏è Linting completed with warnings"
              ;;
            typecheck)
              pnpm typecheck || echo "‚ö†Ô∏è Type checking completed with warnings"
              ;;
          esac
          echo "‚úÖ ${{ matrix.validation_type }} validation complete"

  # Build stage - build application and container image
  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    needs: [validate]
    outputs:
      image-tag: ${{ steps.out.outputs.image-tag }}
      image-digest: ${{ steps.out.outputs.image-digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Verify checkout
        run: |
          echo "üîç Verifying checkout completed successfully..."
          echo "üìÇ Working directory: $(pwd)"
          echo "üìÇ GitHub workspace: ${{ github.workspace }}"
          if [[ ! -f "package.json" ]]; then
            echo "‚ùå Checkout verification failed - package.json not found!"
            echo "üìÇ Directory contents:"
            ls -la
            exit 1
          fi
          echo "‚úÖ Checkout verified - repository files present"

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Pre-install diagnostics
        if: runner.debug == '1'
        run: |
          echo "üîç CI Environment Diagnostics"
          echo "Node: $(node --version)"
          echo "pnpm: $(pnpm --version)"
          echo "Memory: $(free -h | grep Mem || echo 'N/A')"
          echo "Disk: $(df -h . | tail -1)"
          echo "Package manager in package.json: $(cat package.json | grep packageManager || echo 'not specified')"
          pnpm store path || echo "pnpm store not initialized"

      - name: Load environment from .env
        run: |
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading environment variables from .env file"
            # Export variables that might be in .env
            while IFS= read -r line; do
              if [[ $line =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                export "$line"
              fi
            done < .env
          fi

      - name: Install dependencies
        run: |
          set -o pipefail
          # Enhanced retry logic for pnpm install with comprehensive error handling
          for i in {1..3}; do
            echo "üì¶ Attempt $i of 3: Installing dependencies..."
            ERROR_LOG=$(mktemp)
            
            if pnpm install --frozen-lockfile --prefer-offline 2>&1 | tee "$ERROR_LOG"; then
              echo "‚úÖ Dependencies installed successfully"
              rm -f "$ERROR_LOG"
              break
            else
              EXIT_CODE=$?
              echo "‚ùå Install failed with exit code: $EXIT_CODE"
              echo "üìù Full error output:"
              cat "$ERROR_LOG"
              
              # Check for lockfile mismatch
              if grep -qE "ERR_PNPM_LOCKFILE_CONFIG_MISMATCH|overrides.*doesn't match|lockfile.*not compatible" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Lockfile config mismatch detected, updating lockfile..."
                pnpm install --no-frozen-lockfile
                echo "‚úÖ Dependencies installed with updated lockfile"
                rm -f "$ERROR_LOG"
                break
              fi
              
              # Check for network errors
              if grep -qE "ENOTFOUND|ETIMEDOUT|ECONNRESET|fetch failed|network" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Network error detected"
                echo "üîç Testing network connectivity..."
                ping -c 1 registry.npmjs.org || echo "Registry connectivity check failed"
                if [ $i -eq 3 ]; then
                  echo "‚ùå All install attempts failed due to network issues"
                  rm -f "$ERROR_LOG"
                  exit 1
                fi
              fi
              
              # Check for peer dependency issues
              if grep -qE "WARN.*peer dep|unmet peer" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Peer dependency warnings detected, trying with --no-strict-peer-dependencies..."
                if pnpm install --frozen-lockfile --no-strict-peer-dependencies 2>&1; then
                  echo "‚úÖ Dependencies installed with relaxed peer dependencies"
                  rm -f "$ERROR_LOG"
                  break
                fi
              fi
              
              # Check for git fetch issues
              if grep -qE "git|fetch.*failed|clone.*failed" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Git fetch error detected"
                echo "üìä Git configuration:"
                git config --list | grep -E "(http|pack|lfs)" || true
              fi
              
              rm -f "$ERROR_LOG"
              
              if [ $i -lt 3 ]; then
                DELAY=$((5 * i))
                echo "‚è≥ Retrying in $DELAY seconds..."
                sleep $DELAY
                
                # Clean up partial state
                echo "üßπ Cleaning up partial installation state..."
                rm -rf node_modules/.pnpm || true
                pnpm store prune || true
              else
                echo "‚ùå All install attempts failed"
                echo "üí° Debug information:"
                echo "  - Node version: $(node --version)"
                echo "  - pnpm version: $(pnpm --version)"
                echo "  - Package manager in package.json: $(cat package.json | grep packageManager || echo 'not specified')"
                echo "  - Available memory: $(free -h | grep Mem || echo 'N/A')"
                exit 1
              fi
            fi
          done

      - name: Build application
        run: |
          echo "üèóÔ∏è Building application with progressive memory optimization..."
          # Use memory-optimized build script for better memory management
          chmod +x ./scripts/memory-optimized-build.sh
          ./scripts/memory-optimized-build.sh
          echo "‚úÖ Application build completed successfully"

      - name: Verify Dockerfile exists
        run: |
          echo "üîç Verifying Dockerfile location..."
          echo "üìÇ Current working directory: $(pwd)"
          echo "üìÇ GitHub workspace: ${{ github.workspace }}"

          # Change to the GitHub workspace directory
          cd "${{ github.workspace }}" || { echo "‚ùå Failed to change to workspace directory"; exit 1; }

          # Verify checkout succeeded by checking for common files
          if [ ! -f "package.json" ]; then
            echo "‚ùå Checkout verification failed - package.json not found!"
            echo "üìÇ Current directory contents:"
            ls -la
            echo "üìÇ Expected workspace: ${{ github.workspace }}"
            echo "üìÇ Git configuration:"
            ls -la .git 2>/dev/null || echo ".git directory not found"
            exit 1
          fi

          # Check for Dockerfile in root
          if [ -f "Dockerfile" ]; then
            echo "‚úÖ Dockerfile found at: ${{ github.workspace }}/Dockerfile"
            echo "üìÑ Dockerfile size: $(stat -c%s Dockerfile) bytes"
          else
            echo "‚ùå Dockerfile not found in root directory"
            echo "üìÇ Current directory contents:"
            ls -la | head -20
            echo "üìÇ Looking for Dockerfile in repository:"
            find "${{ github.workspace }}" -name "Dockerfile" -type f 2>/dev/null | head -10 || echo "No Dockerfile found"
            echo "‚ùå Dockerfile verification failed!"
            exit 1
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Free disk space for security scan
        uses: easimon/maximize-build-space@v10
        with:
          root-reserve-mb: 25600
          swap-size-mb: 1
          remove-dotnet: true
          remove-android: true
          remove-haskell: true
          remove-codeql: true
          remove-docker-images: true

      - name: Verify workspace after disk cleanup
        run: |
          echo "üîç Verifying workspace integrity after disk cleanup..."
          if [[ ! -f "package.json" ]] || [[ ! -f "Dockerfile" ]]; then
            echo "‚ùå Workspace files missing after disk cleanup!"
            echo "üìÇ Current directory contents:"
            ls -la
            echo "üìÇ Expected workspace: ${{ github.workspace }}"
            exit 1
          fi
          echo "‚úÖ Workspace integrity verified"

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=main-,format=short
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Load Sentry environment
        run: |
          # Load Sentry variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading Sentry configuration from .env"
            SENTRY_DSN=$(grep "^SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            PUBLIC_SENTRY_DSN=$(grep "^PUBLIC_SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            SENTRY_AUTH_TOKEN=$(grep "^SENTRY_AUTH_TOKEN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")

            if [[ -n "$SENTRY_DSN" ]]; then
              echo "SENTRY_DSN=${SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$PUBLIC_SENTRY_DSN" ]]; then
              echo "PUBLIC_SENTRY_DSN=${PUBLIC_SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$SENTRY_AUTH_TOKEN" ]]; then
              echo "SENTRY_AUTH_TOKEN=${SENTRY_AUTH_TOKEN}" >> $GITHUB_ENV
            fi
          fi

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            SENTRY_RELEASE=${{ github.sha }}
            SENTRY_DSN=${{ env.SENTRY_DSN || secrets.SENTRY_DSN }}
            SENTRY_AUTH_TOKEN=${{ env.SENTRY_AUTH_TOKEN || secrets.SENTRY_AUTH_TOKEN }}
            PUBLIC_SENTRY_DSN=${{ env.PUBLIC_SENTRY_DSN || secrets.PUBLIC_SENTRY_DSN }}

      - name: Output image info
        id: out
        run: |
          # Extract first tag from multi-line tags output
          FIRST_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n 1)
          echo "image-tag=${FIRST_TAG}" >> $GITHUB_OUTPUT
          echo "image-digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

  # Security scanning stage
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      contents: read
      security-events: write
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine image tag
        id: image_tag
        run: |
          # Use immutable image digest produced by the build job
          IMAGE_DIGEST="${{ needs.build.outputs.image-digest }}"
          if [ -z "$IMAGE_DIGEST" ]; then
            echo "‚ùå Missing image digest from build outputs"
            exit 1
          fi
          IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${IMAGE_DIGEST}"
          echo "image_ref=${IMAGE_REF}" >> $GITHUB_OUTPUT
          echo "üîç Using image: ${IMAGE_REF}"

      - name: Pull Docker image for scanning
        run: |
          docker pull "${{ steps.image_tag.outputs.image_ref }}"
          echo "‚úÖ Image pulled successfully"

      - name: Configure Trivy temp and cache directories
        run: |
          echo "TMPDIR=$RUNNER_TEMP" >> $GITHUB_ENV
          echo "XDG_CACHE_HOME=$RUNNER_TEMP/.cache" >> $GITHUB_ENV
          echo "TRIVY_CACHE_DIR=$RUNNER_TEMP/.cache/trivy" >> $GITHUB_ENV
          mkdir -p "$RUNNER_TEMP/.cache/trivy"
          echo "‚úÖ Trivy will use $RUNNER_TEMP for temp and cache"

      - name: Aggressive Docker cleanup before scan
        run: |
          echo "üßπ Pruning Docker to reclaim space..."
          docker system prune -af || true
          docker builder prune -af || true

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.33.1
        continue-on-error: true
        with:
          image-ref: ${{ steps.image_tag.outputs.image_ref }}
          format: "sarif"
          output: "trivy-results.sarif"
          cache-dir: ${{ env.TRIVY_CACHE_DIR }}
          # Limit scanning to vulnerabilities to reduce temp usage and speed
          scanners: vuln
          # Keep SARIF focused and smaller
          severity: CRITICAL,HIGH
          limit-severities-for-sarif: true
          timeout: 10m

      - name: Check for Trivy SARIF file
        id: trivy_sarif
        run: |
          if [ -s trivy-results.sarif ]; then
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Trivy SARIF file found"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è Trivy SARIF file not found or empty"
          fi

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v4
        if: ${{ always() && steps.trivy_sarif.outputs.found == 'true' }}
        continue-on-error: true
        with:
          sarif_file: "trivy-results.sarif"

      - name: Container security check
        run: |
          echo "üîç Checking container security configuration..."
          IMAGE_REF="${{ steps.image_tag.outputs.image_ref }}"
          # Check user configuration
          USER_ID=$(docker inspect "$IMAGE_REF" --format='{{.Config.User}}' 2>/dev/null || echo "")
          if [ -z "$USER_ID" ] || [ "$USER_ID" = "root" ] || [ "$USER_ID" = "0" ]; then
            echo "‚ö†Ô∏è Container may run as root - checking runtime behavior"
            RUNTIME_USER=$(timeout 30 docker run --rm "$IMAGE_REF" whoami 2>/dev/null || echo "unknown")
            if [ "$RUNTIME_USER" = "root" ]; then
              echo "‚ùå Container runs as root - security risk"
              exit 1
            else
              echo "‚úÖ Container runs as non-root user at runtime: $RUNTIME_USER"
            fi
          else
            echo "‚úÖ Container configured with non-root user: $USER_ID"
          fi

          # Check exposed ports
          EXPOSED_PORTS=$(docker inspect "$IMAGE_REF" --format='{{range $p, $conf := .Config.ExposedPorts}}{{$p}} {{end}}' 2>/dev/null || echo "")
          echo "‚ÑπÔ∏è Exposed ports: ${EXPOSED_PORTS:-none}"
          echo "‚úÖ Security checks completed"

  # Sentry release creation
  sentry-release:
    name: Create Sentry Release
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Load Sentry environment
        run: |
          # Load Sentry variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading Sentry configuration from .env"
            SENTRY_DSN=$(grep "^SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            PUBLIC_SENTRY_DSN=$(grep "^PUBLIC_SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            SENTRY_AUTH_TOKEN=$(grep "^SENTRY_AUTH_TOKEN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            SENTRY_ORG=$(grep "^SENTRY_ORG=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            SENTRY_PROJECT=$(grep "^SENTRY_PROJECT=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")

            if [[ -n "$SENTRY_DSN" ]]; then
              echo "SENTRY_DSN=${SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$PUBLIC_SENTRY_DSN" ]]; then
              echo "PUBLIC_SENTRY_DSN=${PUBLIC_SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$SENTRY_AUTH_TOKEN" ]]; then
              echo "SENTRY_AUTH_TOKEN=${SENTRY_AUTH_TOKEN}" >> $GITHUB_ENV
            fi
            if [[ -n "$SENTRY_ORG" ]]; then
              echo "SENTRY_ORG=${SENTRY_ORG}" >> $GITHUB_ENV
            fi
            if [[ -n "$SENTRY_PROJECT" ]]; then
              echo "SENTRY_PROJECT=${SENTRY_PROJECT}" >> $GITHUB_ENV
            fi
          fi

      - name: Create Sentry release
        if: env.SENTRY_AUTH_TOKEN != '' && env.SENTRY_DSN != ''
        env:
          SENTRY_AUTH_TOKEN: ${{ env.SENTRY_AUTH_TOKEN || secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ env.SENTRY_ORG || secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ env.SENTRY_PROJECT || secrets.SENTRY_PROJECT }}
          SENTRY_RELEASE: ${{ github.sha }}
        run: |
          echo "üìä Creating Sentry release: $SENTRY_RELEASE"
          curl -sL https://sentry.io/get-cli/ | sh
          sentry-cli releases new "$SENTRY_RELEASE" || true
          sentry-cli releases files "$SENTRY_RELEASE" upload-sourcemaps ./dist --rewrite --strip-prefix ./ --strip-common-prefix || true
          sentry-cli releases finalize "$SENTRY_RELEASE" || true
          echo "‚úÖ Sentry release created"

  # GKE Deployment with multiple strategies
  # DISABLED: GKE billing not enabled. Re-enable when billing is configured.
  deploy-gke:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    needs: [build, security-scan, sentry-release]
    if: false # DISABLED: GKE billing not enabled
    environment: production
    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      deployment-strategy: ${{ steps.deploy.outputs.strategy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Load GCP environment
        run: |
          # Load GCP variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading GCP configuration from .env"
            GCP_PROJECT_ID=$(grep "^GCP_PROJECT_ID=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_CLUSTER_NAME=$(grep "^GKE_CLUSTER_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_ZONE=$(grep "^GKE_ZONE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_NAMESPACE=$(grep "^GKE_NAMESPACE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_DEPLOYMENT_NAME=$(grep "^GKE_DEPLOYMENT_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_SERVICE_NAME=$(grep "^GKE_SERVICE_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_ENVIRONMENT_URL=$(grep "^GKE_ENVIRONMENT_URL=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GCP_SERVICE_ACCOUNT_KEY=$(grep "^GCP_SERVICE_ACCOUNT_KEY=" .env | cut -d'=' -f2- | sed 's/^'\''//;s/'\''$//' || echo "")

            if [[ -n "$GCP_PROJECT_ID" ]]; then
              echo "GCP_PROJECT_ID=${GCP_PROJECT_ID}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_CLUSTER_NAME" ]]; then
              echo "GKE_CLUSTER_NAME=${GKE_CLUSTER_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_ZONE" ]]; then
              echo "GKE_ZONE=${GKE_ZONE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_NAMESPACE" ]]; then
              echo "GKE_NAMESPACE=${GKE_NAMESPACE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_DEPLOYMENT_NAME" ]]; then
              echo "GKE_DEPLOYMENT_NAME=${GKE_DEPLOYMENT_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_SERVICE_NAME" ]]; then
              echo "GKE_SERVICE_NAME=${GKE_SERVICE_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_ENVIRONMENT_URL" ]]; then
              echo "GKE_ENVIRONMENT_URL=${GKE_ENVIRONMENT_URL}" >> $GITHUB_ENV
            fi
            if [[ -n "$GCP_SERVICE_ACCOUNT_KEY" ]]; then
              echo "GCP_SERVICE_ACCOUNT_KEY=${GCP_SERVICE_ACCOUNT_KEY}" >> $GITHUB_ENV
            fi
          fi

      - name: Verify Workload Identity Configuration
        run: |
          echo "üîç Verifying workload identity configuration..."

          # Check required secrets are set
          if [ -z "${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}" ]; then
            echo "‚ùå Error: GCP_WORKLOAD_IDENTITY_PROVIDER secret is not set"
            echo "üìö See docs/gcp-authentication-setup.md for setup instructions"
            echo "üí° Format: projects/[PROJECT_NUMBER]/locations/global/workloadIdentityPools/[POOL_NAME]/providers/[PROVIDER_NAME]"
            exit 1
          fi

          if [ -z "${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}" ]; then
            echo "‚ùå Error: GCP_SERVICE_ACCOUNT_EMAIL secret is not set"
            echo "üìö See docs/gcp-authentication-setup.md for setup instructions"
            exit 1
          fi

          if [ -z "${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}" ]; then
            echo "‚ùå Error: GCP_PROJECT_ID is not set"
            echo "üìö See docs/gcp-authentication-setup.md for setup instructions"
            exit 1
          fi

          # Validate provider path format
          PROVIDER_PATH="${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}"
          PROJECT_ID="${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}"

          echo "‚úÖ Required secrets are configured"
          echo "GCP_PROJECT_ID: ${PROJECT_ID}"
          echo "Workload Identity Provider: ${PROVIDER_PATH}"
          echo "Service Account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}"
          echo ""

          # Validate provider path format
          echo "üîç Validating provider path format..."

          # Check if path matches expected format
          if [[ ! "$PROVIDER_PATH" =~ ^projects/[0-9]+/locations/global/workloadIdentityPools/[^/]+/providers/[^/]+$ ]]; then
            echo "‚ùå Invalid provider path format!"
            echo "Expected: projects/[PROJECT_NUMBER]/locations/global/workloadIdentityPools/[POOL_NAME]/providers/[PROVIDER_NAME]"
            echo "Got: ${PROVIDER_PATH}"
            echo ""
            echo "‚ö†Ô∏è  CRITICAL: The path MUST use PROJECT_NUMBER (numeric), not PROJECT_ID (alphanumeric)"
            echo "   Get your PROJECT_NUMBER with: gcloud projects describe ${PROJECT_ID} --format='value(projectNumber)'"
            exit 1
          fi

          # Extract project number from path and check if it's numeric
          PROVIDER_PROJECT_NUMBER=$(echo "$PROVIDER_PATH" | sed -n 's|^projects/\([^/]*\)/.*|\1|p')
          if [[ ! "$PROVIDER_PROJECT_NUMBER" =~ ^[0-9]+$ ]]; then
            echo "‚ùå ERROR: Provider path contains non-numeric project identifier: ${PROVIDER_PROJECT_NUMBER}"
            echo "   This must be your PROJECT_NUMBER, not PROJECT_ID!"
            echo "   Your PROJECT_ID is: ${PROJECT_ID}"
            echo "   Get PROJECT_NUMBER with: gcloud projects describe ${PROJECT_ID} --format='value(projectNumber)'"
            echo ""
            echo "   Correct format example:"
            echo "   projects/123456789012/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
            exit 1
          fi

          echo "‚úÖ Provider path format is valid"
          echo "   Project number in path: ${PROVIDER_PROJECT_NUMBER}"
          echo ""
          echo "‚ö†Ô∏è  If authentication still fails with 'invalid_target', verify:"
          echo "   1. The workload identity pool exists and is ACTIVE:"
          echo "      gcloud iam workload-identity-pools list --project=${PROJECT_ID}"
          echo "   2. The provider exists and is ACTIVE:"
          echo "      gcloud iam workload-identity-pools providers list --project=${PROJECT_ID} --location=global --workload-identity-pool=github-pool"
          echo "   3. The provider path uses the correct PROJECT_NUMBER (${PROVIDER_PROJECT_NUMBER})"
          echo "   4. Run verification script: ./scripts/verify-workload-identity.sh"
          echo "üìö Full troubleshooting: docs/workload-identity-troubleshooting.md"

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          create_credentials_file: true
          export_environment_variables: true
          project_id: ${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}
          universe: googleapis.com
          cleanup_credentials: true
          access_token_lifetime: 3600s
          access_token_scopes: https://www.googleapis.com/auth/cloud-platform
          id_token_include_email: false

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v3

      - name: "Preflight: verify GKE API access permissions"
        run: |
          PROJECT_ID="${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}"
          CLUSTER_NAME="${{ env.GKE_CLUSTER_NAME || secrets.GKE_CLUSTER_NAME }}"
          ZONE="${{ env.GKE_ZONE || secrets.GKE_ZONE }}"

          echo "üîê Authenticated as:"
          gcloud auth list --filter=status:ACTIVE --format='table(account)'

          echo "üîé Verifying permission to access cluster metadata (container.clusters.get) ..."
          # This lightweight call will fail with the same 403 if the SA lacks container.clusters.get
          if ! gcloud container clusters describe "$CLUSTER_NAME" --zone "$ZONE" --project "$PROJECT_ID" --format='value(name)' >/dev/null 2>&1; then
            echo "‚ùå Missing required permission: container.clusters.get for $PROJECT_ID/$ZONE/$CLUSTER_NAME"
            echo "üí° Grant the GitHub Actions service account the IAM role: roles/container.clusterViewer (Project-level)"
            echo "   gcloud projects add-iam-policy-binding $PROJECT_ID \\";
            echo "     --member=serviceAccount:${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }} \\";
            echo "     --role=roles/container.clusterViewer"
            echo "üìö After granting, re-run the workflow."
            exit 1
          fi
          echo "‚úÖ GKE API permission check passed"

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER_NAME || secrets.GKE_CLUSTER_NAME }} \
            --zone ${{ env.GKE_ZONE || secrets.GKE_ZONE }} \
            --project ${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}

      - name: Configure kubectl
        run: |
          echo "üîß Configuring kubectl..."
          kubectl config current-context
          kubectl cluster-info

          # Create namespace if it doesn't exist
          kubectl create namespace ${{ env.GKE_NAMESPACE || secrets.GKE_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl config set-context --current --namespace=${{ env.GKE_NAMESPACE || secrets.GKE_NAMESPACE }}

      - name: Deploy to GKE
        id: deploy
        env:
          CONTAINER_IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          GKE_DEPLOYMENT_NAME: ${{ env.GKE_DEPLOYMENT_NAME || secrets.GKE_DEPLOYMENT_NAME }}
          GKE_SERVICE_NAME: ${{ env.GKE_SERVICE_NAME || secrets.GKE_SERVICE_NAME }}
          GKE_NAMESPACE: ${{ env.GKE_NAMESPACE || secrets.GKE_NAMESPACE }}
          REPLICAS: ${{ env.GKE_REPLICAS || secrets.GKE_REPLICAS || '3' }}
          MAX_SURGE: ${{ env.GKE_MAX_SURGE || secrets.GKE_MAX_SURGE || '1' }}
          MAX_UNAVAILABLE: ${{ env.GKE_MAX_UNAVAILABLE || secrets.GKE_MAX_UNAVAILABLE || '0' }}
          DEPLOYMENT_STRATEGY: ${{ github.event.inputs.deployment_strategy || 'rolling' }}
          CANARY_PERCENTAGE: ${{ env.CANARY_PERCENTAGE || secrets.CANARY_PERCENTAGE || '25' }}
          AUTO_ROLLBACK_ENABLED: ${{ env.AUTO_ROLLBACK || secrets.AUTO_ROLLBACK || 'true' }}
          HEALTH_CHECK_TIMEOUT: ${{ env.HEALTH_CHECK_TIMEOUT || secrets.HEALTH_CHECK_TIMEOUT || '300' }}
        run: |
          echo "üöÄ Deploying to GKE cluster: ${{ env.GKE_CLUSTER_NAME || secrets.GKE_CLUSTER_NAME }}"
          echo "üì¶ Container image: $CONTAINER_IMAGE"
          echo "üéØ Deployment strategy: $DEPLOYMENT_STRATEGY"

          # Set deployment variables
          export CI_COMMIT_SHORT_SHA=${{ github.sha }}

          # Pre-deployment validation
          echo "üîç Pre-deployment validation..."

          # Check deployment strategy and validate
          case $DEPLOYMENT_STRATEGY in
            rolling|blue-green|canary)
              echo "‚úÖ Deployment strategy: $DEPLOYMENT_STRATEGY"
              ;;
            *)
              echo "‚ùå Invalid deployment strategy: $DEPLOYMENT_STRATEGY"
              exit 1
              ;;
          esac

          # Apply Kubernetes manifests based on strategy
          echo "üìã Applying Kubernetes manifests using $DEPLOYMENT_STRATEGY strategy..."

          case $DEPLOYMENT_STRATEGY in
            rolling)
              # Standard rolling update
              . ./scripts/deploy-rolling.sh
              ;;
            blue-green)
              # Blue-green deployment
              . ./scripts/deploy-blue-green.sh
              ;;
            canary)
              # Canary deployment
              . ./scripts/deploy-canary.sh
              ;;
          esac

          # Wait for rollout based on strategy
          echo "‚è≥ Waiting for deployment rollout..."
          case $DEPLOYMENT_STRATEGY in
            rolling)
              if ! kubectl rollout status deployment/$GKE_DEPLOYMENT_NAME --timeout=600s; then
                echo "‚ùå Rolling deployment failed"
                kubectl describe deployment $GKE_DEPLOYMENT_NAME
                kubectl get events --sort-by=.metadata.creationTimestamp
                # Auto-rollback if enabled
                if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
                  echo "üîÑ Initiating automatic rollback..."
                  kubectl rollout undo deployment/$GKE_DEPLOYMENT_NAME
                  kubectl rollout status deployment/$GKE_DEPLOYMENT_NAME --timeout=300s
                fi
                exit 1
              fi
              ;;
            blue-green|canary)
              # For advanced strategies, wait for canary/blue validation
              if ! . ./scripts/wait-for-deployment.sh; then
                echo "‚ùå Deployment validation failed"
                if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
                  echo "üîÑ Initiating automatic rollback..."
                  . ./scripts/rollback-deployment.sh
                fi
                exit 1
              fi
              ;;
          esac

          # Post-deployment validation with health checks
          echo "üîç Post-deployment validation..."

          # Run comprehensive health checks
          if ! . ./scripts/health-check-comprehensive.sh; then
            echo "‚ùå Health checks failed"
            if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
              echo "üîÑ Initiating automatic rollback due to health check failure..."
              . ./scripts/rollback-deployment.sh
            fi
            exit 1
          fi

          # Performance validation for canary deployments
          if [ "$DEPLOYMENT_STRATEGY" = "canary" ]; then
            echo "üìà Validating canary performance..."
            if ! . ./scripts/validate-canary-performance.sh; then
              echo "‚ùå Canary performance validation failed"
              if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
                echo "üîÑ Rolling back canary deployment..."
                . ./scripts/rollback-deployment.sh
              fi
              exit 1
            fi
          fi

          echo "‚úÖ GKE deployment completed successfully"
          echo "üåê Application URL: ${{ env.GKE_ENVIRONMENT_URL || secrets.GKE_ENVIRONMENT_URL }}"
          echo "üìä Deployment strategy: $DEPLOYMENT_STRATEGY"

          # Store deployment metadata
          echo "status=success" >> $GITHUB_OUTPUT
          echo "strategy=$DEPLOYMENT_STRATEGY" >> $GITHUB_OUTPUT

  # GKE Health Check
  # DISABLED: Depends on GKE deployment which is disabled
  health-check-gke:
    name: GKE Health Check
    runs-on: ubuntu-latest
    needs: [deploy-gke]
    if: false # DISABLED: GKE billing not enabled
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Load GCP environment
        run: |
          # Load GCP variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading GCP configuration from .env"
            GCP_PROJECT_ID=$(grep "^GCP_PROJECT_ID=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_CLUSTER_NAME=$(grep "^GKE_CLUSTER_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_ZONE=$(grep "^GKE_ZONE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_NAMESPACE=$(grep "^GKE_NAMESPACE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_SERVICE_NAME=$(grep "^GKE_SERVICE_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GCP_SERVICE_ACCOUNT_KEY=$(grep "^GCP_SERVICE_ACCOUNT_KEY=" .env | cut -d'=' -f2- | sed 's/^'\''//;s/'\''$//' || echo "")

            if [[ -n "$GCP_PROJECT_ID" ]]; then
              echo "GCP_PROJECT_ID=${GCP_PROJECT_ID}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_CLUSTER_NAME" ]]; then
              echo "GKE_CLUSTER_NAME=${GKE_CLUSTER_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_ZONE" ]]; then
              echo "GKE_ZONE=${GKE_ZONE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_NAMESPACE" ]]; then
              echo "GKE_NAMESPACE=${GKE_NAMESPACE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_SERVICE_NAME" ]]; then
              echo "GKE_SERVICE_NAME=${GKE_SERVICE_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GCP_SERVICE_ACCOUNT_KEY" ]]; then
              echo "GCP_SERVICE_ACCOUNT_KEY=${GCP_SERVICE_ACCOUNT_KEY}" >> $GITHUB_ENV
            fi
          fi

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          create_credentials_file: true
          export_environment_variables: true
          project_id: ${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}
          universe: googleapis.com
          cleanup_credentials: true
          access_token_lifetime: 3600s
          access_token_scopes: https://www.googleapis.com/auth/cloud-platform
          id_token_include_email: false

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v3
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER_NAME || secrets.GKE_CLUSTER_NAME }} \
            --zone ${{ env.GKE_ZONE || secrets.GKE_ZONE }} \
            --project ${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}

      - name: Run health checks
        env:
          GKE_SERVICE_NAME: ${{ env.GKE_SERVICE_NAME || secrets.GKE_SERVICE_NAME }}
          GKE_ENVIRONMENT_URL: ${{ env.GKE_ENVIRONMENT_URL || secrets.GKE_ENVIRONMENT_URL }}
        run: |
          echo "üè• Running GKE health checks..."

          # Check deployment health
          echo "üìä Deployment status:"
          kubectl get deployment pixelated -o wide

          # Check pod health
          echo "üîç Pod health:"
          kubectl get pods -l app=pixelated -o wide

          # Check service status
          echo "üåê Service status:"
          kubectl get service $GKE_SERVICE_NAME

          # Detailed health check
          READY_PODS=$(kubectl get pods -l app=pixelated -o json | jq '[.items[] | select(.status.phase == "Running" and (.status.containerStatuses[]?.ready // false))] | length')
          TOTAL_PODS=$(kubectl get pods -l app=pixelated -o json | jq '.items | length')

          echo "üìà Health summary: $READY_PODS/$TOTAL_PODS pods ready"

          if [ "$READY_PODS" -eq 0 ]; then
            echo "‚ùå No healthy pods found"
            kubectl describe pods -l app=pixelated
            exit 1
          elif [ "$READY_PODS" -lt "$TOTAL_PODS" ]; then
            echo "‚ö†Ô∏è Some pods are not ready"
            kubectl describe pods -l app=pixelated | grep -A 10 -B 5 "Warning\|Error" || true
          else
            echo "‚úÖ All pods are healthy"
          fi

          # Test internal connectivity if possible
          if [ -n "$GKE_ENVIRONMENT_URL" ]; then
            echo "üåê Testing external connectivity..."
            if curl -f --connect-timeout 10 --max-time 30 "$GKE_ENVIRONMENT_URL/api/health" >/dev/null 2>&1; then
              echo "‚úÖ External health check passed"
            else
              echo "‚ö†Ô∏è External health check failed"
            fi
          fi

          echo "‚úÖ GKE health check completed"

  # Cleanup job - runs after deployments
  # DISABLED: Depends on GKE deployment which is disabled
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [deploy-gke, health-check-gke]
    if: false # DISABLED: GKE billing not enabled
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Load GCP environment
        run: |
          # Load GCP variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading GCP configuration from .env"
            GCP_PROJECT_ID=$(grep "^GCP_PROJECT_ID=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_CLUSTER_NAME=$(grep "^GKE_CLUSTER_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_ZONE=$(grep "^GKE_ZONE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GCP_SERVICE_ACCOUNT_KEY=$(grep "^GCP_SERVICE_ACCOUNT_KEY=" .env | cut -d'=' -f2- | sed 's/^'\''//;s/'\''$//' || echo "")

            if [[ -n "$GCP_PROJECT_ID" ]]; then
              echo "GCP_PROJECT_ID=${GCP_PROJECT_ID}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_CLUSTER_NAME" ]]; then
              echo "GKE_CLUSTER_NAME=${GKE_CLUSTER_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_ZONE" ]]; then
              echo "GKE_ZONE=${GKE_ZONE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GCP_SERVICE_ACCOUNT_KEY" ]]; then
              echo "GCP_SERVICE_ACCOUNT_KEY=${GCP_SERVICE_ACCOUNT_KEY}" >> $GITHUB_ENV
            fi
          fi

      - name: Authenticate to Google Cloud
        env:
          HAS_GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          HAS_GCP_SERVICE_ACCOUNT_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
        if: ${{ env.HAS_GCP_WORKLOAD_IDENTITY_PROVIDER != '' && env.HAS_GCP_SERVICE_ACCOUNT_EMAIL != '' }}
        uses: google-github-actions/auth@v3
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          create_credentials_file: true
          export_environment_variables: true
          project_id: ${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}
          universe: googleapis.com
          cleanup_credentials: true
          access_token_lifetime: 3600s
          access_token_scopes: https://www.googleapis.com/auth/cloud-platform
          id_token_include_email: false

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup old images
        env:
          KEEP_IMAGES: ${{ env.KEEP_IMAGES || secrets.KEEP_IMAGES || '3' }}
          CLEANUP_OLDER_THAN: ${{ env.CLEANUP_OLDER_THAN || secrets.CLEANUP_OLDER_THAN || '12h' }}
        run: |
          echo "üßπ Starting optimized cleanup process..."
          echo "üìã Configuration:"
          echo "  - Keep last $KEEP_IMAGES images"
          echo "  - Cleanup images older than $CLEANUP_OLDER_THAN"

          # Get list of images sorted by creation date (newest first)
          IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} | \
            head -20 | \
            sort -k2 -r)

          IMAGE_COUNT=$(echo "$IMAGES" | wc -l)
          echo "üìä Found $IMAGE_COUNT images for ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"

          if [ $IMAGE_COUNT -gt $KEEP_IMAGES ]; then
            # Remove images beyond the keep threshold
            IMAGES_TO_REMOVE=$(echo "$IMAGES" | tail -n +$((KEEP_IMAGES + 1)) | awk '{print $1}')
            BATCH_SIZE=5
            echo "$IMAGES_TO_REMOVE" | head -$BATCH_SIZE | while read -r image; do
              echo "üóëÔ∏è Removing $image..."
              docker rmi "$image" || echo "‚ö†Ô∏è Could not remove $image"
            done
            echo "‚úÖ Processed first batch of $(echo "$IMAGES_TO_REMOVE" | head -$BATCH_SIZE | wc -l) images"
          else
            echo "‚úÖ Image count within retention policy"
          fi

          echo "üìä Cleanup completed successfully"
