---
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Slider } from '@/components/ui/slider'
import { Switch } from '@/components/ui/switch'

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Checkbox } from '@/components/ui/checkbox'
import { IconFilter, IconX } from '@/components/ui/icons'

import { cn } from '@/lib/utils'

export interface Props {
  availableEmotionTypes?: string[]
  availablePatternTypes?: string[]
  availablePatternCategories?: string[]
  className?: string
  compact?: boolean
}

const {
  availableEmotionTypes = [],
  availablePatternTypes = [],
  availablePatternCategories = [],
  className = '',
  compact = false,
} = Astro.props
---

<div
  class={cn(
    'bg-card border rounded-md shadow-sm overflow-hidden',
    compact ? 'p-2' : 'p-4',
    className,
  )}
  id="advanced-filtering-component"
>
  <div class="space-y-4">
    <!-- Tab Navigation -->
    <div class="flex border-b">
      <button
        class="tab-button px-3 py-2 border-b-2 border-primary"
        data-tab="time"
      >
        Time Range
      </button>
      <button
        class="tab-button px-3 py-2 border-b-2 border-transparent"
        data-tab="emotions"
      >
        Emotions
      </button>
      <button
        class="tab-button px-3 py-2 border-b-2 border-transparent"
        data-tab="patterns"
      >
        Patterns
      </button>
      <button
        class="tab-button px-3 py-2 border-b-2 border-transparent"
        data-tab="visualization"
      >
        Visualization
      </button>
    </div>

    <!-- Filter Sections -->
    <div id="filter-sections">
      <!-- Time Filters -->
      <div class="filter-section space-y-4" data-section="time">
        <div class="space-y-2">
          <Label>Time Range</Label>
          <Select>
            <SelectTrigger className="w-full">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="day">Last 24 hours</SelectItem>
              <SelectItem value="week">Last 7 days</SelectItem>
              <SelectItem value="month">Last 30 days</SelectItem>
              <SelectItem value="quarter">Last 90 days</SelectItem>
              <SelectItem value="year">Last 365 days</SelectItem>
              <SelectItem value="custom">Custom range</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div id="custom-date-range" class="grid grid-cols-2 gap-4 hidden">
          <div class="space-y-2">
            <Label htmlFor="start-date">Start Date</Label>
            <Input id="start-date" type="date" />
          </div>
          <div class="space-y-2">
            <Label htmlFor="end-date">End Date</Label>
            <Input id="end-date" type="date" />
          </div>
        </div>
      </div>

      <!-- Emotions Filters -->
      <div class="filter-section space-y-4 hidden" data-section="emotions">
        <div class="space-y-2">
          <Label>Emotion Types</Label>
          <div class="grid grid-cols-2 sm:grid-cols-3 gap-2 mt-1">
            {availableEmotionTypes.map((type: string) => (
              <div class="flex items-center space-x-2">
                <Checkbox
                  id={`emotion-${type}`}
                  value={type}
                  className="emotion-type-checkbox"
                />
                <Label htmlFor={`emotion-${type}`} className="cursor-pointer">
                  {type}
                </Label>
              </div>
            ))}
          </div>
        </div>

        <div class="space-y-2">
          <div class="flex justify-between">
            <Label>Intensity Range</Label>
            <span class="text-xs text-gray-500" id="intensity-range-display">
              0.0 - 1.0
            </span>
          </div>
          <div class="pt-2 px-2">
            <div id="intensity-range-slider-wrapper">
              <Slider
                data-min="0"
                data-max="1"
                data-start="0"
                data-end="1"
              />
            </div>
          </div>
        </div>

        <div class="space-y-2">
          <Label>Dimensional Ranges</Label>

          <div class="p-2 border rounded-md space-y-3">
            <div class="space-y-1">
              <div class="flex justify-between">
                <Label>Valence (Negative - Positive)</Label>
                <span class="text-xs text-gray-500" id="valence-range-display">
                  -1.0 - 1.0
                </span>
              </div>
              <div class="pt-1 px-2">
                <div id="valence-range-slider-wrapper">
                  <Slider
                    data-min="-1"
                    data-max="1"
                    data-start="-1"
                    data-end="1"
                  />
                </div>
              </div>
            </div>

            <div class="space-y-1">
              <div class="flex justify-between">
                <Label>Arousal (Calm - Excited)</Label>
                <span class="text-xs text-gray-500" id="arousal-range-display">
                  -1.0 - 1.0
                </span>
              </div>
              <div class="pt-1 px-2">
                <div id="arousal-range-slider-wrapper">
                  <Slider
                    data-min="-1"
                    data-max="1"
                    data-start="-1"
                    data-end="1"
                  />
                </div>
              </div>
            </div>

            <div class="space-y-1">
              <div class="flex justify-between">
                <Label>Dominance (Submissive - Dominant)</Label>
                <span
                  class="text-xs text-gray-500"
                  id="dominance-range-display"
                >
                  -1.0 - 1.0
                </span>
              </div>
              <div class="pt-1 px-2">
                <div id="dominance-range-slider-wrapper">
                  <Slider
                    data-min="-1"
                    data-max="1"
                    data-start="-1"
                    data-end="1"
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Patterns Filters -->
      <div class="filter-section space-y-4 hidden" data-section="patterns">
        <div class="space-y-2">
          <Label>Pattern Types</Label>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-1">
            {
              availablePatternTypes.map((type: string) => (
                <div class="flex items-center space-x-2">
                  <Checkbox
                    id={`pattern-${type}`}
                    value={type}
                    className="pattern-type-checkbox"
                  />
                  <Label htmlFor={`pattern-${type}`} className="cursor-pointer">
                    {type}
                  </Label>
                </div>
              ))
            }
          </div>
        </div>

        <div class="space-y-2">
          <div class="flex justify-between">
            <Label>Minimum Strength</Label>
            <span class="text-xs text-gray-500" id="strength-display">
              0.0
            </span>
          </div>
          <div class="pt-2 px-2">
            <div id="strength-slider-wrapper">
              <Slider
                data-min="0"
                data-max="1"
                data-value="0"
              />
            </div>
          </div>
        </div>

        <div class="space-y-2">
          <div class="flex justify-between">
            <Label>Minimum Confidence</Label>
            <span class="text-xs text-gray-500" id="confidence-display">
              0.0
            </span>
          </div>
          <div class="pt-2 px-2">
            <div id="confidence-slider-wrapper">
              <Slider
                data-min="0"
                data-max="1"
                data-value="0"
              />
            </div>
          </div>
        </div>

        <div class="space-y-2">
          <Label>Pattern Categories</Label>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-1">
            {
              availablePatternCategories.map((category: string) => (
                <div class="flex items-center space-x-2">
                  <Checkbox
                    id={`category-${category}`}
                    value={category}
                    className="pattern-category-checkbox"
                  />
                  <Label
                    htmlFor={`category-${category}`}
                    className="cursor-pointer"
                  >
                    {category}
                  </Label>
                </div>
              ))
            }
          </div>
        </div>
      </div>

      <!-- Visualization Filters -->
      <div class="filter-section space-y-4 hidden" data-section="visualization">
        <div class="space-y-2">
          <Label>Group By</Label>
          <Select>
            <SelectTrigger className="w-full">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="session">Session</SelectItem>
              <SelectItem value="day">Day</SelectItem>
              <SelectItem value="week">Week</SelectItem>
              <SelectItem value="month">Month</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div class="space-y-2">
          <div class="flex justify-between">
            <Label>Smoothing</Label>
            <span class="text-xs text-gray-500" id="smoothing-display">
              0
            </span>
          </div>
          <div class="pt-2 px-2">
            <Slider
              min={0}
              max={10}
              defaultValue={[0]}
              step={1}
            />
          </div>
        </div>

        <div class="space-y-4">
          <div class="flex items-center justify-between">
            <Label htmlFor="show-raw-data">Show Raw Data</Label>
            <Switch id="show-raw-data" />
          </div>

          <div class="flex items-center justify-between">
            <Label htmlFor="show-trendlines">Show Trendlines</Label>
            <Switch id="show-trendlines" />
          </div>

          <div class="flex items-center justify-between">
            <Label htmlFor="show-confidence-intervals"
              >Show Confidence Intervals</Label
            >
            <Switch id="show-confidence-intervals" />
          </div>

          <div class="flex items-center justify-between">
            <Label htmlFor="show-annotations">Show Annotations</Label>
            <Switch id="show-annotations" />
          </div>
        </div>
      </div>
    </div>

    <!-- Action Buttons -->
    <div class="flex justify-between pt-2">
      <Button variant="outline" size="sm" id="reset-filters">
        <IconX className="mr-1 h-4 w-4" />
        Reset
      </Button>
      <Button id="apply-filters">
        <IconFilter className="mr-1 h-4 w-4" />
        Apply Filters
      </Button>
    </div>
  </div>
</div>

<script>
  // We need to initialize the component when it loads
  document.addEventListener('DOMContentLoaded', initializeAdvancedFiltering)

  function initializeAdvancedFiltering(): void {
    const component = document.getElementById('advanced-filtering-component')
    if (!component) return

    // Define proper types for the options object
    interface FilterOptions {
      timeRange: {
        presetRange?: string
        startDate?: Date
        endDate?: Date
      }
      emotions: {
        types: string[]
        minIntensity?: number
        maxIntensity?: number
        dimensionalRanges: {
          valence?: [number, number]
          arousal?: [number, number]
          dominance?: [number, number]
        }
      }
      patterns: {
        types: string[]
        minStrength?: number
        minConfidence?: number
        categories: string[]
      }
      visualization: {
        groupBy?: string
        smoothing?: number
        showRawData?: boolean
        showTrendlines?: boolean
        showConfidenceIntervals?: boolean
        showAnnotations?: boolean
      }
    }

    // JS object to track the current filter state
    const options: FilterOptions = {
      timeRange: {
        presetRange: undefined,
        startDate: undefined,
        endDate: undefined,
      },
      emotions: {
        types: [],
        minIntensity: undefined,
        maxIntensity: undefined,
        dimensionalRanges: {
          valence: undefined,
          arousal: undefined,
          dominance: undefined,
        },
      },
      patterns: {
        types: [],
        minStrength: undefined,
        minConfidence: undefined,
        categories: [],
      },
      visualization: {
        groupBy: undefined,
        smoothing: undefined,
        showRawData: undefined,
        showTrendlines: undefined,
        showConfidenceIntervals: undefined,
        showAnnotations: undefined,
      },
    }

    // Elements
    const tabButtons = component.querySelectorAll('.tab-button')
    const filterSections = component.querySelectorAll('.filter-section')
    const timeRangeSelect = component.querySelector('#time-range-select')
    const customDateRange = component.querySelector('#custom-date-range')
    const startDateInput = component.querySelector('#start-date')
    const endDateInput = component.querySelector('#end-date')
    const emotionTypeCheckboxes = component.querySelectorAll('.emotion-type-checkbox')
    const intensityRangeSlider = component.querySelector('#intensity-range-slider')
    const intensityRangeDisplay = component.querySelector('#intensity-range-display')
    const valenceRangeSlider = component.querySelector('#valence-range-slider')
    const valenceRangeDisplay = component.querySelector('#valence-range-display')
    const arousalRangeSlider = component.querySelector('#arousal-range-slider')
    const arousalRangeDisplay = component.querySelector('#arousal-range-display')
    const dominanceRangeSlider = component.querySelector('#dominance-range-slider')
    const dominanceRangeDisplay = component.querySelector('#dominance-range-display')
    const patternTypeCheckboxes = component.querySelectorAll('.pattern-type-checkbox')
    const strengthSlider = component.querySelector('#strength-slider')
    const strengthDisplay = component.querySelector('#strength-display')
    const confidenceSlider = component.querySelector('#confidence-slider')
    const confidenceDisplay = component.querySelector('#confidence-display')
    const patternCategoryCheckboxes = component.querySelectorAll('.pattern-category-checkbox')
    const groupBySelect = component.querySelector('#group-by-select')
    const smoothingSlider = component.querySelector('#smoothing-slider')
    const smoothingDisplay = component.querySelector('#smoothing-display')
    const showRawDataSwitch = component.querySelector('#show-raw-data')
    const showTrendlinesSwitch = component.querySelector('#show-trendlines')
    const showConfidenceIntervalsSwitch = component.querySelector('#show-confidence-intervals')
    const showAnnotationsSwitch = component.querySelector('#show-annotations')
    const resetButton = component.querySelector('#reset-filters')
    const applyButton = component.querySelector('#apply-filters')

    // Tab switching
    tabButtons.forEach((button) => {
      if (button instanceof HTMLElement) {
        button.addEventListener('click', (_event: MouseEvent) => {
          const tab = button.getAttribute('data-tab')
    
          // Update active tab button
          tabButtons.forEach((btn) => {
            if (btn instanceof HTMLElement) {
              btn.classList.remove('border-primary')
              btn.classList.add('border-transparent')
            }
          })
          button.classList.remove('border-transparent')
          button.classList.add('border-primary')
    
          // Show active section
          filterSections.forEach((section) => {
            if (section.getAttribute('data-section') === tab) {
              section.classList.remove('hidden')
            } else {
              section.classList.add('hidden')
            }
          })
        })
      }
    })

    // Time range select
    if (timeRangeSelect instanceof HTMLElement) {
      timeRangeSelect.addEventListener(
        'valueChange',
        (e) => {
          const event = e as CustomEvent<{ value: string }>
          const value = event.detail?.value || (event.detail as any)
          options.timeRange.presetRange = value
    
          if (value === 'custom') {
            if (customDateRange instanceof HTMLElement) customDateRange.classList.remove('hidden')
          } else {
            if (customDateRange instanceof HTMLElement) customDateRange.classList.add('hidden')
    
            // Calculate dates based on preset
            const today = new Date()
            let startDate: Date | undefined
    
            switch (value) {
              case 'day':
                startDate = new Date(today)
                startDate.setDate(today.getDate() - 1)
                break
              case 'week':
                startDate = new Date(today)
                startDate.setDate(today.getDate() - 7)
                break
              case 'month':
                startDate = new Date(today)
                startDate.setMonth(today.getMonth() - 1)
                break
              case 'quarter':
                startDate = new Date(today)
                startDate.setMonth(today.getMonth() - 3)
                break
              case 'year':
                startDate = new Date(today)
                startDate.setFullYear(today.getFullYear() - 1)
                break
            }
    
            options.timeRange.startDate = startDate ?? undefined
            options.timeRange.endDate = today
          }
        },
      )
    }

    // Date inputs
    if (startDateInput instanceof HTMLInputElement) {
      startDateInput.addEventListener('change', () => {
        options.timeRange.startDate = startDateInput.valueAsDate ?? undefined
      })
    }

    if (endDateInput instanceof HTMLInputElement) {
      endDateInput.addEventListener('change', () => {
        options.timeRange.endDate = endDateInput.valueAsDate ?? undefined
      })
    }

    // Initialize sliders
    if (intensityRangeSlider && intensityRangeDisplay) {
      initializeSlider(
        intensityRangeSlider as HTMLElement,
        intensityRangeDisplay as HTMLElement,
        (values: number[]) => {
          if (values.length === 2 && values[0] != null && values[1] != null) {
            const [min, max] = values
            options.emotions.minIntensity = min
            options.emotions.maxIntensity = max
            intensityRangeDisplay.textContent = `${min.toFixed(1)} - ${max.toFixed(1)}`
          }
        },
      )
    }

    if (valenceRangeSlider instanceof HTMLElement && valenceRangeDisplay instanceof HTMLElement) {
      initializeSlider(
        valenceRangeSlider,
        valenceRangeDisplay,
        (values: number[]) => {
          if (values.length === 2 && values[0] != null && values[1] != null) {
            const [min, max] = values
            if (!options.emotions.dimensionalRanges) {
              options.emotions.dimensionalRanges = { valence: undefined, arousal: undefined, dominance: undefined }
            }
            options.emotions.dimensionalRanges.valence = [min, max]
            valenceRangeDisplay.textContent = `${min.toFixed(1)} - ${max.toFixed(1)}`
          }
        },
      )
    }

    if (arousalRangeSlider instanceof HTMLElement && arousalRangeDisplay instanceof HTMLElement) {
      initializeSlider(
        arousalRangeSlider,
        arousalRangeDisplay,
        (values: number[]) => {
          if (values.length === 2 && values[0] != null && values[1] != null) {
            const [min, max] = values
            if (!options.emotions.dimensionalRanges) {
              options.emotions.dimensionalRanges = { valence: undefined, arousal: undefined, dominance: undefined }
            }
            options.emotions.dimensionalRanges.arousal = [min, max]
            arousalRangeDisplay.textContent = `${min.toFixed(1)} - ${max.toFixed(1)}`
          }
        },
      )
    }

    if (dominanceRangeSlider instanceof HTMLElement && dominanceRangeDisplay instanceof HTMLElement) {
      initializeSlider(
        dominanceRangeSlider,
        dominanceRangeDisplay,
        (values: number[]) => {
          if (values.length === 2 && values[0] != null && values[1] != null) {
            const [min, max] = values
            if (!options.emotions.dimensionalRanges) {
              options.emotions.dimensionalRanges = { valence: undefined, arousal: undefined, dominance: undefined }
            }
            options.emotions.dimensionalRanges.dominance = [min, max]
            dominanceRangeDisplay.textContent = `${min.toFixed(1)} - ${max.toFixed(1)}`
          }
        },
      )
    }

    if (strengthSlider instanceof HTMLElement && strengthDisplay instanceof HTMLElement) {
      initializeSlider(
        strengthSlider,
        strengthDisplay,
        (values: number[]) => {
          if (values.length === 1 && values[0] !== undefined) {
            const value = values[0]
            options.patterns.minStrength = value
            strengthDisplay.textContent = value.toFixed(1)
          }
        },
        true,
      )
    }

    if (confidenceSlider instanceof HTMLElement && confidenceDisplay instanceof HTMLElement) {
      initializeSlider(
        confidenceSlider,
        confidenceDisplay,
        (values: number[]) => {
          if (values.length === 1 && values[0] !== undefined) {
            const value = values[0]
            options.patterns.minConfidence = value
            confidenceDisplay.textContent = value.toFixed(1)
          }
        },
        true,
      )
    }

    if (smoothingSlider instanceof HTMLElement && smoothingDisplay instanceof HTMLElement) {
      initializeSlider(
        smoothingSlider,
        smoothingDisplay,
        (values: number[]) => {
          if (values.length === 1 && values[0] !== undefined) {
            const value = values[0]
            options.visualization.smoothing = value
            smoothingDisplay.textContent = String(value)
          }
        },
        true,
      )
    }

    // Initialize checkbox collections
    emotionTypeCheckboxes.forEach((checkbox) => {
      if (checkbox instanceof HTMLInputElement) {
        checkbox.addEventListener('change', (e: Event) => {
          const target = e.target
          if (target instanceof HTMLInputElement) {
            updateCheckboxArray(target, 'emotions', 'types')
          }
        })
      }
    })

    patternTypeCheckboxes.forEach((checkbox) => {
      if (checkbox instanceof HTMLInputElement) {
        checkbox.addEventListener('change', (e: Event) => {
          const target = e.target
          if (target instanceof HTMLInputElement) {
            updateCheckboxArray(target, 'patterns', 'types')
          }
        })
      }
    })

    patternCategoryCheckboxes.forEach((checkbox) => {
      if (checkbox instanceof HTMLInputElement) {
        checkbox.addEventListener('change', (e: Event) => {
          const target = e.target
          if (target instanceof HTMLInputElement) {
            updateCheckboxArray(target, 'patterns', 'categories')
          }
        })
      }
    })

    // Initialize switches
    if (showRawDataSwitch instanceof HTMLElement) {
      initializeSwitch(showRawDataSwitch, (checked: boolean) => {
        options.visualization.showRawData = checked
      })
    }

    if (showTrendlinesSwitch instanceof HTMLElement) {
      initializeSwitch(showTrendlinesSwitch, (checked: boolean) => {
        options.visualization.showTrendlines = checked
      })
    }

    if (showConfidenceIntervalsSwitch instanceof HTMLElement) {
      initializeSwitch(showConfidenceIntervalsSwitch, (checked: boolean) => {
        options.visualization.showConfidenceIntervals = checked
      })
    }

    if (showAnnotationsSwitch instanceof HTMLElement) {
      initializeSwitch(showAnnotationsSwitch, (checked: boolean) => {
        options.visualization.showAnnotations = checked
      })
    }

    // Group by select
    if (groupBySelect instanceof HTMLElement) {
      groupBySelect.addEventListener(
        'valueChange',
        (e) => {
          const event = e as CustomEvent<{ value: string }>
          options.visualization.groupBy = event.detail?.value || (event.detail as any)
        },
      )
    }

    // Reset button
    if (resetButton) {
      resetButton.addEventListener('click', () => {
        // Reset the options object with proper types
        options.timeRange = { presetRange: undefined, startDate: undefined, endDate: undefined }
        options.emotions = { 
          types: [], 
          minIntensity: undefined, 
          maxIntensity: undefined, 
          dimensionalRanges: { valence: undefined, arousal: undefined, dominance: undefined } 
        }
        options.patterns = { types: [], minStrength: undefined, minConfidence: undefined, categories: [] }
        options.visualization = { 
          groupBy: undefined, 
          smoothing: undefined, 
          showRawData: undefined, 
          showTrendlines: undefined, 
          showConfidenceIntervals: undefined, 
          showAnnotations: undefined 
        }

        // Reset UI elements
        // This would require resetting all the UI elements to their default state
        // For brevity, we're not implementing the full reset here

        // Dispatch change event
        dispatchOptionsChange(options)
      })
    }

    // Apply button
    if (applyButton) {
      applyButton.addEventListener('click', () => {
        dispatchApplyEvent()
      })
    }

    // Helper for slider initialization
    function initializeSlider(
      slider: HTMLElement,
      _display: HTMLElement,
      onChange: (values: number[]) => void,
      singleValue = false,
    ): void {
      if (!slider) return

      let initialValues
      if (singleValue) {
        const value = parseFloat(slider.getAttribute('data-value') || '0')
        initialValues = [value]
      } else {
        const start = parseFloat(slider.getAttribute('data-start') || '0')
        const end = parseFloat(slider.getAttribute('data-end') || '1')
        initialValues = [start, end]
      }

      // For demonstration, we'll just simulate the change event
      onChange(initialValues)

      // Add event listener for value changes
      slider.addEventListener('sliderValueChange', (e) => {
        const event = e as CustomEvent<{ values: number[] }>
        onChange(event.detail?.values || [])
      })
    }

    // Helper for switch initialization
    function initializeSwitch(
      switchEl: HTMLElement,
      onChange: (checked: boolean) => void,
    ): void {
      if (!switchEl) return

      // Initialize with default state
      onChange(false)

      // Add event listener for changes
      switchEl.addEventListener('checkedChange', (e) => {
        const event = e as CustomEvent<boolean>
        onChange(event.detail)
      })
    }

    // Helper for checkbox array updates
    function updateCheckboxArray(
      checkbox: HTMLInputElement,
      category: keyof FilterOptions,
      key: string,
    ): void {
      const value = checkbox.value
      const checked = checkbox.checked

      // Type-safe property access
      const categoryObj = options[category] as any
      
      // Ensure the property exists and is an array
      if (!Array.isArray(categoryObj[key])) {
        categoryObj[key] = []
      }

      const values: string[] = categoryObj[key]

      if (checked) {
        // Add to array if not already present
        if (!values.includes(value)) {
          values.push(value)
        }
      } else {
        // Remove from array
        categoryObj[key] = values.filter((item: string) => item !== value)
      }

      // Dispatch change event
      dispatchOptionsChange(options)
    }

    // Dispatch options change event
    function dispatchOptionsChange(filterOptions: FilterOptions): void {
      if (!component) return

      const event = new CustomEvent('advancedFilterOptionsChange', {
        detail: { options: filterOptions },
        bubbles: true,
      })
      component.dispatchEvent(event)
    }

    // Dispatch apply event
    function dispatchApplyEvent(): void {
      if (!component) return

      const event = new CustomEvent('advancedFilterApply', {
        bubbles: true,
      })
      component.dispatchEvent(event)
    }
  }
</script>

<style>
  /* Any component-specific styles can go here */
  .filter-section {
    transition: all 0.2s ease-in-out;
  }

  .tab-button {
    transition: all 0.2s ease-in-out;
  }

  .tab-button:hover {
    background-color: rgba(0, 0, 0, 0.05);
  }
</style>
