---
// inspired by: https://github.com/antfu/antfu.me/blob/main/src/components/ArtDots.vue
---

<bg-dot
  class="z--1 fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden dark:invert"
  client:load
>
</bg-dot>

<script type="module">
  // Only run on client-side to prevent SSR hydration mismatches
  if (typeof window === 'undefined') {
    console.warn('Dot background component requires browser environment');
  } else {
    // Load p5 from CDN with centralized loading to prevent race conditions
    let p5;
    
    // Check if p5 is already loaded globally
    if (window.p5) {
      p5 = window.p5;
    } else {
      try {
        // Try to import p5 from CDN
        const p5Module = await import('https://cdn.jsdelivr.net/npm/p5@2.0.3/lib/p5.min.js');
        p5 = p5Module.default || window.p5;
      } catch (error) {
        console.warn('Failed to load p5 from CDN, trying fallback:', error);
        // Fallback: load p5 via script tag
        await new Promise((resolve, reject) => {
          if (window.p5) {
            p5 = window.p5;
            resolve();
            return;
          }
          
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/p5@2.0.3/lib/p5.min.js';
          script.onload = () => {
            p5 = window.p5;
            resolve();
          };
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }
    }

    if (!p5) {
      console.error('Failed to load p5.js library');
    } else {
      class BgDotElement extends HTMLElement {
        p5Instance = null

        constructor() {
          super()
          this.p5Instance = null
        }

        connectedCallback() {
          const sketch = (p) => {
            const BACKGROUND = '#fff'
            const SCALE = 200
            const LENGTH = 10
            const SPACING = 15

            const width = window.innerWidth
            const height = window.innerHeight

            const existingPoints = new Set()
            const points = []

            function getForceOnPoint(x, y, z) {
              return (p.noise(x / SCALE, y / SCALE, z) - 0.5) * 2 * p.TWO_PI
            }

            function getLength(x, y, t) {
              return (p.noise(x / SCALE, y / SCALE, t * 2) + 0.5) * LENGTH
            }

            function addPoints() {
              for (let x = -SPACING / 2; x < width + SPACING; x += SPACING) {
                for (let y = -SPACING / 2; y < height + SPACING; y += SPACING) {
                  const id = `${x}-${y}`
                  if (existingPoints.has(id)) continue
                  existingPoints.add(id)
                  points.push({ x, y, opacity: Math.random() * 0.5 + 0.5 })
                }
              }
            }

            p.setup = () => {
              p.createCanvas(width, height)
              p.background(BACKGROUND)
              p.frameRate(30)
              addPoints()
            }

            p.draw = () => {
              p.background(BACKGROUND)

              const t = +new Date() / 10000
              for (const point of points) {
                const { x, y } = point
                const rad = getForceOnPoint(x, y, t)
                const length = getLength(x, y, t)
                const nx = x + p.cos(rad) * length
                const ny = y + p.sin(rad) * length
                p.stroke(
                  200,
                  200,
                  200,
                  (Math.abs(p.cos(rad)) * 0.8 + 0.2) * point.opacity * 255,
                )
                p.strokeWeight(2)
                p.point(nx, ny)
              }
            }
          }

          this.p5Instance = new p5(sketch, this)
        }

        // after switching pages, stop the animation loop
        disconnectedCallback() {
          if (this.p5Instance) {
            this.p5Instance.remove()
            this.p5Instance = null
          }
        }
      }

      customElements.define('bg-dot', BgDotElement);
    }
  }
</script>
