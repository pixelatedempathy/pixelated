name: GKE Deployment Pipeline

permissions:
  contents: read
  id-token: write
  packages: write

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:

env:
  NODE_VERSION: "24"
  PNPM_VERSION: "10.28.1"
  PYTHON_VERSION: "3.11"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Validation stage - fast parallel validation
  validate:
    name: Validate
    runs-on: ubuntu-latest
    strategy:
      matrix:
        validation_type: [dependencies, lint, typecheck]
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Pre-install diagnostics
        if: runner.debug == '1'
        run: |
          echo "üîç CI Environment Diagnostics"
          echo "Node: $(node --version)"
          echo "pnpm: $(pnpm --version)"
          echo "Memory: $(free -h | grep Mem || echo 'N/A')"
          echo "Disk: $(df -h . | tail -1)"
          echo "Package manager in package.json: $(cat package.json | grep packageManager || echo 'not specified')"
          pnpm store path || echo "pnpm store not initialized"

      - name: Load environment from .env
        run: |
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading environment variables from .env file"
            # Export variables that might be in .env
            while IFS= read -r line; do
              if [[ $line =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                export "$line"
              fi
            done < .env
          fi

      - name: Validate package.json
        run: |
          echo "Validating package.json syntax..."
          node -e "JSON.parse(require('fs').readFileSync('package.json', 'utf8'))" && echo "‚úÖ package.json is valid JSON" || (echo "‚ùå package.json has JSON syntax errors" && exit 1)

      - name: Install dependencies
        run: |
          set -o pipefail
          # Enhanced retry logic for pnpm install with comprehensive error handling
          for i in {1..3}; do
            echo "üì¶ Attempt $i of 3: Installing dependencies..."
            ERROR_LOG=$(mktemp)

            if pnpm install --frozen-lockfile --prefer-offline 2>&1 | tee "$ERROR_LOG"; then
              echo "‚úÖ Dependencies installed successfully"
              rm -f "$ERROR_LOG"
              break
            else
              EXIT_CODE=$?
              echo "‚ùå Install failed with exit code: $EXIT_CODE"
              echo "üìù Full error output:"
              cat "$ERROR_LOG"

              # Check for lockfile mismatch
              if grep -qE "ERR_PNPM_LOCKFILE_CONFIG_MISMATCH|overrides.*doesn't match|lockfile.*not compatible" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Lockfile config mismatch detected, updating lockfile..."
                pnpm install --no-frozen-lockfile
                echo "‚úÖ Dependencies installed with updated lockfile"
                rm -f "$ERROR_LOG"
                break
              fi

              # Check for network errors
              if grep -qE "ENOTFOUND|ETIMEDOUT|ECONNRESET|fetch failed|network" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Network error detected"
                if [ $i -eq 3 ]; then
                  echo "‚ùå All install attempts failed due to network issues"
                  rm -f "$ERROR_LOG"
                  exit 1
                fi
              fi

              # Check for peer dependency issues
              if grep -qE "WARN.*peer dep|unmet peer" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Peer dependency warnings detected, trying with --no-strict-peer-dependencies..."
                if pnpm install --frozen-lockfile --no-strict-peer-dependencies 2>&1; then
                  echo "‚úÖ Dependencies installed with relaxed peer dependencies"
                  rm -f "$ERROR_LOG"
                  break
                fi
              fi

              rm -f "$ERROR_LOG"

              if [ $i -lt 3 ]; then
                DELAY=$((5 * i))
                echo "‚è≥ Retrying in $DELAY seconds..."
                sleep $DELAY

                # Clean up partial state
                echo "üßπ Cleaning up partial installation state..."
                rm -rf node_modules/.pnpm || true
                pnpm store prune || true
              else
                echo "‚ùå All install attempts failed"
                echo "üí° Debug information:"
                echo "  - Node version: $(node --version)"
                echo "  - pnpm version: $(pnpm --version)"
                echo "  - Package manager in package.json: $(cat package.json | grep packageManager || echo 'not specified')"
                exit 1
              fi
            fi
          done

      - name: Run ${{ matrix.validation_type }} validation
        run: |
          echo "üîç Running ${{ matrix.validation_type }} validation..."
          case "${{ matrix.validation_type }}" in
            dependencies)
              pnpm audit --audit-level moderate || echo "‚ö†Ô∏è Audit warnings found but continuing"
              ;;
            lint)
              pnpm lint:ci || echo "‚ö†Ô∏è Linting completed with warnings"
              ;;
            typecheck)
              pnpm typecheck || echo "‚ö†Ô∏è Type checking completed with warnings"
              ;;
          esac
          echo "‚úÖ ${{ matrix.validation_type }} validation complete"

  # Build stage - build application and container image
  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    needs: [validate]
    outputs:
      image-tag: ${{ steps.out.outputs.image-tag }}
      image-digest: ${{ steps.out.outputs.image-digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Verify checkout
        run: |
          echo "üîç Verifying checkout completed successfully..."
          echo "üìÇ Working directory: $(pwd)"
          echo "üìÇ GitHub workspace: ${{ github.workspace }}"
          if [[ ! -f "package.json" ]]; then
            echo "‚ùå Checkout verification failed - package.json not found!"
            echo "üìÇ Directory contents:"
            ls -la
            exit 1
          fi
          echo "‚úÖ Checkout verified - repository files present"

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Pre-install diagnostics
        if: runner.debug == '1'
        run: |
          echo "üîç CI Environment Diagnostics"
          echo "Node: $(node --version)"
          echo "pnpm: $(pnpm --version)"
          echo "Memory: $(free -h | grep Mem || echo 'N/A')"
          echo "Disk: $(df -h . | tail -1)"
          echo "Package manager in package.json: $(cat package.json | grep packageManager || echo 'not specified')"
          pnpm store path || echo "pnpm store not initialized"

      - name: Load environment from .env
        run: |
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading environment variables from .env file"
            # Export variables that might be in .env
            while IFS= read -r line; do
              if [[ $line =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                export "$line"
              fi
            done < .env
          fi

      - name: Install dependencies
        run: |
          set -o pipefail
          # Enhanced retry logic for pnpm install with comprehensive error handling
          for i in {1..3}; do
            echo "üì¶ Attempt $i of 3: Installing dependencies..."
            ERROR_LOG=$(mktemp)

            if pnpm install --frozen-lockfile --prefer-offline 2>&1 | tee "$ERROR_LOG"; then
              echo "‚úÖ Dependencies installed successfully"
              rm -f "$ERROR_LOG"
              break
            else
              EXIT_CODE=$?
              echo "‚ùå Install failed with exit code: $EXIT_CODE"
              echo "üìù Full error output:"
              cat "$ERROR_LOG"

              # Check for lockfile mismatch
              if grep -qE "ERR_PNPM_LOCKFILE_CONFIG_MISMATCH|overrides.*doesn't match|lockfile.*not compatible" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Lockfile config mismatch detected, updating lockfile..."
                pnpm install --no-frozen-lockfile
                echo "‚úÖ Dependencies installed with updated lockfile"
                rm -f "$ERROR_LOG"
                break
              fi

              # Check for network errors
              if grep -qE "ENOTFOUND|ETIMEDOUT|ECONNRESET|fetch failed|network" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Network error detected"
                echo "üîç Testing network connectivity..."
                ping -c 1 registry.npmjs.org || echo "Registry connectivity check failed"
                if [ $i -eq 3 ]; then
                  echo "‚ùå All install attempts failed due to network issues"
                  rm -f "$ERROR_LOG"
                  exit 1
                fi
              fi

              # Check for peer dependency issues
              if grep -qE "WARN.*peer dep|unmet peer" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Peer dependency warnings detected, trying with --no-strict-peer-dependencies..."
                if pnpm install --frozen-lockfile --no-strict-peer-dependencies 2>&1; then
                  echo "‚úÖ Dependencies installed with relaxed peer dependencies"
                  rm -f "$ERROR_LOG"
                  break
                fi
              fi

              # Check for git fetch issues
              if grep -qE "git|fetch.*failed|clone.*failed" "$ERROR_LOG"; then
                echo "‚ö†Ô∏è Git fetch error detected"
                echo "üìä Git configuration:"
                git config --list | grep -E "(http|pack|lfs)" || true
              fi

              rm -f "$ERROR_LOG"

              if [ $i -lt 3 ]; then
                DELAY=$((5 * i))
                echo "‚è≥ Retrying in $DELAY seconds..."
                sleep $DELAY

                # Clean up partial state
                echo "üßπ Cleaning up partial installation state..."
                rm -rf node_modules/.pnpm || true
                pnpm store prune || true
              else
                echo "‚ùå All install attempts failed"
                echo "üí° Debug information:"
                echo "  - Node version: $(node --version)"
                echo "  - pnpm version: $(pnpm --version)"
                echo "  - Package manager in package.json: $(cat package.json | grep packageManager || echo 'not specified')"
                echo "  - Available memory: $(free -h | grep Mem || echo 'N/A')"
                exit 1
              fi
            fi
          done

      - name: Build application
        run: |
          echo "üèóÔ∏è Building application with progressive memory optimization..."
          # Use memory-optimized build script for better memory management
          chmod +x ./scripts/memory-optimized-build.sh
          ./scripts/memory-optimized-build.sh
          echo "‚úÖ Application build completed successfully"

      - name: Verify Dockerfile exists
        run: |
          echo "üîç Verifying Dockerfile location..."
          echo "üìÇ Current working directory: $(pwd)"
          echo "üìÇ GitHub workspace: ${{ github.workspace }}"

          # Change to the GitHub workspace directory
          cd "${{ github.workspace }}" || { echo "‚ùå Failed to change to workspace directory"; exit 1; }

          # Verify checkout succeeded by checking for common files
          if [[ ! -f "package.json" ]]; then
            echo "‚ùå Checkout verification failed - package.json not found!"
            echo "üìÇ Current directory contents:"
            ls -la
            echo "üìÇ Expected workspace: ${{ github.workspace }}"
            echo "üìÇ Git configuration:"
            ls -la .git || echo ".git directory not found"
            exit 1
          fi

          # Check for Dockerfile in root
          if [[ -f "Dockerfile" ]]; then
            echo "‚úÖ Dockerfile found at: ${{ github.workspace }}/Dockerfile"
            echo "üìÑ Dockerfile size: $(stat -c%s Dockerfile) bytes"
          else
            echo "‚ùå Dockerfile not found in root directory"
            echo "üìÇ Current directory contents:"
            ls -la | head -20
            echo "üìÇ Looking for Dockerfile in repository:"
            find "${{ github.workspace }}" -name "Dockerfile" -type f 2>/dev/null | head -10 || echo "No Dockerfile found"
            echo "‚ùå Dockerfile verification failed!"
            exit 1
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Free disk space for security scan
        uses: easimon/maximize-build-space@v10
        with:
          root-reserve-mb: 25600
          swap-size-mb: 1
          remove-dotnet: true
          remove-android: true
          remove-haskell: true
          remove-codeql: true
          remove-docker-images: true

      - name: Verify workspace after disk cleanup
        run: |
          echo "üîç Verifying workspace integrity after disk cleanup..."
          if [[ ! -f "package.json" ]] || [[ ! -f "Dockerfile" ]]; then
            echo "‚ùå Workspace files missing after disk cleanup!"
            echo "üìÇ Current directory contents:"
            ls -la
            echo "üìÇ Expected workspace: ${{ github.workspace }}"
            exit 1
          fi
          echo "‚úÖ Workspace integrity verified"

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=main-,format=short
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Load Sentry environment
        run: |
          # Load Sentry variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading Sentry configuration from .env"
            SENTRY_DSN=$(grep "^SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            PUBLIC_SENTRY_DSN=$(grep "^PUBLIC_SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            SENTRY_AUTH_TOKEN=$(grep "^SENTRY_AUTH_TOKEN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")

            if [[ -n "$SENTRY_DSN" ]]; then
              echo "SENTRY_DSN=${SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$PUBLIC_SENTRY_DSN" ]]; then
              echo "PUBLIC_SENTRY_DSN=${PUBLIC_SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$SENTRY_AUTH_TOKEN" ]]; then
              echo "SENTRY_AUTH_TOKEN=${SENTRY_AUTH_TOKEN}" >> $GITHUB_ENV
            fi
          fi

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            SENTRY_RELEASE=${{ github.sha }}
            SENTRY_DSN=${{ env.SENTRY_DSN || secrets.SENTRY_DSN }}
            SENTRY_AUTH_TOKEN=${{ env.SENTRY_AUTH_TOKEN || secrets.SENTRY_AUTH_TOKEN }}
            PUBLIC_SENTRY_DSN=${{ env.PUBLIC_SENTRY_DSN || secrets.PUBLIC_SENTRY_DSN }}

      - name: Output image info
        id: out
        run: |
          # Extract first tag from multi-line tags output
          FIRST_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n 1)
          echo "image-tag=${FIRST_TAG}" >> $GITHUB_OUTPUT
          echo "image-digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT
