{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/errors.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/base64-js/index.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/node_modules/fast-deep-equal/index.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/utils.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/rng.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/regex.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/validate.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/stringify.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v1.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/parse.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v35.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/md5.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v3.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/sha1.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v5.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/v4.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/nil.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/uuid/dist/esm-browser/version.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/loggers.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/messages.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/configuration.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/headers.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/EventSender.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/canonicalize.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/context.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/EventSummarizer.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/MultiEventSummarizer.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/attributeReference.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/ContextFilter.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/EventProcessor.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/EventEmitter.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/InitializationState.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/PersistentFlagStore.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/PersistentStorage.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/Stream.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/promiseCoalescer.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/Requestor.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/Identity.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/AnonymousContextProcessor.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/diagnosticEvents.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/SafeInspector.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/InspectorManager.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/timedPromise.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/HookRunner.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/FlagStore.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/plugins.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/launchdarkly-js-sdk-common/src/index.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/src/basicLogger.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/src/httpRequest.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/node_modules/escape-string-regexp/index.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/src/GoalTracker.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/src/GoalManager.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/src/index.js", "../../node_modules/.pnpm/launchdarkly-js-client-sdk@3.9.0/node_modules/launchdarkly-js-client-sdk/src/browserPlatform.js"],
  "sourcesContent": ["function createCustomError(name) {\n  function CustomError(message, code) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.code = code;\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.name = name;\n  CustomError.prototype.constructor = CustomError;\n\n  return CustomError;\n}\n\nconst LDUnexpectedResponseError = createCustomError('LaunchDarklyUnexpectedResponseError');\nconst LDInvalidEnvironmentIdError = createCustomError('LaunchDarklyInvalidEnvironmentIdError');\nconst LDInvalidUserError = createCustomError('LaunchDarklyInvalidUserError');\nconst LDInvalidEventKeyError = createCustomError('LaunchDarklyInvalidEventKeyError');\nconst LDInvalidArgumentError = createCustomError('LaunchDarklyInvalidArgumentError');\nconst LDFlagFetchError = createCustomError('LaunchDarklyFlagFetchError');\nconst LDInvalidDataError = createCustomError('LaunchDarklyInvalidDataError');\nconst LDTimeoutError = createCustomError('LaunchDarklyTimeoutError');\n\nfunction isHttpErrorRecoverable(status) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}\n\nmodule.exports = {\n  LDUnexpectedResponseError,\n  LDInvalidEnvironmentIdError,\n  LDInvalidUserError,\n  LDInvalidEventKeyError,\n  LDInvalidArgumentError,\n  LDInvalidDataError,\n  LDFlagFetchError,\n  LDTimeoutError,\n  isHttpErrorRecoverable,\n};\n", "'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n", "const base64 = require('base64-js');\nconst fastDeepEqual = require('fast-deep-equal');\n\nconst userAttrsToStringify = ['key', 'ip', 'country', 'email', 'firstName', 'lastName', 'avatar', 'name'];\n\nfunction appendUrlPath(baseUrl, path) {\n  // Ensure that URL concatenation is done correctly regardless of whether the\n  // base URL has a trailing slash or not.\n  const trimBaseUrl = baseUrl.endsWith('/') ? baseUrl.substring(0, baseUrl.length - 1) : baseUrl;\n  return trimBaseUrl + (path.startsWith('/') ? '' : '/') + path;\n}\n\n// See http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\nfunction btoa(s) {\n  const escaped = unescape(encodeURIComponent(s));\n  return base64.fromByteArray(stringToBytes(escaped));\n}\n\nfunction stringToBytes(s) {\n  const b = [];\n  for (let i = 0; i < s.length; i++) {\n    b.push(s.charCodeAt(i));\n  }\n  return b;\n}\n\nfunction base64URLEncode(s) {\n  return (\n    btoa(s)\n      // eslint-disable-next-line\n      .replace(/=/g, '')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n  );\n}\n\nfunction clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction deepEquals(a, b) {\n  return fastDeepEqual(a, b);\n}\n\n// Events emitted in LDClient's initialize method will happen before the consumer\n// can register a listener, so defer them to next tick.\nfunction onNextTick(cb) {\n  setTimeout(cb, 0);\n}\n\n/**\n * Wrap a promise to invoke an optional callback upon resolution or rejection.\n *\n * This function assumes the callback follows the Node.js callback type: (err, value) => void\n *\n * If a callback is provided:\n *   - if the promise is resolved, invoke the callback with (null, value)\n *   - if the promise is rejected, invoke the callback with (error, null)\n *\n * @param {Promise<any>} promise\n * @param {Function} callback\n * @returns Promise<any> | undefined\n */\nfunction wrapPromiseCallback(promise, callback) {\n  const ret = promise.then(\n    value => {\n      if (callback) {\n        setTimeout(() => {\n          callback(null, value);\n        }, 0);\n      }\n      return value;\n    },\n    error => {\n      if (callback) {\n        setTimeout(() => {\n          callback(error, null);\n        }, 0);\n      } else {\n        return Promise.reject(error);\n      }\n    }\n  );\n\n  return !callback ? ret : undefined;\n}\n\n/**\n * Takes a map of flag keys to values, and returns the more verbose structure used by the\n * client stream.\n */\nfunction transformValuesToVersionedValues(flags) {\n  const ret = {};\n  for (const key in flags) {\n    if (objectHasOwnProperty(flags, key)) {\n      ret[key] = { value: flags[key], version: 0 };\n    }\n  }\n  return ret;\n}\n\n/**\n * Converts the internal flag state map to a simple map of flag keys to values.\n */\nfunction transformVersionedValuesToValues(flagsState) {\n  const ret = {};\n  for (const key in flagsState) {\n    if (objectHasOwnProperty(flagsState, key)) {\n      ret[key] = flagsState[key].value;\n    }\n  }\n  return ret;\n}\n\nfunction getLDUserAgentString(platform) {\n  const version = platform.version || '?';\n  return platform.userAgent + '/' + version;\n}\n\nfunction extend(...objects) {\n  return objects.reduce((acc, obj) => ({ ...acc, ...obj }), {});\n}\n\nfunction objectHasOwnProperty(object, name) {\n  return Object.prototype.hasOwnProperty.call(object, name);\n}\n\nfunction sanitizeContext(context) {\n  if (!context) {\n    return context;\n  }\n  let newContext;\n  // Only stringify user attributes for legacy users.\n  if (context.kind === null || context.kind === undefined) {\n    userAttrsToStringify.forEach(attr => {\n      const value = context[attr];\n      if (value !== undefined && typeof value !== 'string') {\n        newContext = newContext || { ...context };\n        newContext[attr] = String(value);\n      }\n    });\n  }\n\n  return newContext || context;\n}\n\n/**\n * Creates a function that will invoke the provided function only once.\n *\n * If the function returns a value, then that returned value will be re-used for subsequent invocations.\n *\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new restricted function.\n */\nfunction once(func) {\n  let called = false;\n  let result;\n  return function(...args) {\n    if (!called) {\n      called = true;\n      result = func.apply(this, args);\n    }\n    return result;\n  };\n}\n\nmodule.exports = {\n  appendUrlPath,\n  base64URLEncode,\n  btoa,\n  clone,\n  deepEquals,\n  extend,\n  getLDUserAgentString,\n  objectHasOwnProperty,\n  onNextTick,\n  sanitizeContext,\n  transformValuesToVersionedValues,\n  transformVersionedValuesToValues,\n  wrapPromiseCallback,\n  once,\n};\n", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;", "import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import rng from './rng.js';\nimport stringify from './stringify.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || stringify(b);\n}\n\nexport default v1;", "import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;", "import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}", "/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;", "import v35 from './v35.js';\nimport md5 from './md5.js';\nvar v3 = v35('v3', 0x30, md5);\nexport default v3;", "// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;", "import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;", "import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;", "export default '00000000-0000-0000-0000-000000000000';", "import validate from './validate.js';\n\nfunction version(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nexport default version;", "const logLevels = ['debug', 'info', 'warn', 'error', 'none'];\n\n/**\n * A simple logger that writes to stderr.\n */\nfunction commonBasicLogger(options, formatFn) {\n  if (options && options.destination && typeof options.destination !== 'function') {\n    throw new Error('destination for basicLogger was set to a non-function');\n  }\n\n  function toConsole(methodName) {\n    // The global console variable is not guaranteed to be defined at all times in all browsers:\n    // https://www.beyondjava.net/console-log-surprises-with-internet-explorer-11-and-edge\n    return function(line) {\n      if (console && console[methodName]) {\n        console[methodName].call(console, line);\n      }\n    };\n  }\n  const destinations =\n    options && options.destination\n      ? [options.destination, options.destination, options.destination, options.destination]\n      : [toConsole('log'), toConsole('info'), toConsole('warn'), toConsole('error')];\n  const prependLevelToMessage = !!(options && options.destination); // if we're writing to console.warn, etc. we don't need the prefix\n  const prefix =\n    !options || options.prefix === undefined || options.prefix === null ? '[LaunchDarkly] ' : options.prefix;\n\n  let minLevel = 1; // default is 'info'\n  if (options && options.level) {\n    for (let i = 0; i < logLevels.length; i++) {\n      if (logLevels[i] === options.level) {\n        minLevel = i;\n      }\n    }\n  }\n\n  function write(levelIndex, levelName, args) {\n    if (args.length < 1) {\n      return;\n    }\n    let line;\n    const fullPrefix = prependLevelToMessage ? levelName + ': ' + prefix : prefix;\n    if (args.length === 1 || !formatFn) {\n      line = fullPrefix + args[0];\n    } else {\n      const tempArgs = [...args];\n      tempArgs[0] = fullPrefix + tempArgs[0];\n      line = formatFn(...tempArgs);\n    }\n    try {\n      destinations[levelIndex](line);\n    } catch (err) {\n      console &&\n        console.log &&\n        console.log(\"[LaunchDarkly] Configured logger's \" + levelName + ' method threw an exception: ' + err);\n    }\n  }\n\n  const logger = {};\n  for (let i = 0; i < logLevels.length; i++) {\n    const levelName = logLevels[i];\n    if (levelName !== 'none') {\n      if (i < minLevel) {\n        logger[levelName] = () => {};\n      } else {\n        const levelIndex = i;\n        logger[levelName] = function() {\n          // can't use arrow function with \"arguments\"\n          write(levelIndex, levelName, arguments);\n        };\n      }\n    }\n  }\n\n  return logger;\n}\n\nfunction validateLogger(logger) {\n  logLevels.forEach(level => {\n    if (level !== 'none' && (!logger[level] || typeof logger[level] !== 'function')) {\n      throw new Error('Provided logger instance must support logger.' + level + '(...) method');\n      // Note that the SDK normally does not throw exceptions to the application, but that rule\n      // does not apply to LDClient.init() which will throw an exception if the parameters are so\n      // invalid that we cannot proceed with creating the client. An invalid logger meets those\n      // criteria since the SDK calls the logger during nearly all of its operations.\n    }\n  });\n}\n\nmodule.exports = {\n  commonBasicLogger,\n  validateLogger,\n};\n", "const errors = require('./errors');\n\nfunction errorString(err) {\n  if (err && err.message) {\n    return err.message;\n  }\n  if (typeof err === 'string' || err instanceof String) {\n    return err;\n  }\n  return JSON.stringify(err);\n}\n\nconst clientInitialized = function() {\n  return 'LaunchDarkly client initialized';\n};\n\nconst docLink =\n  ' Please see https://docs.launchdarkly.com/sdk/client-side/javascript#initialize-the-client for instructions on SDK initialization.';\n\nconst clientNotReady = function() {\n  return 'LaunchDarkly client is not ready';\n};\n\nconst eventCapacityExceeded = function() {\n  return 'Exceeded event queue capacity. Increase capacity to avoid dropping events.';\n};\n\nconst eventWithoutContext = function() {\n  return 'Be sure to call `identify` in the LaunchDarkly client: https://docs.launchdarkly.com/sdk/features/identify#javascript';\n};\n\nconst invalidContentType = function(contentType) {\n  return 'Expected application/json content type but got \"' + contentType + '\"';\n};\n\nconst invalidKey = function() {\n  return 'Event key must be a string';\n};\n\nconst localStorageUnavailable = function(err) {\n  return 'local storage is unavailable: ' + errorString(err);\n};\n\nconst networkError = e => 'network error' + (e ? ' (' + e + ')' : '');\n\n// We should remove unknownCustomEventKey in the future - see comments in track() in index.js\nconst unknownCustomEventKey = function(key) {\n  return 'Custom event \"' + key + '\" does not exist';\n};\n\nconst environmentNotFound = function() {\n  return 'Environment not found. Double check that you specified a valid environment/client-side ID.' + docLink;\n};\n\nconst environmentNotSpecified = function() {\n  return 'No environment/client-side ID was specified.' + docLink;\n};\n\nconst errorFetchingFlags = function(err) {\n  return 'Error fetching flag settings: ' + errorString(err);\n};\n\nconst contextNotSpecified = function() {\n  return 'No context specified.' + docLink;\n};\n\nconst invalidContext = function() {\n  return 'Invalid context specified.' + docLink;\n};\n\nconst invalidData = function() {\n  return 'Invalid data received from LaunchDarkly; connection may have been interrupted';\n};\n\nconst bootstrapOldFormat = function() {\n  return (\n    'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. ' +\n    'Events may not be sent correctly.' +\n    docLink\n  );\n};\n\nconst bootstrapInvalid = function() {\n  return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';\n};\n\nconst deprecated = function(oldName, newName) {\n  if (newName) {\n    return '\"' + oldName + '\" is deprecated, please use \"' + newName + '\"';\n  }\n  return '\"' + oldName + '\" is deprecated';\n};\n\nconst httpErrorMessage = function(status, context, retryMessage) {\n  return (\n    'Received error ' +\n    status +\n    (status === 401 ? ' (invalid SDK key)' : '') +\n    ' for ' +\n    context +\n    ' - ' +\n    (errors.isHttpErrorRecoverable(status) ? retryMessage : 'giving up permanently')\n  );\n};\n\nconst httpUnavailable = function() {\n  return 'Cannot make HTTP requests in this environment.' + docLink;\n};\n\nconst identifyDisabled = function() {\n  return 'identify() has no effect here; it must be called on the main client instance';\n};\n\nconst streamClosing = function() {\n  return 'Closing stream connection';\n};\n\nconst streamConnecting = function(url) {\n  return 'Opening stream connection to ' + url;\n};\n\nconst streamError = function(err, streamReconnectDelay) {\n  return (\n    'Error on stream connection: ' +\n    errorString(err) +\n    ', will continue retrying after ' +\n    streamReconnectDelay +\n    ' milliseconds.'\n  );\n};\n\nconst unknownOption = name => 'Ignoring unknown config option \"' + name + '\"';\n\nconst unrecoverableStreamError = err => `Error on stream connection ${errorString(err)}, giving up permanently`;\n\nconst wrongOptionType = (name, expectedType, actualType) =>\n  'Config option \"' + name + '\" should be of type ' + expectedType + ', got ' + actualType + ', using default value';\n\nconst wrongOptionTypeBoolean = (name, actualType) =>\n  'Config option \"' + name + '\" should be a boolean, got ' + actualType + ', converting to boolean';\n\nconst optionBelowMinimum = (name, value, minimum) =>\n  'Config option \"' + name + '\" was set to ' + value + ', changing to minimum value of ' + minimum;\n\nconst debugPolling = function(url) {\n  return 'polling for feature flags at ' + url;\n};\n\nconst debugStreamPing = function() {\n  return 'received ping message from stream';\n};\n\nconst debugStreamPut = function() {\n  return 'received streaming update for all flags';\n};\n\nconst debugStreamPatch = function(key) {\n  return 'received streaming update for flag \"' + key + '\"';\n};\n\nconst debugStreamPatchIgnored = function(key) {\n  return 'received streaming update for flag \"' + key + '\" but ignored due to version check';\n};\n\nconst debugStreamDelete = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\"';\n};\n\nconst debugStreamDeleteIgnored = function(key) {\n  return 'received streaming deletion for flag \"' + key + '\" but ignored due to version check';\n};\n\nconst debugEnqueueingEvent = function(kind) {\n  return 'enqueueing \"' + kind + '\" event';\n};\n\nconst debugPostingEvents = function(count) {\n  return 'sending ' + count + ' events';\n};\n\nconst debugPostingDiagnosticEvent = function(event) {\n  return 'sending diagnostic event (' + event.kind + ')';\n};\n\nconst invalidInspector = (type, name) => `an inspector: \"${name}\" of an invalid type (${type}) was configured`;\n\nconst inspectorMethodError = (type, name) => `an inspector: \"${name}\" of type: \"${type}\" generated an exception`;\n\nconst invalidTagValue = name => `Config option \"${name}\" must only contain letters, numbers, ., _ or -.`;\n\nconst tagValueTooLong = name => `Value of \"${name}\" was longer than 64 characters and was discarded.`;\n\nconst invalidMetricValue = badType =>\n  `The track function was called with a non-numeric \"metricValue\" (${badType}), only numeric metric values are supported.`;\n\nmodule.exports = {\n  bootstrapInvalid,\n  bootstrapOldFormat,\n  clientInitialized,\n  clientNotReady,\n  debugEnqueueingEvent,\n  debugPostingDiagnosticEvent,\n  debugPostingEvents,\n  debugStreamDelete,\n  debugStreamDeleteIgnored,\n  debugStreamPatch,\n  debugStreamPatchIgnored,\n  debugStreamPing,\n  debugPolling,\n  debugStreamPut,\n  deprecated,\n  environmentNotFound,\n  environmentNotSpecified,\n  errorFetchingFlags,\n  eventCapacityExceeded,\n  eventWithoutContext,\n  httpErrorMessage,\n  httpUnavailable,\n  identifyDisabled,\n  inspectorMethodError,\n  invalidContentType,\n  invalidData,\n  invalidInspector,\n  invalidKey,\n  invalidMetricValue,\n  invalidContext,\n  invalidTagValue,\n  localStorageUnavailable,\n  networkError,\n  optionBelowMinimum,\n  streamClosing,\n  streamConnecting,\n  streamError,\n  tagValueTooLong,\n  unknownCustomEventKey,\n  unknownOption,\n  contextNotSpecified,\n  unrecoverableStreamError,\n  wrongOptionType,\n  wrongOptionTypeBoolean,\n};\n", "const errors = require('./errors');\nconst { validateLogger } = require('./loggers');\nconst messages = require('./messages');\nconst utils = require('./utils');\n\n// baseOptionDefs should contain an entry for each supported configuration option in the common package.\n// Each entry can have three properties:\n// - \"default\": the default value if any\n// - \"type\": a type constraint used if the type can't be inferred from the default value). The allowable\n//   values are \"boolean\", \"string\", \"number\", \"array\", \"object\", \"function\", or several of these OR'd\n//   together with \"|\" (\"function|object\").\n// - \"minimum\": minimum value if any for numeric properties\n//\n// The extraOptionDefs parameter to validate() uses the same format.\nconst baseOptionDefs = {\n  baseUrl: { default: 'https://app.launchdarkly.com' },\n  streamUrl: { default: 'https://clientstream.launchdarkly.com' },\n  eventsUrl: { default: 'https://events.launchdarkly.com' },\n  sendEvents: { default: true },\n  streaming: { type: 'boolean' }, // default for this is undefined, which is different from false\n  sendLDHeaders: { default: true },\n  requestHeaderTransform: { type: 'function' },\n  sendEventsOnlyForVariation: { default: false },\n  useReport: { default: false },\n  evaluationReasons: { default: false },\n  eventCapacity: { default: 100, minimum: 1 },\n  flushInterval: { default: 2000, minimum: 2000 },\n  samplingInterval: { default: 0, minimum: 0 },\n  streamReconnectDelay: { default: 1000, minimum: 0 },\n  allAttributesPrivate: { default: false },\n  privateAttributes: { default: [] },\n  bootstrap: { type: 'string|object' },\n  diagnosticRecordingInterval: { default: 900000, minimum: 2000 },\n  diagnosticOptOut: { default: false },\n  wrapperName: { type: 'string' },\n  wrapperVersion: { type: 'string' },\n  stateProvider: { type: 'object' }, // not a public option, used internally\n  application: { validator: applicationConfigValidator },\n  inspectors: { default: [] },\n  hooks: { default: [] },\n  plugins: { default: [] },\n};\n\n/**\n * Expression to validate characters that are allowed in tag keys and values.\n */\nconst allowedTagCharacters = /^(\\w|\\.|-)+$/;\n\nfunction canonicalizeUrl(url) {\n  return url && url.replace(/\\/+$/, '');\n}\n\n/**\n * Verify that a value meets the requirements for a tag value.\n * @param {string} tagValue\n * @param {Object} logger\n */\nfunction validateTagValue(name, tagValue, logger) {\n  if (typeof tagValue !== 'string' || !tagValue.match(allowedTagCharacters)) {\n    logger.warn(messages.invalidTagValue(name));\n    return undefined;\n  }\n  if (tagValue.length > 64) {\n    logger.warn(messages.tagValueTooLong(name));\n    return undefined;\n  }\n  return tagValue;\n}\n\nfunction applicationConfigValidator(name, value, logger) {\n  const validated = {};\n  if (value.id) {\n    validated.id = validateTagValue(`${name}.id`, value.id, logger);\n  }\n  if (value.version) {\n    validated.version = validateTagValue(`${name}.version`, value.version, logger);\n  }\n  return validated;\n}\n\nfunction validate(options, emitter, extraOptionDefs, logger) {\n  const optionDefs = utils.extend({ logger: { default: logger } }, baseOptionDefs, extraOptionDefs);\n\n  const deprecatedOptions = {\n    // As of the latest major version, there are no deprecated options. Next time we deprecate\n    // something, add an item here where the property name is the deprecated name, and the\n    // property value is the preferred name if any, or null/undefined if there is no replacement.\n  };\n\n  function checkDeprecatedOptions(config) {\n    const opts = config;\n    Object.keys(deprecatedOptions).forEach(oldName => {\n      if (opts[oldName] !== undefined) {\n        const newName = deprecatedOptions[oldName];\n        logger && logger.warn(messages.deprecated(oldName, newName));\n        if (newName) {\n          if (opts[newName] === undefined) {\n            opts[newName] = opts[oldName];\n          }\n          delete opts[oldName];\n        }\n      }\n    });\n  }\n\n  function applyDefaults(config) {\n    // This works differently from utils.extend() in that it *will not* override a default value\n    // if the provided value is explicitly set to null. This provides backward compatibility\n    // since in the past we only used the provided values if they were truthy.\n    const ret = utils.extend({}, config);\n    Object.keys(optionDefs).forEach(name => {\n      if (ret[name] === undefined || ret[name] === null) {\n        ret[name] = optionDefs[name] && optionDefs[name].default;\n      }\n    });\n    return ret;\n  }\n\n  function validateTypesAndNames(config) {\n    const ret = utils.extend({}, config);\n    const typeDescForValue = value => {\n      if (value === null) {\n        return 'any';\n      }\n      if (value === undefined) {\n        return undefined;\n      }\n      if (Array.isArray(value)) {\n        return 'array';\n      }\n      const t = typeof value;\n      if (t === 'boolean' || t === 'string' || t === 'number' || t === 'function') {\n        return t;\n      }\n      return 'object';\n    };\n    Object.keys(config).forEach(name => {\n      const value = config[name];\n      if (value !== null && value !== undefined) {\n        const optionDef = optionDefs[name];\n        if (optionDef === undefined) {\n          reportArgumentError(messages.unknownOption(name));\n        } else {\n          const expectedType = optionDef.type || typeDescForValue(optionDef.default);\n          const validator = optionDef.validator;\n          if (validator) {\n            const validated = validator(name, config[name], logger);\n            if (validated !== undefined) {\n              ret[name] = validated;\n            } else {\n              delete ret[name];\n            }\n          } else if (expectedType !== 'any') {\n            const allowedTypes = expectedType.split('|');\n            const actualType = typeDescForValue(value);\n            if (allowedTypes.indexOf(actualType) < 0) {\n              if (expectedType === 'boolean') {\n                ret[name] = !!value;\n                reportArgumentError(messages.wrongOptionTypeBoolean(name, actualType));\n              } else {\n                reportArgumentError(messages.wrongOptionType(name, expectedType, actualType));\n                ret[name] = optionDef.default;\n              }\n            } else {\n              if (actualType === 'number' && optionDef.minimum !== undefined && value < optionDef.minimum) {\n                reportArgumentError(messages.optionBelowMinimum(name, value, optionDef.minimum));\n                ret[name] = optionDef.minimum;\n              }\n            }\n          }\n        }\n      }\n    });\n\n    ret.baseUrl = canonicalizeUrl(ret.baseUrl);\n    ret.streamUrl = canonicalizeUrl(ret.streamUrl);\n    ret.eventsUrl = canonicalizeUrl(ret.eventsUrl);\n\n    return ret;\n  }\n\n  function reportArgumentError(message) {\n    utils.onNextTick(() => {\n      emitter && emitter.maybeReportError(new errors.LDInvalidArgumentError(message));\n    });\n  }\n\n  let config = utils.extend({}, options || {});\n\n  checkDeprecatedOptions(config);\n\n  config = applyDefaults(config);\n  config = validateTypesAndNames(config);\n  validateLogger(config.logger);\n\n  return config;\n}\n\n/**\n * Get tags for the specified configuration.\n *\n * If any additional tags are added to the configuration, then the tags from\n * this method should be extended with those.\n * @param {Object} config The already valiated configuration.\n * @returns {Object} The tag configuration.\n */\nfunction getTags(config) {\n  const tags = {};\n  if (config) {\n    if (config.application && config.application.id !== undefined && config.application.id !== null) {\n      tags['application-id'] = [config.application.id];\n    }\n    if (config.application && config.application.version !== undefined && config.application.id !== null) {\n      tags['application-version'] = [config.application.version];\n    }\n  }\n\n  return tags;\n}\n\nmodule.exports = {\n  baseOptionDefs,\n  validate,\n  getTags,\n};\n", "const { getLDUserAgentString } = require('./utils');\nconst configuration = require('./configuration');\n\nfunction getLDHeaders(platform, options) {\n  if (options && !options.sendLDHeaders) {\n    return {};\n  }\n  const h = {};\n  h[platform.userAgentHeaderName || 'User-Agent'] = getLDUserAgentString(platform);\n  if (options && options.wrapperName) {\n    h['X-LaunchDarkly-Wrapper'] = options.wrapperVersion\n      ? options.wrapperName + '/' + options.wrapperVersion\n      : options.wrapperName;\n  }\n  const tags = configuration.getTags(options);\n  const tagKeys = Object.keys(tags);\n  if (tagKeys.length) {\n    h['x-launchdarkly-tags'] = tagKeys\n      .sort()\n      .map(key =>\n        Array.isArray(tags[key]) ? tags[key].sort().map(value => `${key}/${value}`) : [`${key}/${tags[key]}`]\n      )\n      .reduce((flattened, item) => flattened.concat(item), [])\n      .join(' ');\n  }\n  return h;\n}\n\nfunction transformHeaders(headers, options) {\n  if (!options || !options.requestHeaderTransform) {\n    return headers;\n  }\n  return options.requestHeaderTransform({ ...headers });\n}\n\nmodule.exports = {\n  getLDHeaders,\n  transformHeaders,\n};\n", "const errors = require('./errors');\nconst utils = require('./utils');\nconst { v1: uuidv1 } = require('uuid');\nconst { getLDHeaders, transformHeaders } = require('./headers');\n\nfunction EventSender(platform, environmentId, options) {\n  const baseHeaders = utils.extend({ 'Content-Type': 'application/json' }, getLDHeaders(platform, options));\n  const sender = {};\n\n  function getResponseInfo(result) {\n    const ret = { status: result.status };\n    const dateStr = result.header('date');\n    if (dateStr) {\n      const time = Date.parse(dateStr);\n      if (time) {\n        ret.serverTime = time;\n      }\n    }\n    return ret;\n  }\n\n  sender.sendEvents = (events, url, isDiagnostic) => {\n    if (!platform.httpRequest) {\n      return Promise.resolve();\n    }\n\n    const jsonBody = JSON.stringify(events);\n    const payloadId = isDiagnostic ? null : uuidv1();\n\n    function doPostRequest(canRetry) {\n      const headers = isDiagnostic\n        ? baseHeaders\n        : utils.extend({}, baseHeaders, {\n            'X-LaunchDarkly-Event-Schema': '4',\n            'X-LaunchDarkly-Payload-ID': payloadId,\n          });\n      return platform\n        .httpRequest('POST', url, transformHeaders(headers, options), jsonBody)\n        .promise.then(result => {\n          if (!result) {\n            // This was a response from a fire-and-forget request, so we won't have a status.\n            return;\n          }\n          if (result.status >= 400 && errors.isHttpErrorRecoverable(result.status) && canRetry) {\n            return doPostRequest(false);\n          } else {\n            return getResponseInfo(result);\n          }\n        })\n        .catch(() => {\n          if (canRetry) {\n            return doPostRequest(false);\n          }\n          return Promise.reject();\n        });\n    }\n\n    return doPostRequest(true).catch(() => {});\n  };\n\n  return sender;\n}\n\nmodule.exports = EventSender;\n", "/**\n * Given some object to serialize product a canonicalized JSON string.\n * https://www.rfc-editor.org/rfc/rfc8785.html\n *\n * We do not support custom toJSON methods on objects. Objects should be limited to basic types.\n *\n * @param {any} object The object to serialize.\n * @param {any[]?} visited The list of objects that have already been visited to avoid cycles.\n * @returns {string} The canonicalized JSON string.\n */\nfunction canonicalize(object, visited = []) {\n  // For JavaScript the default JSON serialization will produce canonicalized output for basic types.\n  if (object === null || typeof object !== 'object') {\n    return JSON.stringify(object);\n  }\n\n  if (visited.includes(object)) {\n    throw new Error('Cycle detected');\n  }\n\n  if (Array.isArray(object)) {\n    const values = object\n      .map(item => canonicalize(item, [...visited, object]))\n      .map(item => (item === undefined ? 'null' : item));\n    return `[${values.join(',')}]`;\n  }\n\n  const values = Object.keys(object)\n    .sort()\n    .map(key => {\n      const value = canonicalize(object[key], [...visited, object]);\n      if (value !== undefined) {\n        return `${JSON.stringify(key)}:${value}`;\n      }\n      return undefined;\n    })\n    .filter(item => item !== undefined);\n  return `{${values.join(',')}}`;\n}\n\nmodule.exports = canonicalize;\n", "const { commonBasicLogger } = require('./loggers');\n\n/**\n * Validate a context kind.\n * @param {string} kind\n * @returns true if the kind is valid.\n */\nfunction validKind(kind) {\n  return typeof kind === 'string' && kind !== 'kind' && kind.match(/^(\\w|\\.|-)+$/);\n}\n\n/**\n * Perform a check of basic context requirements.\n * @param {Object} context\n * @param {boolean} allowLegacyKey If true, then a legacy user can have an\n * empty or non-string key. A legacy user is a context without a kind.\n * @returns true if the context meets basic requirements.\n */\nfunction checkContext(context, allowLegacyKey) {\n  if (context) {\n    if (allowLegacyKey && (context.kind === undefined || context.kind === null)) {\n      return context.key !== undefined && context.key !== null;\n    }\n    const key = context.key;\n    const kind = context.kind === undefined ? 'user' : context.kind;\n    const kindValid = validKind(kind);\n    const keyValid = kind === 'multi' || (key !== undefined && key !== null && key !== '');\n    if (kind === 'multi') {\n      const kinds = Object.keys(context).filter(key => key !== 'kind');\n      return (\n        keyValid &&\n        kinds.every(key => validKind(key)) &&\n        kinds.every(key => {\n          const contextKey = context[key].key;\n          return contextKey !== undefined && contextKey !== null && contextKey !== '';\n        })\n      );\n    }\n    return keyValid && kindValid;\n  }\n  return false;\n}\n\n/**\n * For a given context get a list of context kinds.\n * @param {Object} context\n * @returns {string[]} A list of kinds in the context.\n */\nfunction getContextKinds(context) {\n  if (context) {\n    if (context.kind === null || context.kind === undefined) {\n      return ['user'];\n    }\n    if (context.kind !== 'multi') {\n      return [context.kind];\n    }\n    return Object.keys(context).filter(kind => kind !== 'kind');\n  }\n  return [];\n}\n\n/**\n * The partial URL encoding is needed because : is a valid character in context keys.\n *\n * Partial encoding is the replacement of all colon (:) characters with the URL\n * encoded equivalent (%3A) and all percent (%) characters with the URL encoded\n * equivalent (%25).\n * @param {string} key The key to encode.\n * @returns {string} Partially URL encoded key.\n */\nfunction encodeKey(key) {\n  if (key.includes('%') || key.includes(':')) {\n    return key.replace(/%/g, '%25').replace(/:/g, '%3A');\n  }\n  return key;\n}\n\nfunction getCanonicalKey(context) {\n  if (context) {\n    if ((context.kind === undefined || context.kind === null || context.kind === 'user') && context.key) {\n      return context.key;\n    } else if (context.kind !== 'multi' && context.key) {\n      return `${context.kind}:${encodeKey(context.key)}`;\n    } else if (context.kind === 'multi') {\n      return Object.keys(context)\n        .sort()\n        .filter(key => key !== 'kind')\n        .map(key => `${key}:${encodeKey(context[key].key)}`)\n        .join(':');\n    }\n  }\n}\n\nfunction getContextKeys(context, logger = commonBasicLogger()) {\n  if (!context) {\n    return undefined;\n  }\n\n  const keys = {};\n  const { kind, key } = context;\n\n  switch (kind) {\n    case undefined:\n      keys.user = `${key}`;\n      break;\n    case 'multi':\n      Object.entries(context)\n        .filter(([key]) => key !== 'kind')\n        .forEach(([key, value]) => {\n          if (value && value.key) {\n            keys[key] = value.key;\n          }\n        });\n      break;\n    case null:\n      logger.warn(`null is not a valid context kind: ${context}`);\n      break;\n    case '':\n      logger.warn(`'' is not a valid context kind: ${context}`);\n      break;\n    default:\n      keys[kind] = `${key}`;\n      break;\n  }\n\n  return keys;\n}\n\nmodule.exports = {\n  checkContext,\n  getContextKeys,\n  getContextKinds,\n  getCanonicalKey,\n};\n", "const { getContextKinds } = require('./context');\n\nfunction getKinds(event) {\n  if (event.context) {\n    return getContextKinds(event.context);\n  }\n  if (event.contextKeys) {\n    return Object.keys(event.contextKeys);\n  }\n  return [];\n}\n\nfunction EventSummarizer() {\n  const es = {};\n\n  let startDate = 0,\n    endDate = 0,\n    counters = {},\n    contextKinds = {};\n\n  es.summarizeEvent = event => {\n    if (event.kind === 'feature') {\n      const counterKey =\n        event.key +\n        ':' +\n        (event.variation !== null && event.variation !== undefined ? event.variation : '') +\n        ':' +\n        (event.version !== null && event.version !== undefined ? event.version : '');\n      const counterVal = counters[counterKey];\n      let kinds = contextKinds[event.key];\n      if (!kinds) {\n        kinds = new Set();\n        contextKinds[event.key] = kinds;\n      }\n      getKinds(event).forEach(kind => kinds.add(kind));\n\n      if (counterVal) {\n        counterVal.count = counterVal.count + 1;\n      } else {\n        counters[counterKey] = {\n          count: 1,\n          key: event.key,\n          version: event.version,\n          variation: event.variation,\n          value: event.value,\n          default: event.default,\n        };\n      }\n      if (startDate === 0 || event.creationDate < startDate) {\n        startDate = event.creationDate;\n      }\n      if (event.creationDate > endDate) {\n        endDate = event.creationDate;\n      }\n    }\n  };\n\n  es.getSummary = () => {\n    const flagsOut = {};\n    let empty = true;\n    for (const c of Object.values(counters)) {\n      let flag = flagsOut[c.key];\n      if (!flag) {\n        flag = {\n          default: c.default,\n          counters: [],\n          contextKinds: [...contextKinds[c.key]],\n        };\n        flagsOut[c.key] = flag;\n      }\n      const counterOut = {\n        value: c.value,\n        count: c.count,\n      };\n      if (c.variation !== undefined && c.variation !== null) {\n        counterOut.variation = c.variation;\n      }\n      if (c.version !== undefined && c.version !== null) {\n        counterOut.version = c.version;\n      } else {\n        counterOut.unknown = true;\n      }\n      flag.counters.push(counterOut);\n      empty = false;\n    }\n    return empty\n      ? null\n      : {\n          startDate,\n          endDate,\n          features: flagsOut,\n          kind: 'summary',\n        };\n  };\n\n  es.clearSummary = () => {\n    startDate = 0;\n    endDate = 0;\n    counters = {};\n    contextKinds = {};\n  };\n\n  return es;\n}\n\nmodule.exports = EventSummarizer;\n", "const canonicalize = require('./canonicalize');\nconst EventSummarizer = require('./EventSummarizer');\n\n/**\n * Construct a multi-event summarizer. This summarizer produces a summary event for each unique context.\n * @param {{filter: (context: any) => any}} contextFilter\n */\nfunction MultiEventSummarizer(contextFilter) {\n  let summarizers = {};\n  let contexts = {};\n\n  /**\n   * Summarize the given event.\n   * @param {{\n   *   kind: string,\n   *   context?: any,\n   * }} event\n   */\n  function summarizeEvent(event) {\n    if (event.kind === 'feature') {\n      const key = canonicalize(event.context);\n      if (!key) {\n        return;\n      }\n\n      let summarizer = summarizers[key];\n      if (!summarizer) {\n        summarizers[key] = EventSummarizer();\n        summarizer = summarizers[key];\n        contexts[key] = event.context;\n      }\n\n      summarizer.summarizeEvent(event);\n    }\n  }\n\n  /**\n   * Get the summaries of the events that have been summarized.\n   * @returns {any[]}\n   */\n  function getSummaries() {\n    const summarizersToFlush = summarizers;\n    const contextsForSummaries = contexts;\n\n    summarizers = {};\n    contexts = {};\n    return Object.entries(summarizersToFlush).map(([key, summarizer]) => {\n      const summary = summarizer.getSummary();\n      summary.context = contextFilter.filter(contextsForSummaries[key]);\n      return summary;\n    });\n  }\n\n  return {\n    summarizeEvent,\n    getSummaries,\n  };\n}\n\nmodule.exports = MultiEventSummarizer;\n", "/**\n * Take a key string and escape the characters to allow it to be used as a reference.\n * @param {string} key\n * @returns {string} The processed key.\n */\nfunction processEscapeCharacters(key) {\n  return key.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n/**\n * @param {string} reference The reference to get the components of.\n * @returns {string[]} The components of the reference. Escape characters will be converted to their representative values.\n */\nfunction getComponents(reference) {\n  const referenceWithoutPrefix = reference.startsWith('/') ? reference.substring(1) : reference;\n  return referenceWithoutPrefix\n    .split('/')\n    .map(component => (component.indexOf('~') >= 0 ? component.replace(/~1/g, '/').replace(/~0/g, '~') : component));\n}\n\n/**\n * @param {string} reference The reference to check if it is a literal.\n * @returns true if the reference is a literal.\n */\nfunction isLiteral(reference) {\n  return !reference.startsWith('/');\n}\n\n/**\n * Compare two references and determine if they are equivalent.\n * @param {string} a\n * @param {string} b\n */\nfunction compare(a, b) {\n  const aIsLiteral = isLiteral(a);\n  const bIsLiteral = isLiteral(b);\n  if (aIsLiteral && bIsLiteral) {\n    return a === b;\n  }\n  if (aIsLiteral) {\n    const bComponents = getComponents(b);\n    if (bComponents.length !== 1) {\n      return false;\n    }\n    return a === bComponents[0];\n  }\n  if (bIsLiteral) {\n    const aComponents = getComponents(a);\n    if (aComponents.length !== 1) {\n      return false;\n    }\n    return b === aComponents[0];\n  }\n  return a === b;\n}\n\n/**\n * @param {string} a\n * @param {string} b\n * @returns The two strings joined by '/'.\n */\nfunction join(a, b) {\n  return `${a}/${b}`;\n}\n\n/**\n * There are cases where a field could have been named with a preceeding '/'.\n * If that attribute was private, then the literal would appear to be a reference.\n * This method can be used to convert a literal to a reference in such situations.\n * @param {string} literal The literal to convert to a reference.\n * @returns A literal which has been converted to a reference.\n */\nfunction literalToReference(literal) {\n  return `/${processEscapeCharacters(literal)}`;\n}\n\n/**\n * Clone an object excluding the values referenced by a list of references.\n * @param {Object} target The object to clone.\n * @param {string[]} references A list of references from the cloned object.\n * @returns {{cloned: Object, excluded: string[]}} The cloned object and a list of excluded values.\n */\nfunction cloneExcluding(target, references) {\n  const stack = [];\n  const cloned = {};\n  const excluded = [];\n\n  stack.push(\n    ...Object.keys(target).map(key => ({\n      key,\n      ptr: literalToReference(key),\n      source: target,\n      parent: cloned,\n      visited: [target],\n    }))\n  );\n\n  while (stack.length) {\n    const item = stack.pop();\n    if (!references.some(ptr => compare(ptr, item.ptr))) {\n      const value = item.source[item.key];\n\n      // Handle null because it overlaps with object, which we will want to handle later.\n      if (value === null) {\n        item.parent[item.key] = value;\n      } else if (Array.isArray(value)) {\n        item.parent[item.key] = [...value];\n      } else if (typeof value === 'object') {\n        //Arrays and null must already be handled.\n\n        //Prevent cycles by not visiting the same object\n        //with in the same branch. Parallel branches\n        //may contain the same object.\n        if (item.visited.includes(value)) {\n          continue;\n        }\n\n        item.parent[item.key] = {};\n\n        stack.push(\n          ...Object.keys(value).map(key => ({\n            key,\n            ptr: join(item.ptr, processEscapeCharacters(key)),\n            source: value,\n            parent: item.parent[item.key],\n            visited: [...item.visited, value],\n          }))\n        );\n      } else {\n        item.parent[item.key] = value;\n      }\n    } else {\n      excluded.push(item.ptr);\n    }\n  }\n  return { cloned, excluded: excluded.sort() };\n}\n\nmodule.exports = {\n  cloneExcluding,\n  compare,\n  literalToReference,\n};\n", "const AttributeReference = require('./attributeReference');\n\nfunction ContextFilter(config) {\n  const filter = {};\n\n  const allAttributesPrivate = config.allAttributesPrivate;\n  const privateAttributes = config.privateAttributes || [];\n\n  // These attributes cannot be removed via a private attribute.\n  const protectedAttributes = ['key', 'kind', '_meta', 'anonymous'];\n\n  const legacyTopLevelCopyAttributes = ['name', 'ip', 'firstName', 'lastName', 'email', 'avatar', 'country'];\n\n  /**\n   * For the given context and configuration get a list of attributes to filter.\n   * @param {Object} context\n   * @returns {string[]} A list of the attributes to filter.\n   */\n  const getAttributesToFilter = (context, redactAnonymous) =>\n    (allAttributesPrivate || (redactAnonymous && context.anonymous)\n      ? Object.keys(context)\n      : [...privateAttributes, ...((context._meta && context._meta.privateAttributes) || [])]\n    ).filter(attr => !protectedAttributes.some(protectedAttr => AttributeReference.compare(attr, protectedAttr)));\n\n  /**\n   * @param {Object} context\n   * @param {boolean} redactAnonymous\n   * @returns {Object} A copy of the context with private attributes removed,\n   * and the redactedAttributes meta populated.\n   */\n  const filterSingleKind = (context, redactAnonymous) => {\n    if (typeof context !== 'object' || context === null || Array.isArray(context)) {\n      return undefined;\n    }\n\n    const { cloned, excluded } = AttributeReference.cloneExcluding(\n      context,\n      getAttributesToFilter(context, redactAnonymous)\n    );\n    cloned.key = String(cloned.key);\n    if (excluded.length) {\n      if (!cloned._meta) {\n        cloned._meta = {};\n      }\n      cloned._meta.redactedAttributes = excluded;\n    }\n    if (cloned._meta) {\n      delete cloned._meta['privateAttributes'];\n      if (Object.keys(cloned._meta).length === 0) {\n        delete cloned._meta;\n      }\n    }\n    // Make sure anonymous is boolean if present.\n    // Null counts as present, and would be falsy, which is the default.\n    if (cloned.anonymous !== undefined) {\n      cloned.anonymous = !!cloned.anonymous;\n    }\n\n    return cloned;\n  };\n\n  /**\n   * @param {Object} context\n   * @param {boolean} redactAnonymous\n   * @returns {Object} A copy of the context with the private attributes removed,\n   * and the redactedAttributes meta populated for each sub-context.\n   */\n  const filterMultiKind = (context, redactAnonymous) => {\n    const filtered = {\n      kind: context.kind,\n    };\n    const contextKeys = Object.keys(context);\n\n    for (const contextKey of contextKeys) {\n      if (contextKey !== 'kind') {\n        const filteredContext = filterSingleKind(context[contextKey], redactAnonymous);\n        if (filteredContext) {\n          filtered[contextKey] = filteredContext;\n        }\n      }\n    }\n    return filtered;\n  };\n\n  /**\n   * Convert the LDUser object into an LDContext object.\n   * @param {Object} user The LDUser to produce an LDContext for.\n   * @returns {Object} A single kind context based on the provided user.\n   */\n  const legacyToSingleKind = user => {\n    const filtered = {\n      /* Destructure custom items into the top level.\n         Duplicate keys will be overridden by previously\n         top level items.\n      */\n      ...(user.custom || {}),\n\n      // Implicity a user kind.\n      kind: 'user',\n\n      key: user.key,\n    };\n\n    if (user.anonymous !== undefined) {\n      filtered.anonymous = !!user.anonymous;\n    }\n\n    // Copy top level keys and convert them to strings.\n    // Remove keys that may have been destructured from `custom`.\n    for (const key of legacyTopLevelCopyAttributes) {\n      delete filtered[key];\n      if (user[key] !== undefined && user[key] !== null) {\n        filtered[key] = String(user[key]);\n      }\n    }\n\n    if (user.privateAttributeNames !== undefined && user.privateAttributeNames !== null) {\n      filtered._meta = filtered._meta || {};\n      // If any private attributes started with '/' we need to convert them to references, otherwise the '/' will\n      // cause the literal to incorrectly be treated as a reference.\n      filtered._meta.privateAttributes = user.privateAttributeNames.map(literal =>\n        literal.startsWith('/') ? AttributeReference.literalToReference(literal) : literal\n      );\n    }\n\n    return filtered;\n  };\n\n  filter.filter = (context, redactAnonymous = false) => {\n    if (context.kind === undefined || context.kind === null) {\n      return filterSingleKind(legacyToSingleKind(context), redactAnonymous);\n    } else if (context.kind === 'multi') {\n      return filterMultiKind(context, redactAnonymous);\n    } else {\n      return filterSingleKind(context, redactAnonymous);\n    }\n  };\n\n  return filter;\n}\n\nmodule.exports = ContextFilter;\n", "const EventSender = require('./EventSender');\nconst MultiEventSummarizer = require('./MultiEventSummarizer');\nconst ContextFilter = require('./ContextFilter');\nconst errors = require('./errors');\nconst messages = require('./messages');\nconst utils = require('./utils');\nconst { getContextKeys } = require('./context');\n\nfunction EventProcessor(\n  platform,\n  options,\n  environmentId,\n  diagnosticsAccumulator = null,\n  emitter = null,\n  sender = null\n) {\n  const processor = {};\n  const eventSender = sender || EventSender(platform, environmentId, options);\n  const mainEventsUrl = utils.appendUrlPath(options.eventsUrl, '/events/bulk/' + environmentId);\n  const contextFilter = ContextFilter(options);\n  const summarizer = MultiEventSummarizer(contextFilter);\n  const samplingInterval = options.samplingInterval;\n  const eventCapacity = options.eventCapacity;\n  const flushInterval = options.flushInterval;\n  const logger = options.logger;\n  let queue = [];\n  let lastKnownPastTime = 0;\n  let disabled = false;\n  let exceededCapacity = false;\n  let flushTimer;\n\n  function shouldSampleEvent() {\n    return samplingInterval === 0 || Math.floor(Math.random() * samplingInterval) === 0;\n  }\n\n  function shouldDebugEvent(e) {\n    if (e.debugEventsUntilDate) {\n      // The \"last known past time\" comes from the last HTTP response we got from the server.\n      // In case the client's time is set wrong, at least we know that any expiration date\n      // earlier than that point is definitely in the past.  If there's any discrepancy, we\n      // want to err on the side of cutting off event debugging sooner.\n      return e.debugEventsUntilDate > lastKnownPastTime && e.debugEventsUntilDate > new Date().getTime();\n    }\n    return false;\n  }\n\n  // Transform an event from its internal format to the format we use when sending a payload.\n  function makeOutputEvent(e) {\n    const ret = utils.extend({}, e);\n\n    // Identify, feature, and custom events should all include the full context.\n    // Debug events do as well, but are not handled by this code path.\n    if (e.kind === 'identify' || e.kind === 'feature' || e.kind === 'custom') {\n      ret.context = contextFilter.filter(e.context);\n    } else {\n      ret.contextKeys = getContextKeysFromEvent(e);\n      delete ret['context'];\n    }\n\n    if (e.kind === 'feature') {\n      delete ret['trackEvents'];\n      delete ret['debugEventsUntilDate'];\n    }\n    return ret;\n  }\n\n  function getContextKeysFromEvent(event) {\n    return getContextKeys(event.context, logger);\n  }\n\n  function addToOutbox(event) {\n    if (queue.length < eventCapacity) {\n      queue.push(event);\n      exceededCapacity = false;\n    } else {\n      if (!exceededCapacity) {\n        exceededCapacity = true;\n        logger.warn(messages.eventCapacityExceeded());\n      }\n      if (diagnosticsAccumulator) {\n        // For diagnostic events, we track how many times we had to drop an event due to exceeding the capacity.\n        diagnosticsAccumulator.incrementDroppedEvents();\n      }\n    }\n  }\n\n  processor.enqueue = function(event) {\n    if (disabled) {\n      return;\n    }\n    let addFullEvent = false;\n    let addDebugEvent = false;\n\n    // Add event to the summary counters if appropriate\n    summarizer.summarizeEvent(event);\n\n    // Decide whether to add the event to the payload. Feature events may be added twice, once for\n    // the event (if tracked) and once for debugging.\n    if (event.kind === 'feature') {\n      if (shouldSampleEvent()) {\n        addFullEvent = !!event.trackEvents;\n        addDebugEvent = shouldDebugEvent(event);\n      }\n    } else {\n      addFullEvent = shouldSampleEvent();\n    }\n\n    if (addFullEvent) {\n      addToOutbox(makeOutputEvent(event));\n    }\n    if (addDebugEvent) {\n      const debugEvent = utils.extend({}, event, { kind: 'debug' });\n      debugEvent.context = contextFilter.filter(debugEvent.context);\n      delete debugEvent['trackEvents'];\n      delete debugEvent['debugEventsUntilDate'];\n      addToOutbox(debugEvent);\n    }\n  };\n\n  processor.flush = async function() {\n    if (disabled) {\n      return Promise.resolve();\n    }\n    const eventsToSend = queue;\n    const summaries = summarizer.getSummaries();\n\n    summaries.forEach(summary => {\n      if (Object.keys(summary.features).length) {\n        eventsToSend.push(summary);\n      }\n    });\n\n    if (diagnosticsAccumulator) {\n      // For diagnostic events, we record how many events were in the queue at the last flush (since \"how\n      // many events happened to be in the queue at the moment we decided to send a diagnostic event\" would\n      // not be a very useful statistic).\n      diagnosticsAccumulator.setEventsInLastBatch(eventsToSend.length);\n    }\n    if (eventsToSend.length === 0) {\n      return Promise.resolve();\n    }\n    queue = [];\n    logger.debug(messages.debugPostingEvents(eventsToSend.length));\n    return eventSender.sendEvents(eventsToSend, mainEventsUrl).then(responseInfo => {\n      if (responseInfo) {\n        if (responseInfo.serverTime) {\n          lastKnownPastTime = responseInfo.serverTime;\n        }\n        if (!errors.isHttpErrorRecoverable(responseInfo.status)) {\n          disabled = true;\n        }\n        if (responseInfo.status >= 400) {\n          utils.onNextTick(() => {\n            emitter.maybeReportError(\n              new errors.LDUnexpectedResponseError(\n                messages.httpErrorMessage(responseInfo.status, 'event posting', 'some events were dropped')\n              )\n            );\n          });\n        }\n      }\n    });\n  };\n\n  processor.start = function() {\n    const flushTick = () => {\n      processor.flush();\n      flushTimer = setTimeout(flushTick, flushInterval);\n    };\n    flushTimer = setTimeout(flushTick, flushInterval);\n  };\n\n  processor.stop = function() {\n    clearTimeout(flushTimer);\n  };\n\n  return processor;\n}\n\nmodule.exports = EventProcessor;\n", "function EventEmitter(logger) {\n  const emitter = {};\n  const events = {};\n\n  const listeningTo = event => !!events[event];\n\n  emitter.on = function(event, handler, context) {\n    events[event] = events[event] || [];\n    events[event] = events[event].concat({\n      handler: handler,\n      context: context,\n    });\n  };\n\n  emitter.off = function(event, handler, context) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      if (events[event][i].handler === handler && events[event][i].context === context) {\n        events[event] = events[event].slice(0, i).concat(events[event].slice(i + 1));\n      }\n    }\n  };\n\n  emitter.emit = function(event) {\n    if (!events[event]) {\n      return;\n    }\n    // Copy the list of handlers before iterating, in case any handler adds or removes another handler.\n    // Any such changes should not affect what we do here-- we want to notify every handler that existed\n    // at the moment that the event was fired.\n    const copiedHandlers = events[event].slice(0);\n    for (let i = 0; i < copiedHandlers.length; i++) {\n      copiedHandlers[i].handler.apply(copiedHandlers[i].context, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  emitter.getEvents = function() {\n    return Object.keys(events);\n  };\n\n  emitter.getEventListenerCount = function(event) {\n    return events[event] ? events[event].length : 0;\n  };\n\n  emitter.maybeReportError = function(error) {\n    if (!error) {\n      return;\n    }\n    if (listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      (logger || console).error(error.message);\n    }\n  };\n  return emitter;\n}\n\nmodule.exports = EventEmitter;\n", "// This file provides an abstraction of the client's startup state.\n//\n// Startup can either succeed or fail exactly once; calling signalSuccess() or signalFailure()\n// after that point has no effect.\n//\n// On success, we fire both an \"initialized\" event and a \"ready\" event. Both the waitForInitialization()\n// promise and the waitUntilReady() promise are resolved in this case.\n//\n// On failure, we fire both a \"failed\" event (with the error as a parameter) and a \"ready\" event.\n// The waitForInitialization() promise is rejected, but the waitUntilReady() promise is resolved.\n//\n// To complicate things, we must *not* create the waitForInitialization() promise unless it is\n// requested, because otherwise failures would cause an *unhandled* rejection which can be a\n// serious problem in some environments. So we use a somewhat roundabout system for tracking the\n// initialization state and lazily creating this promise.\n\nconst readyEvent = 'ready',\n  successEvent = 'initialized',\n  failureEvent = 'failed';\n\nfunction InitializationStateTracker(eventEmitter) {\n  let succeeded = false,\n    failed = false,\n    failureValue = null,\n    initializationPromise = null;\n\n  const readyPromise = new Promise(resolve => {\n    const onReady = () => {\n      eventEmitter.off(readyEvent, onReady); // we can't use \"once\" because it's not available on some JS platforms\n      resolve();\n    };\n    eventEmitter.on(readyEvent, onReady);\n  }).catch(() => {}); // this Promise should never be rejected, but the catch handler is a safety measure\n\n  return {\n    getInitializationPromise: () => {\n      if (initializationPromise) {\n        return initializationPromise;\n      }\n      if (succeeded) {\n        return Promise.resolve();\n      }\n      if (failed) {\n        return Promise.reject(failureValue);\n      }\n      initializationPromise = new Promise((resolve, reject) => {\n        const onSuccess = () => {\n          eventEmitter.off(successEvent, onSuccess);\n          resolve();\n        };\n        const onFailure = err => {\n          eventEmitter.off(failureEvent, onFailure);\n          reject(err);\n        };\n        eventEmitter.on(successEvent, onSuccess);\n        eventEmitter.on(failureEvent, onFailure);\n      });\n      return initializationPromise;\n    },\n\n    getReadyPromise: () => readyPromise,\n\n    signalSuccess: () => {\n      if (!succeeded && !failed) {\n        succeeded = true;\n        eventEmitter.emit(successEvent);\n        eventEmitter.emit(readyEvent);\n      }\n    },\n\n    signalFailure: err => {\n      if (!succeeded && !failed) {\n        failed = true;\n        failureValue = err;\n        eventEmitter.emit(failureEvent, err);\n        eventEmitter.emit(readyEvent);\n      }\n      eventEmitter.maybeReportError(err); // the \"error\" event can be emitted more than once, unlike the others\n    },\n  };\n}\n\nmodule.exports = InitializationStateTracker;\n", "const utils = require('./utils');\n\nfunction PersistentFlagStore(storage, environment, hash, ident) {\n  const store = {};\n\n  function getFlagsKey() {\n    let key = '';\n    const context = ident.getContext();\n    if (context) {\n      key = hash || utils.btoa(JSON.stringify(context));\n    }\n    return 'ld:' + environment + ':' + key;\n  }\n\n  // Returns a Promise which will be resolved with a parsed JSON value if a stored value was available,\n  // or resolved with null if there was no value or if storage was not available.\n  store.loadFlags = () =>\n    storage.get(getFlagsKey()).then(dataStr => {\n      if (dataStr === null || dataStr === undefined) {\n        return null;\n      }\n      try {\n        let data = JSON.parse(dataStr);\n        if (data) {\n          const schema = data.$schema;\n          if (schema === undefined || schema < 1) {\n            data = utils.transformValuesToVersionedValues(data);\n          } else {\n            delete data['$schema'];\n          }\n        }\n        return data;\n      } catch (ex) {\n        return store.clearFlags().then(() => null);\n      }\n    });\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  store.saveFlags = flags => {\n    const data = utils.extend({}, flags, { $schema: 1 });\n    return storage.set(getFlagsKey(), JSON.stringify(data));\n  };\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  store.clearFlags = () => storage.clear(getFlagsKey());\n\n  return store;\n}\n\nmodule.exports = PersistentFlagStore;\n", "const messages = require('./messages');\n\n// The localStorageProvider is provided by the platform object. It should have the following\n// methods, each of which should return a Promise:\n// - get(key): Gets the string value, if any, for the given key\n// - set(key, value): Stores a string value for the given key\n// - remove(key): Removes the given key\n//\n// Storage is just a light wrapper of the localStorageProvider, adding error handling and\n// ensuring that we don't call it if it's unavailable. The get method will simply resolve\n// with an undefined value if there is an error or if there is no localStorageProvider.\n// None of the promises returned by Storage will ever be rejected.\n//\n// It is always possible that the underlying platform storage mechanism might fail or be\n// disabled. If so, it's likely that it will keep failing, so we will only log one warning\n// instead of repetitive warnings.\nfunction PersistentStorage(localStorageProvider, logger) {\n  const storage = {};\n  let loggedError = false;\n\n  const logError = err => {\n    if (!loggedError) {\n      loggedError = true;\n      logger.warn(messages.localStorageUnavailable(err));\n    }\n  };\n\n  storage.isEnabled = () => !!localStorageProvider;\n\n  // Resolves with a value, or undefined if storage is unavailable. Never rejects.\n  storage.get = key =>\n    new Promise(resolve => {\n      if (!localStorageProvider) {\n        resolve(undefined);\n        return;\n      }\n      localStorageProvider\n        .get(key)\n        .then(resolve)\n        .catch(err => {\n          logError(err);\n          resolve(undefined);\n        });\n    });\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  storage.set = (key, value) =>\n    new Promise(resolve => {\n      if (!localStorageProvider) {\n        resolve(false);\n        return;\n      }\n      localStorageProvider\n        .set(key, value)\n        .then(() => resolve(true))\n        .catch(err => {\n          logError(err);\n          resolve(false);\n        });\n    });\n\n  // Resolves with true if successful, or false if storage is unavailable. Never rejects.\n  storage.clear = key =>\n    new Promise(resolve => {\n      if (!localStorageProvider) {\n        resolve(false);\n        return;\n      }\n      localStorageProvider\n        .clear(key)\n        .then(() => resolve(true))\n        .catch(err => {\n          logError(err);\n          resolve(false);\n        });\n    });\n\n  return storage;\n}\n\nmodule.exports = PersistentStorage;\n", "const messages = require('./messages');\nconst { appendUrlPath, base64URLEncode, objectHasOwnProperty } = require('./utils');\nconst { getLDHeaders, transformHeaders } = require('./headers');\nconst { isHttpErrorRecoverable } = require('./errors');\n\n// The underlying event source implementation is abstracted via the platform object, which should\n// have these three properties:\n// eventSourceFactory(): a function that takes a URL and optional config object and returns an object\n//   with the same methods as the regular HTML5 EventSource object. The properties in the config\n//   object are those supported by the launchdarkly-eventsource package; browser EventSource\n//   implementations don't have any config options.\n// eventSourceIsActive(): a function that takes an EventSource-compatible object and returns true if\n//   it is in an active state (connected or connecting).\n// eventSourceAllowsReport: true if REPORT is supported.\n\n// The read timeout for the stream is a fixed value that is set to be slightly longer than the expected\n// interval between heartbeats from the LaunchDarkly streaming server. If this amount of time elapses\n// with no new data, the connection will be cycled.\nconst streamReadTimeoutMillis = 5 * 60 * 1000; // 5 minutes\nconst maxRetryDelay = 30 * 1000; // Maximum retry delay 30 seconds.\nconst jitterRatio = 0.5; // Delay should be 50%-100% of calculated time.\n\nfunction Stream(platform, config, environment, diagnosticsAccumulator) {\n  const baseUrl = config.streamUrl;\n  const logger = config.logger;\n  const stream = {};\n  const evalUrlPrefix = appendUrlPath(baseUrl, '/eval/' + environment);\n  const useReport = config.useReport;\n  const withReasons = config.evaluationReasons;\n  const baseReconnectDelay = config.streamReconnectDelay;\n  const headers = getLDHeaders(platform, config);\n  let firstConnectionErrorLogged = false;\n  let es = null;\n  let reconnectTimeoutReference = null;\n  let connectionAttemptStartTime;\n  let context = null;\n  let hash = null;\n  let handlers = null;\n  let retryCount = 0;\n\n  function backoff() {\n    const delay = baseReconnectDelay * Math.pow(2, retryCount);\n    return delay > maxRetryDelay ? maxRetryDelay : delay;\n  }\n\n  function jitter(computedDelayMillis) {\n    return computedDelayMillis - Math.trunc(Math.random() * jitterRatio * computedDelayMillis);\n  }\n\n  function getNextRetryDelay() {\n    const delay = jitter(backoff());\n    retryCount += 1;\n    return delay;\n  }\n\n  stream.connect = function(newContext, newHash, newHandlers) {\n    context = newContext;\n    hash = newHash;\n    handlers = {};\n    for (const key in newHandlers || {}) {\n      handlers[key] = function(e) {\n        // Reset the state for logging the first connection error so that the first\n        // connection error following a successful connection will once again be logged.\n        // We will decorate *all* handlers to do this to keep this abstraction agnostic\n        // for different stream implementations.\n        firstConnectionErrorLogged = false;\n        logConnectionResult(true);\n        newHandlers[key] && newHandlers[key](e);\n      };\n    }\n    tryConnect();\n  };\n\n  stream.disconnect = function() {\n    clearTimeout(reconnectTimeoutReference);\n    reconnectTimeoutReference = null;\n    closeConnection();\n  };\n\n  stream.isConnected = function() {\n    return !!(es && platform.eventSourceIsActive && platform.eventSourceIsActive(es));\n  };\n\n  function handleError(err) {\n    // The event source may not produce a status. But the LaunchDarkly\n    // polyfill can. If we can get the status, then we should stop retrying\n    // on certain error codes.\n    if (err.status && typeof err.status === 'number' && !isHttpErrorRecoverable(err.status)) {\n      // If we encounter an unrecoverable condition, then we do not want to\n      // retry anymore.\n      closeConnection();\n      logger.error(messages.unrecoverableStreamError(err));\n      // Ensure any pending retry attempts are not done.\n      if (reconnectTimeoutReference) {\n        clearTimeout(reconnectTimeoutReference);\n        reconnectTimeoutReference = null;\n      }\n      return;\n    }\n\n    const delay = getNextRetryDelay();\n\n    if (!firstConnectionErrorLogged) {\n      logger.warn(messages.streamError(err, delay));\n      firstConnectionErrorLogged = true;\n    }\n    logConnectionResult(false);\n    closeConnection();\n    tryConnect(delay);\n  }\n\n  function tryConnect(delay) {\n    if (!reconnectTimeoutReference) {\n      if (delay) {\n        reconnectTimeoutReference = setTimeout(openConnection, delay);\n      } else {\n        openConnection();\n      }\n    }\n  }\n\n  function openConnection() {\n    reconnectTimeoutReference = null;\n    let url;\n    let query = '';\n    const options = { headers, readTimeoutMillis: streamReadTimeoutMillis };\n    if (platform.eventSourceFactory) {\n      if (hash !== null && hash !== undefined) {\n        query = 'h=' + hash;\n      }\n      if (useReport) {\n        if (platform.eventSourceAllowsReport) {\n          url = evalUrlPrefix;\n          options.method = 'REPORT';\n          options.headers['Content-Type'] = 'application/json';\n          options.body = JSON.stringify(context);\n        } else {\n          // if we can't do REPORT, fall back to the old ping-based stream\n          url = appendUrlPath(baseUrl, '/ping/' + environment);\n          query = '';\n        }\n      } else {\n        url = evalUrlPrefix + '/' + base64URLEncode(JSON.stringify(context));\n      }\n      options.headers = transformHeaders(options.headers, config);\n      if (withReasons) {\n        query = query + (query ? '&' : '') + 'withReasons=true';\n      }\n      url = url + (query ? '?' : '') + query;\n\n      closeConnection();\n      logger.info(messages.streamConnecting(url));\n      logConnectionStarted();\n\n      es = platform.eventSourceFactory(url, options);\n      for (const key in handlers) {\n        if (objectHasOwnProperty(handlers, key)) {\n          es.addEventListener(key, handlers[key]);\n        }\n      }\n\n      es.onerror = handleError;\n\n      es.onopen = () => {\n        // If the connection is a success, then reset the retryCount.\n        retryCount = 0;\n      };\n    }\n  }\n\n  function closeConnection() {\n    if (es) {\n      logger.info(messages.streamClosing());\n      es.close();\n      es = null;\n    }\n  }\n\n  function logConnectionStarted() {\n    connectionAttemptStartTime = new Date().getTime();\n  }\n\n  function logConnectionResult(success) {\n    if (connectionAttemptStartTime && diagnosticsAccumulator) {\n      diagnosticsAccumulator.recordStreamInit(\n        connectionAttemptStartTime,\n        !success,\n        new Date().getTime() - connectionAttemptStartTime\n      );\n    }\n    connectionAttemptStartTime = null;\n  }\n\n  return stream;\n}\n\nmodule.exports = Stream;\n", "// This function allows a series of Promises to be coalesced such that only the most recently\n// added one actually matters. For instance, if several HTTP requests are made to the same\n// endpoint and we want to ensure that whoever made each one always gets the latest data, each\n// can be passed to addPromise (on the same coalescer) and each caller can wait on the\n// coalescer.resultPromise; all three will then receive the result (or error) from the *last*\n// request, and the results of the first two will be discarded.\n//\n// The cancelFn callback, if present, will be called whenever an existing promise is being\n// discarded. This can be used for instance to abort an HTTP request that's now obsolete.\n//\n// The finallyFn callback, if present, is called on completion of the whole thing. This is\n// different from calling coalescer.resultPromise.finally() because it is executed before any\n// other handlers. Its purpose is to tell the caller that this coalescer should no longer be used.\n\nfunction promiseCoalescer(finallyFn) {\n  let currentPromise;\n  let currentCancelFn;\n  let finalResolve;\n  let finalReject;\n\n  const coalescer = {};\n\n  coalescer.addPromise = (p, cancelFn) => {\n    currentPromise = p;\n    currentCancelFn && currentCancelFn();\n    currentCancelFn = cancelFn;\n\n    p.then(\n      result => {\n        if (currentPromise === p) {\n          finalResolve(result);\n          finallyFn && finallyFn();\n        }\n      },\n      error => {\n        if (currentPromise === p) {\n          finalReject(error);\n          finallyFn && finallyFn();\n        }\n      }\n    );\n  };\n\n  coalescer.resultPromise = new Promise((resolve, reject) => {\n    finalResolve = resolve;\n    finalReject = reject;\n  });\n\n  return coalescer;\n}\n\nmodule.exports = promiseCoalescer;\n", "const utils = require('./utils');\nconst errors = require('./errors');\nconst messages = require('./messages');\nconst promiseCoalescer = require('./promiseCoalescer');\nconst { transformHeaders, getLDHeaders } = require('./headers');\n\nconst jsonContentType = 'application/json';\n\nfunction getResponseError(result) {\n  if (result.status === 404) {\n    return new errors.LDInvalidEnvironmentIdError(messages.environmentNotFound());\n  } else {\n    return new errors.LDFlagFetchError(messages.errorFetchingFlags(result.statusText || String(result.status)));\n  }\n}\n\nfunction Requestor(platform, options, environment) {\n  const baseUrl = options.baseUrl;\n  const useReport = options.useReport;\n  const withReasons = options.evaluationReasons;\n  const logger = options.logger;\n\n  const requestor = {};\n\n  const activeRequests = {}; // map of URLs to promiseCoalescers\n\n  function fetchJSON(endpoint, body) {\n    if (!platform.httpRequest) {\n      return new Promise((resolve, reject) => {\n        reject(new errors.LDFlagFetchError(messages.httpUnavailable()));\n      });\n    }\n\n    const method = body ? 'REPORT' : 'GET';\n    const headers = getLDHeaders(platform, options);\n    if (body) {\n      headers['Content-Type'] = jsonContentType;\n    }\n\n    let coalescer = activeRequests[endpoint];\n    if (!coalescer) {\n      coalescer = promiseCoalescer(() => {\n        // this will be called once there are no more active requests for the same endpoint\n        delete activeRequests[endpoint];\n      });\n      activeRequests[endpoint] = coalescer;\n    }\n\n    const req = platform.httpRequest(method, endpoint, transformHeaders(headers, options), body);\n    const p = req.promise.then(\n      result => {\n        if (result.status === 200) {\n          // We're using substring here because using startsWith would require a polyfill in IE.\n          if (\n            result.header('content-type') &&\n            result.header('content-type').substring(0, jsonContentType.length) === jsonContentType\n          ) {\n            return JSON.parse(result.body);\n          } else {\n            const message = messages.invalidContentType(result.header('content-type') || '');\n            return Promise.reject(new errors.LDFlagFetchError(message));\n          }\n        } else {\n          return Promise.reject(getResponseError(result));\n        }\n      },\n      e => Promise.reject(new errors.LDFlagFetchError(messages.networkError(e)))\n    );\n    coalescer.addPromise(p, () => {\n      // this will be called if another request for the same endpoint supersedes this one\n      req.cancel && req.cancel();\n    });\n    return coalescer.resultPromise;\n  }\n\n  // Performs a GET request to an arbitrary path under baseUrl. Returns a Promise which will resolve\n  // with the parsed JSON response, or will be rejected if the request failed.\n  requestor.fetchJSON = function(path) {\n    return fetchJSON(utils.appendUrlPath(baseUrl, path), null);\n  };\n\n  // Requests the current state of all flags for the given context from LaunchDarkly. Returns a Promise\n  // which will resolve with the parsed JSON response, or will be rejected if the request failed.\n  requestor.fetchFlagSettings = function(context, hash) {\n    let data;\n    let endpoint;\n    let query = '';\n    let body;\n\n    if (useReport) {\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/context'].join('');\n      body = JSON.stringify(context);\n    } else {\n      data = utils.base64URLEncode(JSON.stringify(context));\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/contexts/', data].join('');\n    }\n    if (hash) {\n      query = 'h=' + hash;\n    }\n    if (withReasons) {\n      query = query + (query ? '&' : '') + 'withReasons=true';\n    }\n    endpoint = endpoint + (query ? '?' : '') + query;\n    logger.debug(messages.debugPolling(endpoint));\n\n    return fetchJSON(endpoint, body);\n  };\n\n  return requestor;\n}\n\nmodule.exports = Requestor;\n", "const utils = require('./utils');\n\nfunction Identity(initialContext, onChange) {\n  const ident = {};\n  let context;\n\n  ident.setContext = function(c) {\n    context = utils.sanitizeContext(c);\n    if (context && onChange) {\n      onChange(utils.clone(context));\n    }\n  };\n\n  ident.getContext = function() {\n    return context ? utils.clone(context) : null;\n  };\n\n  if (initialContext) {\n    ident.setContext(initialContext);\n  }\n\n  return ident;\n}\n\nmodule.exports = Identity;\n", "const { v1: uuidv1 } = require('uuid');\nconst { getContextKinds } = require('./context');\n\nconst errors = require('./errors');\nconst messages = require('./messages');\nconst utils = require('./utils');\n\nconst ldUserIdKey = 'ld:$anonUserId';\n\n/**\n * Create an object which can process a context and populate any required keys\n * for anonymous objects.\n *\n * @param {Object} persistentStorage The persistent storage from which to store\n * and access persisted anonymous context keys.\n * @returns An AnonymousContextProcessor.\n */\nfunction AnonymousContextProcessor(persistentStorage) {\n  function getContextKeyIdString(kind) {\n    if (kind === undefined || kind === null || kind === 'user') {\n      return ldUserIdKey;\n    }\n    return `ld:$contextKey:${kind}`;\n  }\n\n  function getCachedContextKey(kind) {\n    return persistentStorage.get(getContextKeyIdString(kind));\n  }\n\n  function setCachedContextKey(id, kind) {\n    return persistentStorage.set(getContextKeyIdString(kind), id);\n  }\n\n  /**\n   * Process a single kind context, or a single context within a multi-kind context.\n   * @param {string} kind The kind of the context. Independent because the kind is not prevent\n   * within a context in a multi-kind context.\n   * @param {Object} context\n   * @returns {Promise} a promise that resolves to a processed contexts, or rejects\n   * a context which cannot be processed.\n   */\n  function processSingleKindContext(kind, context) {\n    // We are working on a copy of an original context, so we want to re-assign\n    // versus duplicating it again.\n\n    /* eslint-disable no-param-reassign */\n    if (context.key !== null && context.key !== undefined) {\n      context.key = context.key.toString();\n      return Promise.resolve(context);\n    }\n\n    if (context.anonymous) {\n      // If the key doesn't exist, then the persistent storage will resolve\n      // with undefined.\n      return getCachedContextKey(kind).then(cachedId => {\n        if (cachedId) {\n          context.key = cachedId;\n          return context;\n        } else {\n          const id = uuidv1();\n          context.key = id;\n          return setCachedContextKey(id, kind).then(() => context);\n        }\n      });\n    } else {\n      return Promise.reject(new errors.LDInvalidUserError(messages.invalidContext()));\n    }\n    /* eslint-enable no-param-reassign */\n  }\n\n  /**\n   * Process the context, returning a Promise that resolves to the processed context, or rejects if there is an error.\n   * @param {Object} context\n   * @returns {Promise} A promise which resolves to a processed context, or a rejection if the context cannot be\n   * processed. The context should still be checked for overall validity after being processed.\n   */\n  this.processContext = context => {\n    if (!context) {\n      return Promise.reject(new errors.LDInvalidUserError(messages.contextNotSpecified()));\n    }\n\n    const processedContext = utils.clone(context);\n\n    if (context.kind === 'multi') {\n      const kinds = getContextKinds(processedContext);\n\n      return Promise.all(kinds.map(kind => processSingleKindContext(kind, processedContext[kind]))).then(\n        () => processedContext\n      );\n    }\n    return processSingleKindContext(context.kind, processedContext);\n  };\n}\n\nmodule.exports = AnonymousContextProcessor;\n", "const { v1: uuidv1 } = require('uuid');\n// Note that in the diagnostic events spec, these IDs are to be generated with UUID v4. However,\n// in JS we were already using v1 for unique context keys, so to avoid bringing in two packages we\n// will use v1 here as well.\n\nconst { baseOptionDefs } = require('./configuration');\nconst messages = require('./messages');\nconst { appendUrlPath } = require('./utils');\n\nfunction DiagnosticId(sdkKey) {\n  const ret = {\n    diagnosticId: uuidv1(),\n  };\n  if (sdkKey) {\n    ret.sdkKeySuffix = sdkKey.length > 6 ? sdkKey.substring(sdkKey.length - 6) : sdkKey;\n  }\n  return ret;\n}\n\n// A stateful object holding statistics that will go into diagnostic events.\n\nfunction DiagnosticsAccumulator(startTime) {\n  let dataSinceDate, droppedEvents, eventsInLastBatch, streamInits;\n\n  function reset(time) {\n    dataSinceDate = time;\n    droppedEvents = 0;\n    eventsInLastBatch = 0;\n    streamInits = [];\n  }\n\n  reset(startTime);\n\n  return {\n    getProps: () => ({\n      dataSinceDate,\n      droppedEvents,\n      eventsInLastBatch,\n      streamInits,\n      // omit deduplicatedUsers for the JS SDKs because they don't deduplicate users\n    }),\n    setProps: props => {\n      dataSinceDate = props.dataSinceDate;\n      droppedEvents = props.droppedEvents || 0;\n      eventsInLastBatch = props.eventsInLastBatch || 0;\n      streamInits = props.streamInits || [];\n    },\n    incrementDroppedEvents: () => {\n      droppedEvents++;\n    },\n    setEventsInLastBatch: n => {\n      eventsInLastBatch = n;\n    },\n    recordStreamInit: (timestamp, failed, durationMillis) => {\n      const info = { timestamp, failed, durationMillis };\n      streamInits.push(info);\n    },\n    reset,\n  };\n}\n\n// An object that maintains information that will go into diagnostic events, and knows how to format\n// those events. It is instantiated by the SDK client, and shared with the event processor.\n//\n// The JS-based SDKs have two modes for diagnostic events. By default, the behavior is basically the\n// same as the server-side SDKs: a \"diagnostic-init\" event is sent on startup, and then \"diagnostic\"\n// events with operating statistics are sent periodically. However, in a browser environment this is\n// undesirable because the page may be reloaded frequently. In that case, setting the property\n// \"platform.diagnosticUseCombinedEvent\" to true enables an alternate mode in which a combination of\n// both kinds of event is sent at intervals, relative to the last time this was done (if any) which\n// is cached in local storage.\n\nfunction DiagnosticsManager(\n  platform,\n  persistentStorage,\n  accumulator,\n  eventSender,\n  environmentId,\n  config,\n  diagnosticId\n) {\n  const combinedMode = !!platform.diagnosticUseCombinedEvent;\n  const localStorageKey = 'ld:' + environmentId + ':$diagnostics';\n  const diagnosticEventsUrl = appendUrlPath(config.eventsUrl, '/events/diagnostic/' + environmentId);\n  const periodicInterval = config.diagnosticRecordingInterval;\n  const acc = accumulator;\n  const initialEventSamplingInterval = 4; // used only in combined mode - see start()\n  let streamingEnabled = !!config.streaming;\n  let eventSentTime;\n  let periodicTimer;\n  const manager = {};\n\n  function makeInitProperties() {\n    return {\n      sdk: makeSdkData(),\n      configuration: makeConfigData(),\n      platform: platform.diagnosticPlatformData,\n    };\n  }\n\n  // Send a diagnostic event and do not wait for completion.\n  function sendDiagnosticEvent(event) {\n    config.logger && config.logger.debug(messages.debugPostingDiagnosticEvent(event));\n    eventSender\n      .sendEvents(event, diagnosticEventsUrl, true)\n      .then(() => undefined)\n      .catch(() => undefined);\n  }\n\n  function loadProperties(callback) {\n    if (!persistentStorage.isEnabled()) {\n      return callback(false); // false indicates that local storage is not available\n    }\n    persistentStorage\n      .get(localStorageKey)\n      .then(data => {\n        if (data) {\n          try {\n            const props = JSON.parse(data);\n            acc.setProps(props);\n            eventSentTime = props.dataSinceDate;\n          } catch (e) {\n            // disregard malformed cached data\n          }\n        }\n        callback(true);\n      })\n      .catch(() => {\n        callback(false);\n      });\n  }\n\n  function saveProperties() {\n    if (persistentStorage.isEnabled()) {\n      const props = { ...acc.getProps() };\n      persistentStorage.set(localStorageKey, JSON.stringify(props));\n    }\n  }\n\n  // Creates the initial event that is sent by the event processor when the SDK starts up. This will not\n  // be repeated during the lifetime of the SDK client. In combined mode, we don't send this.\n  function createInitEvent() {\n    return {\n      kind: 'diagnostic-init',\n      id: diagnosticId,\n      creationDate: acc.getProps().dataSinceDate,\n      ...makeInitProperties(),\n    };\n  }\n\n  // Creates a periodic event containing time-dependent stats, and resets the state of the manager with\n  // regard to those stats. In combined mode (browser SDK) this also contains the configuration data.\n  function createPeriodicEventAndReset() {\n    const currentTime = new Date().getTime();\n    let ret = {\n      kind: combinedMode ? 'diagnostic-combined' : 'diagnostic',\n      id: diagnosticId,\n      creationDate: currentTime,\n      ...acc.getProps(),\n    };\n    if (combinedMode) {\n      ret = { ...ret, ...makeInitProperties() };\n    }\n    acc.reset(currentTime);\n    return ret;\n  }\n\n  function sendPeriodicEvent() {\n    sendDiagnosticEvent(createPeriodicEventAndReset());\n    periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n    eventSentTime = new Date().getTime();\n    if (combinedMode) {\n      saveProperties();\n    }\n  }\n\n  function makeSdkData() {\n    const sdkData = { ...platform.diagnosticSdkData };\n    if (config.wrapperName) {\n      sdkData.wrapperName = config.wrapperName;\n    }\n    if (config.wrapperVersion) {\n      sdkData.wrapperVersion = config.wrapperVersion;\n    }\n    return sdkData;\n  }\n\n  function makeConfigData() {\n    const configData = {\n      customBaseURI: config.baseUrl !== baseOptionDefs.baseUrl.default,\n      customStreamURI: config.streamUrl !== baseOptionDefs.streamUrl.default,\n      customEventsURI: config.eventsUrl !== baseOptionDefs.eventsUrl.default,\n      eventsCapacity: config.eventCapacity,\n      eventsFlushIntervalMillis: config.flushInterval,\n      reconnectTimeMillis: config.streamReconnectDelay,\n      streamingDisabled: !streamingEnabled,\n      allAttributesPrivate: !!config.allAttributesPrivate,\n      diagnosticRecordingIntervalMillis: config.diagnosticRecordingInterval,\n      // The following extra properties are only provided by client-side JS SDKs:\n      usingSecureMode: !!config.hash,\n      bootstrapMode: !!config.bootstrap,\n      fetchGoalsDisabled: !config.fetchGoals,\n      sendEventsOnlyForVariation: !!config.sendEventsOnlyForVariation,\n    };\n    // Client-side JS SDKs do not have the following properties which other SDKs have:\n    // connectTimeoutMillis\n    // pollingIntervalMillis\n    // samplingInterval\n    // socketTimeoutMillis\n    // startWaitMillis\n    // userKeysCapacity\n    // userKeysFlushIntervalMillis\n    // usingProxy\n    // usingProxyAuthenticator\n    // usingRelayDaemon\n\n    return configData;\n  }\n\n  // Called when the SDK is starting up. Either send an init event immediately, or, in the alternate\n  // mode, check for cached local storage properties and send an event only if we haven't done so\n  // recently.\n  manager.start = () => {\n    if (combinedMode) {\n      loadProperties(localStorageAvailable => {\n        if (localStorageAvailable) {\n          const nextEventTime = (eventSentTime || 0) + periodicInterval;\n          const timeNow = new Date().getTime();\n          if (timeNow >= nextEventTime) {\n            sendPeriodicEvent();\n          } else {\n            periodicTimer = setTimeout(sendPeriodicEvent, nextEventTime - timeNow);\n          }\n        } else {\n          // We don't have the ability to cache anything in local storage, so we don't know if we\n          // recently sent an event before this page load, but we would still prefer not to send one\n          // on *every* page load. So, as a rough heuristic, we'll decide semi-randomly.\n          if (Math.floor(Math.random() * initialEventSamplingInterval) === 0) {\n            sendPeriodicEvent();\n          } else {\n            periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n          }\n        }\n      });\n    } else {\n      sendDiagnosticEvent(createInitEvent());\n      periodicTimer = setTimeout(sendPeriodicEvent, periodicInterval);\n    }\n  };\n\n  manager.stop = () => {\n    periodicTimer && clearTimeout(periodicTimer);\n  };\n\n  // Called when streaming mode is turned on or off dynamically.\n  manager.setStreaming = enabled => {\n    streamingEnabled = enabled;\n  };\n\n  return manager;\n}\n\nmodule.exports = {\n  DiagnosticId,\n  DiagnosticsAccumulator,\n  DiagnosticsManager,\n};\n", "const messages = require('./messages');\n\n/**\n * Wrap an inspector ensuring that calling its methods are safe.\n * @param {object} inspector Inspector to wrap.\n */\nfunction SafeInspector(inspector, logger) {\n  let errorLogged = false;\n  const wrapper = {\n    type: inspector.type,\n    name: inspector.name,\n    synchronous: inspector.synchronous,\n  };\n\n  wrapper.method = (...args) => {\n    try {\n      inspector.method(...args);\n    } catch {\n      // If something goes wrong in an inspector we want to log that something\n      // went wrong. We don't want to flood the logs, so we only log something\n      // the first time that something goes wrong.\n      // We do not include the exception in the log, because we do not know what\n      // kind of data it may contain.\n      if (!errorLogged) {\n        errorLogged = true;\n        logger.warn(messages.inspectorMethodError(wrapper.type, wrapper.name));\n      }\n      // Prevent errors.\n    }\n  };\n\n  return wrapper;\n}\n\nmodule.exports = SafeInspector;\n", "const messages = require('./messages');\nconst SafeInspector = require('./SafeInspector');\nconst { onNextTick } = require('./utils');\n\n/**\n * The types of supported inspectors.\n */\nconst InspectorTypes = {\n  flagUsed: 'flag-used',\n  flagDetailsChanged: 'flag-details-changed',\n  flagDetailChanged: 'flag-detail-changed',\n  clientIdentityChanged: 'client-identity-changed',\n};\n\nObject.freeze(InspectorTypes);\n\n/**\n * Manages dispatching of inspection data to registered inspectors.\n */\nfunction InspectorManager(inspectors, logger) {\n  const manager = {};\n\n  /**\n   * Collection of inspectors keyed by type.\n   *\n   * Inspectors are async by default.\n   *\n   * @type {{[type: string]: object[]}}\n   */\n  const inspectorsByType = {\n    [InspectorTypes.flagUsed]: [],\n    [InspectorTypes.flagDetailsChanged]: [],\n    [InspectorTypes.flagDetailChanged]: [],\n    [InspectorTypes.clientIdentityChanged]: [],\n  };\n  /**\n   * Collection synchronous of inspectors keyed by type.\n   *\n   * @type {{[type: string]: object[]}}\n   */\n  const synchronousInspectorsByType = {\n    [InspectorTypes.flagUsed]: [],\n    [InspectorTypes.flagDetailsChanged]: [],\n    [InspectorTypes.flagDetailChanged]: [],\n    [InspectorTypes.clientIdentityChanged]: [],\n  };\n\n  const safeInspectors = inspectors && inspectors.map(inspector => SafeInspector(inspector, logger));\n\n  safeInspectors &&\n    safeInspectors.forEach(safeInspector => {\n      // Only add inspectors of supported types.\n      if (Object.prototype.hasOwnProperty.call(inspectorsByType, safeInspector.type) && !safeInspector.synchronous) {\n        inspectorsByType[safeInspector.type].push(safeInspector);\n      } else if (\n        Object.prototype.hasOwnProperty.call(synchronousInspectorsByType, safeInspector.type) &&\n        safeInspector.synchronous\n      ) {\n        synchronousInspectorsByType[safeInspector.type].push(safeInspector);\n      } else {\n        logger.warn(messages.invalidInspector(safeInspector.type, safeInspector.name));\n      }\n    });\n\n  /**\n   * Check if there is an inspector of a specific type registered.\n   *\n   * @param {string} type The type of the inspector to check.\n   * @returns True if there are any inspectors of that type registered.\n   */\n  manager.hasListeners = type =>\n    (inspectorsByType[type] && inspectorsByType[type].length) ||\n    (synchronousInspectorsByType[type] && synchronousInspectorsByType[type].length);\n\n  /**\n   * Notify registered inspectors of a flag being used.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {string} flagKey The key for the flag.\n   * @param {Object} detail The LDEvaluationDetail for the flag.\n   * @param {Object} context The LDContext for the flag.\n   */\n  manager.onFlagUsed = (flagKey, detail, context) => {\n    const type = InspectorTypes.flagUsed;\n    if (synchronousInspectorsByType[type].length) {\n      synchronousInspectorsByType[type].forEach(inspector => inspector.method(flagKey, detail, context));\n    }\n    if (inspectorsByType[type].length) {\n      onNextTick(() => {\n        inspectorsByType[type].forEach(inspector => inspector.method(flagKey, detail, context));\n      });\n    }\n  };\n\n  /**\n   * Notify registered inspectors that the flags have been replaced.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {Record<string, Object>} flags The current flags as a Record<string, LDEvaluationDetail>.\n   */\n  manager.onFlags = flags => {\n    const type = InspectorTypes.flagDetailsChanged;\n    if (synchronousInspectorsByType[type].length) {\n      synchronousInspectorsByType[type].forEach(inspector => inspector.method(flags));\n    }\n    if (inspectorsByType[type].length) {\n      onNextTick(() => {\n        inspectorsByType[type].forEach(inspector => inspector.method(flags));\n      });\n    }\n  };\n\n  /**\n   * Notify registered inspectors that a flag value has changed.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {string} flagKey The key for the flag that changed.\n   * @param {Object} flag An `LDEvaluationDetail` for the flag.\n   */\n  manager.onFlagChanged = (flagKey, flag) => {\n    const type = InspectorTypes.flagDetailChanged;\n    if (synchronousInspectorsByType[type].length) {\n      synchronousInspectorsByType[type].forEach(inspector => inspector.method(flagKey, flag));\n    }\n    if (inspectorsByType[type].length) {\n      onNextTick(() => {\n        inspectorsByType[type].forEach(inspector => inspector.method(flagKey, flag));\n      });\n    }\n  };\n\n  /**\n   * Notify the registered inspectors that the context identity has changed.\n   *\n   * The notification itself will be dispatched asynchronously.\n   *\n   * @param {Object} context The `LDContext` which is now identified.\n   */\n  manager.onIdentityChanged = context => {\n    const type = InspectorTypes.clientIdentityChanged;\n    if (synchronousInspectorsByType[type].length) {\n      synchronousInspectorsByType[type].forEach(inspector => inspector.method(context));\n    }\n    if (inspectorsByType[type].length) {\n      onNextTick(() => {\n        inspectorsByType[type].forEach(inspector => inspector.method(context));\n      });\n    }\n  };\n\n  return manager;\n}\n\nmodule.exports = { InspectorTypes, InspectorManager };\n", "const { LDTimeoutError } = require('./errors');\n\n/**\n * Returns a promise which errors after t seconds.\n *\n * @param t Timeout in seconds.\n * @param taskName Name of task being timed for logging and error reporting.\n */\nfunction timedPromise(t, taskName) {\n  return new Promise((_res, reject) => {\n    setTimeout(() => {\n      const e = `${taskName} timed out after ${t} seconds.`;\n      reject(new LDTimeoutError(e));\n    }, t * 1000);\n  });\n}\nmodule.exports = timedPromise;\n", "const UNKNOWN_HOOK_NAME = 'unknown hook';\nconst BEFORE_EVALUATION_STAGE_NAME = 'beforeEvaluation';\nconst AFTER_EVALUATION_STAGE_NAME = 'afterEvaluation';\nconst BEFORE_IDENTIFY_STAGE_NAME = 'beforeIdentify';\nconst AFTER_IDENTIFY_STAGE_NAME = 'afterIdentify';\nconst AFTER_TRACK_STAGE_NAME = 'afterTrack';\n\n/**\n * Safely executes a hook stage function, logging any errors.\n * @param {{ error: (message: string) => void } | undefined} logger The logger instance.\n * @param {string} method The name of the hook stage being executed (e.g., 'beforeEvaluation').\n * @param {string} hookName The name of the hook.\n * @param {() => any} stage The function representing the hook stage to execute.\n * @param {any} def The default value to return if the stage function throws an error.\n * @returns {any} The result of the stage function, or the default value if an error occurred.\n */\nfunction tryExecuteStage(logger, method, hookName, stage, def) {\n  try {\n    return stage();\n  } catch (err) {\n    logger?.error(`An error was encountered in \"${method}\" of the \"${hookName}\" hook: ${err}`);\n    return def;\n  }\n}\n\n/**\n * Safely gets the name of a hook from its metadata.\n * @param {{ error: (message: string) => void }} logger The logger instance.\n * @param {{ getMetadata: () => { name?: string } }} hook The hook instance.\n * @returns {string} The name of the hook, or 'unknown hook' if unable to retrieve it.\n */\nfunction getHookName(logger, hook) {\n  try {\n    return hook.getMetadata().name || UNKNOWN_HOOK_NAME;\n  } catch {\n    logger.error(`Exception thrown getting metadata for hook. Unable to get hook name.`);\n    return UNKNOWN_HOOK_NAME;\n  }\n}\n\n/**\n * Executes the 'beforeEvaluation' stage for all registered hooks.\n * @param {{ error: (message: string) => void }} logger The logger instance.\n * @param {Array<{ beforeEvaluation?: (hookContext: object, data: object) => object }>} hooks The array of hook instances.\n * @param {{ flagKey: string, context: object, defaultValue: any }} hookContext The context for the evaluation series.\n * @returns {Array<object>} An array containing the data returned by each hook's 'beforeEvaluation' stage.\n */\nfunction executeBeforeEvaluation(logger, hooks, hookContext) {\n  return hooks.map(hook =>\n    tryExecuteStage(\n      logger,\n      BEFORE_EVALUATION_STAGE_NAME,\n      getHookName(logger, hook),\n      () => hook?.beforeEvaluation?.(hookContext, {}) ?? {},\n      {}\n    )\n  );\n}\n\n/**\n * Executes the 'afterEvaluation' stage for all registered hooks in reverse order.\n * @param {{ error: (message: string) => void }} logger The logger instance.\n * @param {Array<{ afterEvaluation?: (hookContext: object, data: object, result: object) => object }>} hooks The array of hook instances.\n * @param {{ flagKey: string, context: object, defaultValue: any }} hookContext The context for the evaluation series.\n * @param {Array<object>} updatedData The data collected from the 'beforeEvaluation' stages.\n * @param {{ value: any, variationIndex?: number, reason?: object }} result The result of the flag evaluation.\n * @returns {void}\n */\nfunction executeAfterEvaluation(logger, hooks, hookContext, updatedData, result) {\n  // This iterates in reverse, versus reversing a shallow copy of the hooks,\n  // for efficiency.\n  for (let hookIndex = hooks.length - 1; hookIndex >= 0; hookIndex -= 1) {\n    const hook = hooks[hookIndex];\n    const data = updatedData[hookIndex];\n    tryExecuteStage(\n      logger,\n      AFTER_EVALUATION_STAGE_NAME,\n      getHookName(logger, hook),\n      () => hook?.afterEvaluation?.(hookContext, data, result) ?? {},\n      {}\n    );\n  }\n}\n\n/**\n * Executes the 'beforeIdentify' stage for all registered hooks.\n * @param {{ error: (message: string) => void }} logger The logger instance.\n * @param {Array<{ beforeIdentify?: (hookContext: object, data: object) => object }>} hooks The array of hook instances.\n * @param {{ context: object, timeout?: number }} hookContext The context for the identify series.\n * @returns {Array<object>} An array containing the data returned by each hook's 'beforeIdentify' stage.\n */\nfunction executeBeforeIdentify(logger, hooks, hookContext) {\n  return hooks.map(hook =>\n    tryExecuteStage(\n      logger,\n      BEFORE_IDENTIFY_STAGE_NAME,\n      getHookName(logger, hook),\n      () => hook?.beforeIdentify?.(hookContext, {}) ?? {},\n      {}\n    )\n  );\n}\n\n/**\n * Executes the 'afterIdentify' stage for all registered hooks in reverse order.\n * @param {{ error: (message: string) => void }} logger The logger instance.\n * @param {Array<{ afterIdentify?: (hookContext: object, data: object, result: object) => object }>} hooks The array of hook instances.\n * @param {{ context: object, timeout?: number }} hookContext The context for the identify series.\n * @param {Array<object>} updatedData The data collected from the 'beforeIdentify' stages.\n * @param {{ status: string }} result The result of the identify operation.\n * @returns {void}\n */\nfunction executeAfterIdentify(logger, hooks, hookContext, updatedData, result) {\n  // This iterates in reverse, versus reversing a shallow copy of the hooks,\n  // for efficiency.\n  for (let hookIndex = hooks.length - 1; hookIndex >= 0; hookIndex -= 1) {\n    const hook = hooks[hookIndex];\n    const data = updatedData[hookIndex];\n    tryExecuteStage(\n      logger,\n      AFTER_IDENTIFY_STAGE_NAME,\n      getHookName(logger, hook),\n      () => hook?.afterIdentify?.(hookContext, data, result) ?? {},\n      {}\n    );\n  }\n}\n\n/**\n * Executes the 'afterTrack' stage for all registered hooks in reverse order.\n * @param {{ error: (message: string) => void }} logger The logger instance.\n * @param {Array<{ afterTrack?: (hookContext: { context: object, data: object, metricValue: number }) => void }>} hooks The array of hook instances.\n * @param {{ context: object, data: object, metricValue: number }} hookContext The context for the track operation.\n * @returns {void}\n */\nfunction executeAfterTrack(logger, hooks, hookContext) {\n  // This iterates in reverse, versus reversing a shallow copy of the hooks,\n  // for efficiency.\n  for (let hookIndex = hooks.length - 1; hookIndex >= 0; hookIndex -= 1) {\n    const hook = hooks[hookIndex];\n    tryExecuteStage(\n      logger,\n      AFTER_TRACK_STAGE_NAME,\n      getHookName(logger, hook),\n      () => hook?.afterTrack?.(hookContext),\n      undefined\n    );\n  }\n}\n\n/**\n * Factory function to create a HookRunner instance.\n * Manages the execution of hooks for flag evaluations and identify operations.\n * @param {{ error: (message: string) => void }} logger The logger instance.\n * @param {Array<object> | undefined} initialHooks An optional array of hooks to initialize with.\n * @returns {{\n *  withEvaluation: (key: string, context: object, defaultValue: any, method: () => { value: any, variationIndex?: number, reason?: object }) => { value: any, variationIndex?: number, reason?: object },\n *  identify: (context: object, timeout?: number) => (result: { status: string }) => void,\n *  addHook: (hook: object) => void\n * }} The hook runner object with methods to manage and execute hooks.\n */\nfunction createHookRunner(logger, initialHooks) {\n  // Use local variable instead of instance property\n  const hooksInternal = initialHooks ? [...initialHooks] : [];\n\n  /**\n   * Wraps a flag evaluation method with before/after hook stages.\n   * @param {string} key The flag key.\n   * @param {object} context The evaluation context.\n   * @param {any} defaultValue The default value for the flag.\n   * @param {() => { value: any, variationIndex?: number, reason?: object }} method The function that performs the actual flag evaluation.\n   * @returns {{ value: any, variationIndex?: number, reason?: object }} The result of the flag evaluation.\n   */\n  function withEvaluation(key, context, defaultValue, method) {\n    if (hooksInternal.length === 0) {\n      return method();\n    }\n    const hooks = [...hooksInternal];\n    /** @type {{ flagKey: string, context: object, defaultValue: any }} */\n    const hookContext = {\n      flagKey: key,\n      context,\n      defaultValue,\n    };\n\n    // Use the logger passed into the factory\n    const hookData = executeBeforeEvaluation(logger, hooks, hookContext);\n    const result = method();\n    executeAfterEvaluation(logger, hooks, hookContext, hookData, result);\n    return result;\n  }\n\n  /**\n   * Wraps the identify operation with before/after hook stages.\n   * Executes the 'beforeIdentify' stage immediately and returns a function\n   * to execute the 'afterIdentify' stage later.\n   * @param {object} context The context being identified.\n   * @param {number | undefined} timeout Optional timeout for the identify operation.\n   * @returns {(result: { status: string }) => void} A function to call after the identify operation completes.\n   */\n  function identify(context, timeout) {\n    const hooks = [...hooksInternal];\n    /** @type {{ context: object, timeout?: number }} */\n    const hookContext = {\n      context,\n      timeout,\n    };\n    // Use the logger passed into the factory\n    const hookData = executeBeforeIdentify(logger, hooks, hookContext);\n    /**\n     * Executes the 'afterIdentify' hook stage.\n     * @param {{ status: string }} result The result of the identify operation.\n     */\n    return result => {\n      executeAfterIdentify(logger, hooks, hookContext, hookData, result);\n    };\n  }\n\n  /**\n   * Adds a new hook to the runner.\n   * @param {object} hook The hook instance to add.\n   * @returns {void}\n   */\n  function addHook(hook) {\n    // Mutate the internal hooks array\n    hooksInternal.push(hook);\n  }\n\n  /**\n   * Executes the 'afterTrack' stage for all registered hooks in reverse order.\n   * @param {{ context: object, data: object, metricValue: number }} hookContext The context for the track operation.\n   * @returns {void}\n   */\n  function afterTrack(hookContext) {\n    if (hooksInternal.length === 0) {\n      return;\n    }\n    const hooks = [...hooksInternal];\n    executeAfterTrack(logger, hooks, hookContext);\n  }\n\n  return {\n    withEvaluation,\n    identify,\n    addHook,\n    afterTrack,\n  };\n}\n\nmodule.exports = createHookRunner;\n", "const utils = require('./utils');\n\n/**\n * FlagStore - Centralized flag store and access point for all feature flags\n *\n * This module manages two types of feature flags:\n * 1. Regular flags - Retrieved from LaunchDarkly servers or bootstrap data\n * 2. Override flags - Local overrides for debugging/testing\n *\n * When a flag is requested:\n * - If an override exists for that flag, the override value is returned\n * - Otherwise, the regular flag value is returned\n */\nfunction FlagStore() {\n  let flags = {};\n  // The flag overrides are set lazily to allow bypassing property checks when no overrides are present.\n  let flagOverrides;\n\n  /**\n   * Gets a single flag by key, with overrides taking precedence over regular flags\n   * @param {string} key The flag key to retrieve\n   * @returns {Object|null} The flag object or null if not found\n   */\n  function get(key) {\n    // Check overrides first, then real flags\n    if (flagOverrides && utils.objectHasOwnProperty(flagOverrides, key) && flagOverrides[key]) {\n      return flagOverrides[key];\n    }\n\n    if (flags && utils.objectHasOwnProperty(flags, key) && flags[key] && !flags[key].deleted) {\n      return flags[key];\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets all flags with overrides applied\n   * @returns {Object} Object containing all flags with any overrides applied\n   */\n  function getFlagsWithOverrides() {\n    const result = {};\n\n    // Add all flags first\n    for (const key in flags) {\n      const flag = get(key);\n      if (flag) {\n        result[key] = flag;\n      }\n    }\n\n    // Override with any flagOverrides (they take precedence)\n    if (flagOverrides) {\n      for (const key in flagOverrides) {\n        const override = get(key);\n        if (override) {\n          result[key] = override;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Replaces all flags with new flag data\n   * @param {Object} newFlags - Object containing the new flag data\n   */\n  function setFlags(newFlags) {\n    flags = { ...newFlags };\n  }\n\n  /**\n   * Sets an override value for a specific flag\n   * @param {string} key The flag key to override\n   * @param {*} value The override value for the flag\n   */\n  function setOverride(key, value) {\n    if (!flagOverrides) {\n      flagOverrides = {};\n    }\n    flagOverrides[key] = { value };\n  }\n\n  /**\n   * Removes an override for a specific flag\n   * @param {string} key The flag key to remove the override for\n   */\n  function removeOverride(key) {\n    if (!flagOverrides || !flagOverrides[key]) {\n      return; // No override to remove\n    }\n\n    delete flagOverrides[key];\n\n    // If no more overrides, reset to undefined for performance\n    if (Object.keys(flagOverrides).length === 0) {\n      flagOverrides = undefined;\n    }\n  }\n\n  /**\n   * Clears all flag overrides and returns the cleared overrides\n   * @returns {Object} The overrides that were cleared, useful for tracking what was removed\n   */\n  function clearAllOverrides() {\n    if (!flagOverrides) {\n      return {}; // No overrides to clear, return empty object for consistency\n    }\n\n    const clearedOverrides = { ...flagOverrides };\n    flagOverrides = undefined; // Reset to undefined\n    return clearedOverrides;\n  }\n\n  /**\n   * Gets the internal flag state without overrides applied\n   * @returns {Object} The internal flag data structure\n   */\n  function getFlags() {\n    return flags;\n  }\n\n  /**\n   * Gets the flag overrides data\n   * @returns {Object} The flag overrides object, or empty object if no overrides exist\n   */\n  function getFlagOverrides() {\n    return flagOverrides || {};\n  }\n\n  return {\n    clearAllOverrides,\n    get,\n    getFlagOverrides,\n    getFlags,\n    getFlagsWithOverrides,\n    removeOverride,\n    setFlags,\n    setOverride,\n  };\n}\n\nmodule.exports = FlagStore;\n", "const UNKNOWN_PLUGIN_NAME = 'unknown plugin';\n\n/**\n * Safely gets the name of a plugin with error handling\n * @param {{ error: (message: string) => void }} logger - The logger instance\n * @param {{getMetadata: () => {name: string}}} plugin - Plugin object that may have a name property\n * @returns {string} The plugin name or 'unknown' if not available\n */\nfunction getPluginName(logger, plugin) {\n  try {\n    return plugin.getMetadata().name || UNKNOWN_PLUGIN_NAME;\n  } catch (error) {\n    logger.error(`Exception thrown getting metadata for plugin. Unable to get plugin name.`);\n    return UNKNOWN_PLUGIN_NAME;\n  }\n}\n\n/**\n * Safely retrieves hooks from plugins with error handling\n * @param {Object} logger - The logger instance\n * @param {Object} environmentMetadata - Metadata about the environment for plugin initialization\n * @param {Array<{getHooks: (environmentMetadata: object) => Hook[]}>} plugins - Array of plugin objects that may implement getHooks\n * @returns {Array<Hook>} Array of hook objects collected from all plugins\n */\nfunction getPluginHooks(logger, environmentMetadata, plugins) {\n  const hooks = [];\n  plugins.forEach(plugin => {\n    try {\n      const pluginHooks = plugin.getHooks?.(environmentMetadata);\n      if (pluginHooks === undefined) {\n        logger.error(`Plugin ${getPluginName(logger, plugin)} returned undefined from getHooks.`);\n      } else if (pluginHooks && pluginHooks.length > 0) {\n        hooks.push(...pluginHooks);\n      }\n    } catch (error) {\n      logger.error(`Exception thrown getting hooks for plugin ${getPluginName(logger, plugin)}. Unable to get hooks.`);\n    }\n  });\n  return hooks;\n}\n\n/**\n * Registers plugins with the SDK\n * @param {{ error: (message: string) => void }} logger - The logger instance\n * @param {Object} environmentMetadata - Metadata about the environment for plugin initialization\n * @param {Object} client - The SDK client instance\n * @param {Array<{register: (client: object, environmentMetadata: object) => void}>} plugins - Array of plugin objects that implement register\n */\nfunction registerPlugins(logger, environmentMetadata, client, plugins) {\n  plugins.forEach(plugin => {\n    try {\n      plugin.register(client, environmentMetadata);\n    } catch (error) {\n      logger.error(`Exception thrown registering plugin ${getPluginName(logger, plugin)}.`);\n    }\n  });\n}\n\n/**\n * Registers plugins for debug override capabilities\n * @param {{ error: (message: string) => void }} logger - The logger instance\n * @param {Object} debugOverride - The debug override interface object\n * @param {Array<{registerDebug?: (debugOverride: object) => void}>} plugins - Array of plugin objects that may implement registerDebug\n */\nfunction registerPluginsForDebugOverride(logger, debugOverride, plugins) {\n  plugins.forEach(plugin => {\n    try {\n      plugin.registerDebug?.(debugOverride);\n    } catch (error) {\n      logger.error(`Exception thrown registering debug override with plugin ${getPluginName(logger, plugin)}.`);\n    }\n  });\n}\n\n/**\n * Creates a plugin environment object\n * @param {{userAgent: string, version: string}} platform - The platform object\n * @param {string} env - The environment\n * @param {{application: {name: string, version: string}, wrapperName: string, wrapperVersion: string}} options - The options\n * @returns {{sdk: {name: string, version: string, wrapperName: string, wrapperVersion: string}, application: {name: string, version: string}, clientSideId: string}} The plugin environment\n */\nfunction createPluginEnvironment(platform, env, options) {\n  const pluginSdkMetadata = {};\n\n  if (platform.userAgent) {\n    pluginSdkMetadata.name = platform.userAgent;\n  }\n  if (platform.version) {\n    pluginSdkMetadata.version = platform.version;\n  }\n  if (options.wrapperName) {\n    pluginSdkMetadata.wrapperName = options.wrapperName;\n  }\n  if (options.wrapperVersion) {\n    pluginSdkMetadata.wrapperVersion = options.wrapperVersion;\n  }\n\n  const pluginApplicationMetadata = {};\n\n  if (options.application) {\n    if (options.application.name) {\n      pluginApplicationMetadata.name = options.application.name;\n    }\n    if (options.application.version) {\n      pluginApplicationMetadata.version = options.application.version;\n    }\n  }\n\n  const pluginEnvironment = {\n    sdk: pluginSdkMetadata,\n    clientSideId: env,\n  };\n\n  if (Object.keys(pluginApplicationMetadata).length > 0) {\n    pluginEnvironment.application = pluginApplicationMetadata;\n  }\n\n  return pluginEnvironment;\n}\n\nmodule.exports = {\n  getPluginHooks,\n  registerPlugins,\n  registerPluginsForDebugOverride,\n  createPluginEnvironment,\n};\n", "const EventProcessor = require('./EventProcessor');\nconst EventEmitter = require('./EventEmitter');\nconst EventSender = require('./EventSender');\nconst InitializationStateTracker = require('./InitializationState');\nconst PersistentFlagStore = require('./PersistentFlagStore');\nconst PersistentStorage = require('./PersistentStorage');\nconst Stream = require('./Stream');\nconst Requestor = require('./Requestor');\nconst Identity = require('./Identity');\nconst AnonymousContextProcessor = require('./AnonymousContextProcessor');\nconst configuration = require('./configuration');\nconst diagnostics = require('./diagnosticEvents');\nconst { commonBasicLogger } = require('./loggers');\nconst utils = require('./utils');\nconst errors = require('./errors');\nconst messages = require('./messages');\nconst { checkContext, getContextKeys } = require('./context');\nconst { InspectorTypes, InspectorManager } = require('./InspectorManager');\nconst timedPromise = require('./timedPromise');\nconst createHookRunner = require('./HookRunner');\nconst FlagStore = require('./FlagStore');\nconst {\n  getPluginHooks,\n  registerPlugins,\n  registerPluginsForDebugOverride,\n  createPluginEnvironment,\n} = require('./plugins');\nconst changeEvent = 'change';\nconst internalChangeEvent = 'internal-change';\nconst highTimeoutThreshold = 5;\n\n// This is called by the per-platform initialize functions to create the base client object that we\n// may also extend with additional behavior. It returns an object with these properties:\n//   client: the actual client object\n//   options: the configuration (after any appropriate defaults have been applied)\n// If we need to give the platform-specific clients access to any internals here, we should add those\n// as properties of the return object, not public properties of the client.\n//\n// For definitions of the API in the platform object, see stubPlatform.js in the test code.\n\nfunction initialize(env, context, specifiedOptions, platform, extraOptionDefs) {\n  const logger = createLogger();\n  const emitter = EventEmitter(logger);\n  const initializationStateTracker = InitializationStateTracker(emitter);\n  const options = configuration.validate(specifiedOptions, emitter, extraOptionDefs, logger);\n  const inspectorManager = InspectorManager(options.inspectors, logger);\n  const sendEvents = options.sendEvents;\n  let environment = env;\n  let hash = options.hash;\n  const plugins = [...options.plugins];\n\n  const pluginEnvironment = createPluginEnvironment(platform, env, options);\n\n  const pluginHooks = getPluginHooks(logger, pluginEnvironment, plugins);\n\n  const hookRunner = createHookRunner(logger, [...options.hooks, ...pluginHooks]);\n\n  const persistentStorage = PersistentStorage(platform.localStorage, logger);\n\n  const eventSender = EventSender(platform, environment, options);\n\n  const diagnosticsEnabled = options.sendEvents && !options.diagnosticOptOut;\n  const diagnosticId = diagnosticsEnabled ? diagnostics.DiagnosticId(environment) : null;\n  const diagnosticsAccumulator = diagnosticsEnabled ? diagnostics.DiagnosticsAccumulator(new Date().getTime()) : null;\n  const diagnosticsManager = diagnosticsEnabled\n    ? diagnostics.DiagnosticsManager(\n        platform,\n        persistentStorage,\n        diagnosticsAccumulator,\n        eventSender,\n        environment,\n        options,\n        diagnosticId\n      )\n    : null;\n\n  const stream = Stream(platform, options, environment, diagnosticsAccumulator);\n\n  const events =\n    options.eventProcessor ||\n    EventProcessor(platform, options, environment, diagnosticsAccumulator, emitter, eventSender);\n\n  const requestor = Requestor(platform, options, environment);\n\n  const flagStore = FlagStore();\n\n  let useLocalStorage;\n  let streamActive;\n  let streamForcedState = options.streaming;\n  let subscribedToChangeEvents;\n  let inited = false;\n  let closed = false;\n  let firstEvent = true;\n\n  // The \"stateProvider\" object is used in the Electron SDK, to allow one client instance to take partial\n  // control of another. If present, it has the following contract:\n  // - getInitialState() returns the initial client state if it is already available. The state is an\n  //   object whose properties are \"environment\", \"context\", and \"flags\".\n  // - on(\"init\", listener) triggers an event when the initial client state becomes available, passing\n  //   the state object to the listener.\n  // - on(\"update\", listener) triggers an event when flag values change and/or the current context changes.\n  //   The parameter is an object that *may* contain \"context\" and/or \"flags\".\n  // - enqueueEvent(event) accepts an analytics event object and returns true if the stateProvider will\n  //   be responsible for delivering it, or false if we still should deliver it ourselves.\n  const stateProvider = options.stateProvider;\n\n  const ident = Identity(null, onIdentifyChange);\n  const anonymousContextProcessor = new AnonymousContextProcessor(persistentStorage);\n  const persistentFlagStore = persistentStorage.isEnabled()\n    ? PersistentFlagStore(persistentStorage, environment, hash, ident, logger)\n    : null;\n\n  function createLogger() {\n    if (specifiedOptions && specifiedOptions.logger) {\n      return specifiedOptions.logger;\n    }\n    return (extraOptionDefs && extraOptionDefs.logger && extraOptionDefs.logger.default) || commonBasicLogger('warn');\n  }\n\n  function readFlagsFromBootstrap(data) {\n    // If the bootstrap data came from an older server-side SDK, we'll have just a map of keys to values.\n    // Newer SDKs that have an allFlagsState method will provide an extra \"$flagsState\" key that contains\n    // the rest of the metadata we want. We do it this way for backward compatibility with older JS SDKs.\n    const keys = Object.keys(data);\n    const metadataKey = '$flagsState';\n    const validKey = '$valid';\n    const metadata = data[metadataKey];\n    if (!metadata && keys.length) {\n      logger.warn(messages.bootstrapOldFormat());\n    }\n    if (data[validKey] === false) {\n      logger.warn(messages.bootstrapInvalid());\n    }\n    const ret = {};\n    keys.forEach(key => {\n      if (key !== metadataKey && key !== validKey) {\n        let flag = { value: data[key] };\n        if (metadata && metadata[key]) {\n          flag = utils.extend(flag, metadata[key]);\n        } else {\n          flag.version = 0;\n        }\n        ret[key] = flag;\n      }\n    });\n    return ret;\n  }\n\n  function shouldEnqueueEvent() {\n    return sendEvents && !closed && !platform.isDoNotTrack();\n  }\n\n  function enqueueEvent(event) {\n    if (!environment) {\n      // We're in paired mode and haven't been initialized with an environment or context yet\n      return;\n    }\n    if (stateProvider && stateProvider.enqueueEvent && stateProvider.enqueueEvent(event)) {\n      return; // it'll be handled elsewhere\n    }\n\n    if (!event.context) {\n      if (firstEvent) {\n        logger.warn(messages.eventWithoutContext());\n        firstEvent = false;\n      }\n      return;\n    }\n    firstEvent = false;\n\n    if (shouldEnqueueEvent()) {\n      logger.debug(messages.debugEnqueueingEvent(event.kind));\n      events.enqueue(event);\n    }\n  }\n\n  function notifyInspectionFlagUsed(key, detail) {\n    if (inspectorManager.hasListeners(InspectorTypes.flagUsed)) {\n      inspectorManager.onFlagUsed(key, detail, ident.getContext());\n    }\n  }\n\n  function notifyInspectionIdentityChanged() {\n    if (inspectorManager.hasListeners(InspectorTypes.clientIdentityChanged)) {\n      inspectorManager.onIdentityChanged(ident.getContext());\n    }\n  }\n\n  function notifyInspectionFlagChanged(data, newFlag) {\n    if (inspectorManager.hasListeners(InspectorTypes.flagDetailChanged)) {\n      inspectorManager.onFlagChanged(data.key, getFlagDetail(newFlag));\n    }\n  }\n\n  function notifyInspectionFlagsChanged() {\n    if (inspectorManager.hasListeners(InspectorTypes.flagDetailsChanged)) {\n      inspectorManager.onFlags(\n        Object.entries(flagStore.getFlagsWithOverrides())\n          .map(([key, value]) => ({ key, detail: getFlagDetail(value) }))\n          .reduce((acc, cur) => {\n            // eslint-disable-next-line no-param-reassign\n            acc[cur.key] = cur.detail;\n            return acc;\n          }, {})\n      );\n    }\n  }\n\n  function onIdentifyChange(context) {\n    sendIdentifyEvent(context);\n    notifyInspectionIdentityChanged();\n  }\n\n  function sendIdentifyEvent(context) {\n    if (stateProvider) {\n      // In paired mode, the other client is responsible for sending identify events\n      return;\n    }\n    if (context) {\n      enqueueEvent({\n        kind: 'identify',\n        context,\n        creationDate: new Date().getTime(),\n      });\n    }\n  }\n\n  function sendFlagEvent(key, detail, defaultValue, includeReason) {\n    const context = ident.getContext();\n    const now = new Date();\n    const value = detail ? detail.value : null;\n\n    const event = {\n      kind: 'feature',\n      key: key,\n      context,\n      value: value,\n      variation: detail ? detail.variationIndex : null,\n      default: defaultValue,\n      creationDate: now.getTime(),\n    };\n    const flag = flagStore.getFlags()[key];\n    if (flag) {\n      event.version = flag.flagVersion ? flag.flagVersion : flag.version;\n      event.trackEvents = flag.trackEvents;\n      event.debugEventsUntilDate = flag.debugEventsUntilDate;\n    }\n    if ((includeReason || (flag && flag.trackReason)) && detail) {\n      event.reason = detail.reason;\n    }\n\n    enqueueEvent(event);\n  }\n\n  function verifyContext(context) {\n    // The context will already have been processed to have a string key, so we\n    // do not need to allow for legacy keys in the check.\n    if (checkContext(context, false)) {\n      return Promise.resolve(context);\n    } else {\n      return Promise.reject(new errors.LDInvalidUserError(messages.invalidContext()));\n    }\n  }\n\n  function identify(context, newHash, onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve({}), onDone);\n    }\n    if (stateProvider) {\n      // We're being controlled by another client instance, so only that instance is allowed to change the context\n      logger.warn(messages.identifyDisabled());\n      return utils.wrapPromiseCallback(\n        Promise.resolve(utils.transformVersionedValuesToValues(flagStore.getFlagsWithOverrides())),\n        onDone\n      );\n    }\n    let afterIdentify;\n    const clearFirst = useLocalStorage && persistentFlagStore ? persistentFlagStore.clearFlags() : Promise.resolve();\n    return utils.wrapPromiseCallback(\n      clearFirst\n        .then(() => anonymousContextProcessor.processContext(context))\n        .then(verifyContext)\n        .then(context => {\n          afterIdentify = utils.once(hookRunner.identify(context, undefined));\n          return context;\n        })\n        .then(validatedContext =>\n          requestor\n            .fetchFlagSettings(validatedContext, newHash)\n            // the following then() is nested within this one so we can use realUser from the previous closure\n            .then(requestedFlags => {\n              const flagValueMap = utils.transformVersionedValuesToValues(requestedFlags);\n              ident.setContext(validatedContext);\n              hash = newHash;\n              if (requestedFlags) {\n                return replaceAllFlags(requestedFlags).then(() => flagValueMap);\n              } else {\n                return flagValueMap;\n              }\n            })\n        )\n        .then(flagValueMap => {\n          afterIdentify?.({ status: 'completed' });\n          if (streamActive) {\n            connectStream();\n          }\n          return flagValueMap;\n        })\n        .catch(err => {\n          afterIdentify?.({ status: 'error' });\n          emitter.maybeReportError(err);\n          return Promise.reject(err);\n        }),\n      onDone\n    );\n  }\n\n  function getContext() {\n    return ident.getContext();\n  }\n\n  function flush(onDone) {\n    return utils.wrapPromiseCallback(sendEvents ? events.flush() : Promise.resolve(), onDone);\n  }\n\n  function variation(key, defaultValue) {\n    const { value } = hookRunner.withEvaluation(key, ident.getContext(), defaultValue, () =>\n      variationDetailInternal(key, defaultValue, true, false, false, true)\n    );\n    return value;\n  }\n\n  function variationDetail(key, defaultValue) {\n    return hookRunner.withEvaluation(key, ident.getContext(), defaultValue, () =>\n      variationDetailInternal(key, defaultValue, true, true, false, true)\n    );\n  }\n\n  function variationDetailInternal(key, defaultValue, sendEvent, includeReasonInEvent, isAllFlags, notifyInspection) {\n    let detail;\n\n    const flag = flagStore.get(key);\n\n    if (flag) {\n      detail = getFlagDetail(flag);\n      if (flag.value === null || flag.value === undefined) {\n        detail.value = defaultValue;\n      }\n    } else {\n      detail = { value: defaultValue, variationIndex: null, reason: { kind: 'ERROR', errorKind: 'FLAG_NOT_FOUND' } };\n    }\n\n    if (sendEvent) {\n      // For an all-flags evaluation, with events enabled, each flag will get an event, so we do not\n      // need to duplicate the prerequisites.\n      if (!isAllFlags) {\n        flag?.prerequisites?.forEach(key => {\n          variationDetailInternal(key, undefined, sendEvent, false, false, false);\n        });\n      }\n      sendFlagEvent(key, detail, defaultValue, includeReasonInEvent);\n    }\n\n    // For the all flags case `onFlags` will be called instead.\n    if (!isAllFlags && notifyInspection) {\n      notifyInspectionFlagUsed(key, detail);\n    }\n\n    return detail;\n  }\n\n  function getFlagDetail(flag) {\n    return {\n      value: flag.value,\n      variationIndex: flag.variation === undefined ? null : flag.variation,\n      reason: flag.reason || null,\n    };\n    // Note, the logic above ensures that variationIndex and reason will always be null rather than\n    // undefined if we don't have values for them. That's just to avoid subtle errors that depend on\n    // whether an object was JSON-encoded with null properties omitted or not.\n  }\n\n  function allFlags() {\n    const results = {};\n\n    const allFlags = flagStore.getFlagsWithOverrides();\n\n    if (!allFlags) {\n      return results;\n    }\n\n    for (const key in allFlags) {\n      results[key] = variationDetailInternal(key, null, !options.sendEventsOnlyForVariation, false, true, false).value;\n    }\n\n    return results;\n  }\n\n  function userContextKind(user) {\n    return user.anonymous ? 'anonymousUser' : 'user';\n  }\n\n  function track(key, data, metricValue) {\n    if (typeof key !== 'string') {\n      emitter.maybeReportError(new errors.LDInvalidEventKeyError(messages.unknownCustomEventKey(key)));\n      return;\n    }\n    if (metricValue !== undefined && typeof metricValue !== 'number') {\n      logger.warn(messages.invalidMetricValue(typeof metricValue));\n    }\n\n    // The following logic was used only for the JS browser SDK (js-client-sdk) and\n    // is no longer needed as of version 2.9.13 of that SDK. The other client-side\n    // JS-based SDKs did not define customEventFilter, and now none of them do. We\n    // can remove this in the next major version of the common code, when it's OK to\n    // make breaking changes to our internal API contracts.\n    if (platform.customEventFilter && !platform.customEventFilter(key)) {\n      logger.warn(messages.unknownCustomEventKey(key));\n    }\n\n    const context = ident.getContext();\n    const e = {\n      kind: 'custom',\n      key: key,\n      context,\n      url: platform.getCurrentUrl(),\n      creationDate: new Date().getTime(),\n    };\n    if (context && context.anonymous) {\n      e.contextKind = userContextKind(context);\n    }\n    // Note, check specifically for null/undefined because it is legal to set these fields to a falsey value.\n    if (data !== null && data !== undefined) {\n      e.data = data;\n    }\n    if (metricValue !== null && metricValue !== undefined) {\n      e.metricValue = metricValue;\n    }\n    enqueueEvent(e);\n    hookRunner.afterTrack({ context, key, data, metricValue });\n  }\n\n  function connectStream() {\n    streamActive = true;\n    if (!ident.getContext()) {\n      return;\n    }\n    const tryParseData = jsonData => {\n      try {\n        return JSON.parse(jsonData);\n      } catch (err) {\n        emitter.maybeReportError(new errors.LDInvalidDataError(messages.invalidData()));\n        return undefined;\n      }\n    };\n    stream.connect(ident.getContext(), hash, {\n      ping: function() {\n        logger.debug(messages.debugStreamPing());\n        const contextAtTimeOfPingEvent = ident.getContext();\n        requestor\n          .fetchFlagSettings(contextAtTimeOfPingEvent, hash)\n          .then(requestedFlags => {\n            // Check whether the current context is still the same - we don't want to overwrite the flags if\n            // the application has called identify() while this request was in progress\n            if (utils.deepEquals(contextAtTimeOfPingEvent, ident.getContext())) {\n              replaceAllFlags(requestedFlags || {});\n            }\n          })\n          .catch(err => {\n            emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n          });\n      },\n      put: function(e) {\n        const data = tryParseData(e.data);\n        if (!data) {\n          return;\n        }\n        logger.debug(messages.debugStreamPut());\n        replaceAllFlags(data);\n        // Don't wait for this Promise to be resolved; note that replaceAllFlags is guaranteed\n        // never to have an unhandled rejection\n      },\n      patch: function(e) {\n        const data = tryParseData(e.data);\n        if (!data) {\n          return;\n        }\n        // If both the flag and the patch have a version property, then the patch version must be\n        // greater than the flag version for us to accept the patch.  If either one has no version\n        // then the patch always succeeds.\n        const flags = flagStore.getFlags();\n        const oldFlag = flags[data.key];\n        if (!oldFlag || !oldFlag.version || !data.version || oldFlag.version < data.version) {\n          logger.debug(messages.debugStreamPatch(data.key));\n          const mods = {};\n          const newFlag = utils.extend({}, data);\n          delete newFlag['key'];\n          flags[data.key] = newFlag;\n          flagStore.setFlags(flags);\n          const newDetail = getFlagDetail(newFlag);\n          if (oldFlag) {\n            mods[data.key] = { previous: oldFlag.value, current: newDetail };\n          } else {\n            mods[data.key] = { current: newDetail };\n          }\n          notifyInspectionFlagChanged(data, newFlag);\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n        } else {\n          logger.debug(messages.debugStreamPatchIgnored(data.key));\n        }\n      },\n      delete: function(e) {\n        const data = tryParseData(e.data);\n        if (!data) {\n          return;\n        }\n        const flags = flagStore.getFlags();\n        if (!flags[data.key] || flags[data.key].version < data.version) {\n          logger.debug(messages.debugStreamDelete(data.key));\n          const mods = {};\n          if (flags[data.key] && !flags[data.key].deleted) {\n            mods[data.key] = { previous: flags[data.key].value };\n          }\n          flags[data.key] = { version: data.version, deleted: true };\n          flagStore.setFlags(flags);\n          notifyInspectionFlagChanged(data, flags[data.key]);\n          handleFlagChanges(mods); // don't wait for this Promise to be resolved\n        } else {\n          logger.debug(messages.debugStreamDeleteIgnored(data.key));\n        }\n      },\n    });\n  }\n\n  function disconnectStream() {\n    if (streamActive) {\n      stream.disconnect();\n      streamActive = false;\n    }\n  }\n\n  // Returns a Promise which will be resolved when we have completely updated the internal flags state,\n  // dispatched all change events, and updated local storage if appropriate. This Promise is guaranteed\n  // never to have an unhandled rejection.\n  function replaceAllFlags(newFlags) {\n    const changes = {};\n\n    if (!newFlags) {\n      return Promise.resolve();\n    }\n\n    const flags = flagStore.getFlags();\n    for (const key in flags) {\n      if (utils.objectHasOwnProperty(flags, key) && flags[key]) {\n        if (newFlags[key] && !utils.deepEquals(newFlags[key].value, flags[key].value)) {\n          changes[key] = { previous: flags[key].value, current: getFlagDetail(newFlags[key]) };\n        } else if (!newFlags[key] || newFlags[key].deleted) {\n          changes[key] = { previous: flags[key].value };\n        }\n      }\n    }\n    for (const key in newFlags) {\n      if (utils.objectHasOwnProperty(newFlags, key) && newFlags[key] && (!flags[key] || flags[key].deleted)) {\n        changes[key] = { current: getFlagDetail(newFlags[key]) };\n      }\n    }\n\n    flagStore.setFlags({ ...newFlags });\n\n    notifyInspectionFlagsChanged();\n\n    return handleFlagChanges(changes).catch(() => {}); // swallow any exceptions from this Promise\n  }\n\n  // Returns a Promise which will be resolved when we have dispatched all change events and updated\n  // local storage if appropriate.\n  function handleFlagChanges(changes) {\n    const keys = Object.keys(changes);\n\n    if (keys.length > 0) {\n      const changeEventParams = {};\n      keys.forEach(key => {\n        const current = changes[key].current;\n        const value = current ? current.value : undefined;\n        const previous = changes[key].previous;\n        emitter.emit(changeEvent + ':' + key, value, previous);\n        changeEventParams[key] = current ? { current: value, previous: previous } : { previous: previous };\n      });\n\n      emitter.emit(changeEvent, changeEventParams);\n      emitter.emit(internalChangeEvent, flagStore.getFlagsWithOverrides());\n\n      // By default, we send feature evaluation events whenever we have received new flag values -\n      // the client has in effect evaluated these flags just by receiving them. This can be suppressed\n      // by setting \"sendEventsOnlyForVariation\". Also, if we have a stateProvider, we don't send these\n      // events because we assume they have already been sent by the other client that gave us the flags\n      // (when it received them in the first place).\n      if (!options.sendEventsOnlyForVariation && !stateProvider) {\n        keys.forEach(key => {\n          sendFlagEvent(key, changes[key].current);\n        });\n      }\n    }\n\n    if (useLocalStorage && persistentFlagStore) {\n      return persistentFlagStore.saveFlags(flagStore.getFlags());\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function on(event, handler, context) {\n    if (isChangeEventKey(event)) {\n      subscribedToChangeEvents = true;\n      if (inited) {\n        updateStreamingState();\n      }\n      emitter.on(event, handler, context);\n    } else {\n      emitter.on(...arguments);\n    }\n  }\n\n  function off(event) {\n    emitter.off(...arguments);\n    if (isChangeEventKey(event)) {\n      let haveListeners = false;\n      emitter.getEvents().forEach(key => {\n        if (isChangeEventKey(key) && emitter.getEventListenerCount(key) > 0) {\n          haveListeners = true;\n        }\n      });\n      if (!haveListeners) {\n        subscribedToChangeEvents = false;\n        if (streamActive && streamForcedState === undefined) {\n          disconnectStream();\n        }\n      }\n    }\n  }\n\n  function setStreaming(state) {\n    const newState = state === null ? undefined : state;\n    if (newState !== streamForcedState) {\n      streamForcedState = newState;\n      updateStreamingState();\n    }\n  }\n\n  function updateStreamingState() {\n    const shouldBeStreaming = streamForcedState || (subscribedToChangeEvents && streamForcedState === undefined);\n    if (shouldBeStreaming && !streamActive) {\n      connectStream();\n    } else if (!shouldBeStreaming && streamActive) {\n      disconnectStream();\n    }\n    if (diagnosticsManager) {\n      diagnosticsManager.setStreaming(shouldBeStreaming);\n    }\n  }\n\n  function isChangeEventKey(event) {\n    return event === changeEvent || event.substr(0, changeEvent.length + 1) === changeEvent + ':';\n  }\n\n  if (typeof options.bootstrap === 'string' && options.bootstrap.toUpperCase() === 'LOCALSTORAGE') {\n    if (persistentFlagStore) {\n      useLocalStorage = true;\n    } else {\n      logger.warn(messages.localStorageUnavailable());\n    }\n  }\n\n  if (typeof options.bootstrap === 'object') {\n    // Set the flags as soon as possible before we get into any async code, so application code can read\n    // them even if the ready event has not yet fired.\n    flagStore.setFlags(readFlagsFromBootstrap(options.bootstrap));\n  }\n\n  if (stateProvider) {\n    // The stateProvider option is used in the Electron SDK, to allow a client instance in the main process\n    // to control another client instance (i.e. this one) in the renderer process. We can't predict which\n    // one will start up first, so the initial state may already be available for us or we may have to wait\n    // to receive it.\n    const state = stateProvider.getInitialState();\n    if (state) {\n      initFromStateProvider(state);\n    } else {\n      stateProvider.on('init', initFromStateProvider);\n    }\n    stateProvider.on('update', updateFromStateProvider);\n  } else {\n    finishInit().catch(signalFailedInit);\n  }\n\n  function finishInit() {\n    if (!env) {\n      return Promise.reject(new errors.LDInvalidEnvironmentIdError(messages.environmentNotSpecified()));\n    }\n    let afterIdentify;\n    return anonymousContextProcessor\n      .processContext(context)\n      .then(verifyContext)\n      .then(context => {\n        afterIdentify = utils.once(hookRunner.identify(context, undefined));\n        return context;\n      })\n      .then(validatedContext => {\n        afterIdentify?.({ status: 'completed' });\n        ident.setContext(validatedContext);\n        if (typeof options.bootstrap === 'object') {\n          // flags have already been set earlier\n          return signalSuccessfulInit();\n        } else if (useLocalStorage) {\n          return finishInitWithLocalStorage();\n        } else {\n          return finishInitWithPolling();\n        }\n      })\n      .catch(err => {\n        afterIdentify?.({ status: 'error' });\n        throw err;\n      });\n  }\n\n  function finishInitWithLocalStorage() {\n    return persistentFlagStore.loadFlags().then(storedFlags => {\n      if (storedFlags === null || storedFlags === undefined) {\n        flagStore.setFlags({});\n        return requestor\n          .fetchFlagSettings(ident.getContext(), hash)\n          .then(requestedFlags => replaceAllFlags(requestedFlags || {}))\n          .then(signalSuccessfulInit)\n          .catch(err => {\n            const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n            signalFailedInit(initErr);\n          });\n      } else {\n        // We're reading the flags from local storage. Signal that we're ready,\n        // then update localStorage for the next page load. We won't signal changes or update\n        // the in-memory flags unless you subscribe for changes\n        flagStore.setFlags(storedFlags);\n        utils.onNextTick(signalSuccessfulInit);\n\n        return requestor\n          .fetchFlagSettings(ident.getContext(), hash)\n          .then(requestedFlags => replaceAllFlags(requestedFlags))\n          .catch(err => emitter.maybeReportError(err));\n      }\n    });\n  }\n\n  function finishInitWithPolling() {\n    return requestor\n      .fetchFlagSettings(ident.getContext(), hash)\n      .then(requestedFlags => {\n        flagStore.setFlags(requestedFlags || {});\n\n        notifyInspectionFlagsChanged();\n        // Note, we don't need to call updateSettings here because local storage and change events are not relevant\n        signalSuccessfulInit();\n      })\n      .catch(err => {\n        flagStore.setFlags({});\n        signalFailedInit(err);\n      });\n  }\n\n  function initFromStateProvider(state) {\n    environment = state.environment;\n    ident.setContext(state.context);\n    flagStore.setFlags({ ...state.flags });\n    utils.onNextTick(signalSuccessfulInit);\n  }\n\n  function updateFromStateProvider(state) {\n    if (state.context) {\n      ident.setContext(state.context);\n    }\n    if (state.flags) {\n      replaceAllFlags(state.flags); // don't wait for this Promise to be resolved\n    }\n  }\n\n  function signalSuccessfulInit() {\n    logger.info(messages.clientInitialized());\n    inited = true;\n    updateStreamingState();\n    initializationStateTracker.signalSuccess();\n  }\n\n  function signalFailedInit(err) {\n    initializationStateTracker.signalFailure(err);\n  }\n\n  function start() {\n    if (sendEvents) {\n      if (diagnosticsManager) {\n        diagnosticsManager.start();\n      }\n      events.start();\n    }\n  }\n\n  function close(onDone) {\n    if (closed) {\n      return utils.wrapPromiseCallback(Promise.resolve(), onDone);\n    }\n    const finishClose = () => {\n      closed = true;\n      flagStore.setFlags({});\n    };\n    const p = Promise.resolve()\n      .then(() => {\n        disconnectStream();\n        if (diagnosticsManager) {\n          diagnosticsManager.stop();\n        }\n        if (sendEvents) {\n          events.stop();\n          return events.flush();\n        }\n      })\n      .then(finishClose)\n      .catch(finishClose);\n    return utils.wrapPromiseCallback(p, onDone);\n  }\n\n  function getFlagsInternal() {\n    // used by Electron integration\n    return flagStore.getFlagsWithOverrides();\n  }\n\n  function waitForInitializationWithTimeout(timeout) {\n    if (timeout > highTimeoutThreshold) {\n      logger.warn(\n        'The waitForInitialization function was called with a timeout greater than ' +\n          `${highTimeoutThreshold} seconds. We recommend a timeout of ` +\n          `${highTimeoutThreshold} seconds or less.`\n      );\n    }\n\n    const initPromise = initializationStateTracker.getInitializationPromise();\n    const timeoutPromise = timedPromise(timeout, 'waitForInitialization');\n\n    return Promise.race([timeoutPromise, initPromise]).catch(e => {\n      if (e instanceof errors.LDTimeoutError) {\n        logger.error(`waitForInitialization error: ${e}`);\n      }\n      throw e;\n    });\n  }\n\n  function waitForInitialization(timeout = undefined) {\n    if (timeout !== undefined && timeout !== null) {\n      if (typeof timeout === 'number') {\n        return waitForInitializationWithTimeout(timeout);\n      }\n      logger.warn('The waitForInitialization method was provided with a non-numeric timeout.');\n    }\n    logger.warn(\n      'The waitForInitialization function was called without a timeout specified.' +\n        ' In a future version a default timeout will be applied.'\n    );\n    return initializationStateTracker.getInitializationPromise();\n  }\n\n  function addHook(hook) {\n    hookRunner.addHook(hook);\n  }\n\n  const client = {\n    waitForInitialization,\n    waitUntilReady: () => initializationStateTracker.getReadyPromise(),\n    identify: identify,\n    getContext: getContext,\n    variation: variation,\n    variationDetail: variationDetail,\n    track: track,\n    on: on,\n    off: off,\n    setStreaming: setStreaming,\n    flush: flush,\n    allFlags: allFlags,\n    close: close,\n    addHook: addHook,\n  };\n\n  registerPlugins(logger, pluginEnvironment, client, plugins);\n\n  function setOverride(key, value) {\n    const mods = {};\n\n    const currentFlag = flagStore.get(key);\n    const currentValue = currentFlag ? currentFlag.value : null;\n\n    if (currentValue === value) {\n      logger.debug(`setOverride: No change needed for ${key}, value already ${value}`);\n      return;\n    }\n\n    flagStore.setOverride(key, value);\n    const newFlag = flagStore.get(key);\n    const newDetail = getFlagDetail(newFlag);\n\n    mods[key] = { previous: currentValue, current: newDetail };\n\n    notifyInspectionFlagChanged({ key }, newFlag);\n    handleFlagChanges(mods);\n  }\n\n  function removeOverride(key) {\n    const flagOverrides = flagStore.getFlagOverrides();\n    if (!flagOverrides[key]) {\n      return; // No override to remove\n    }\n\n    const mods = {};\n    const oldOverride = flagOverrides[key];\n    const flags = flagStore.getFlags();\n    const realFlag = flags[key];\n\n    mods[key] = { previous: oldOverride.value, current: realFlag ? getFlagDetail(realFlag) : undefined };\n\n    flagStore.removeOverride(key);\n    notifyInspectionFlagChanged({ key }, realFlag);\n    handleFlagChanges(mods); // don't wait for this Promise to be resolved\n  }\n\n  function clearAllOverrides() {\n    const flagOverrides = flagStore.getFlagOverrides();\n    if (Object.keys(flagOverrides).length === 0) {\n      return; // No overrides to clear\n    }\n\n    const mods = {};\n    const flags = flagStore.getFlags();\n    Object.keys(flagOverrides).forEach(key => {\n      const oldOverride = flagOverrides[key];\n      const realFlag = flags[key];\n\n      mods[key] = { previous: oldOverride.value, current: realFlag ? getFlagDetail(realFlag) : undefined };\n    });\n\n    flagStore.clearAllOverrides();\n\n    if (Object.keys(mods).length > 0) {\n      handleFlagChanges(mods); // don't wait for this Promise to be resolved\n    }\n  }\n\n  function getAllOverrides() {\n    const flagOverrides = flagStore.getFlagOverrides();\n\n    if (!flagOverrides) {\n      return {}; // No overrides set\n    }\n\n    const result = {};\n    Object.keys(flagOverrides).forEach(key => {\n      const override = flagOverrides[key];\n      if (override) {\n        result[key] = override.value;\n      }\n    });\n    return result;\n  }\n\n  const debugOverride = {\n    setOverride: setOverride,\n    removeOverride: removeOverride,\n    clearAllOverrides: clearAllOverrides,\n    getAllOverrides: getAllOverrides,\n  };\n\n  // Register plugins for debug override capabilities\n  registerPluginsForDebugOverride(logger, debugOverride, plugins);\n\n  return {\n    client: client, // The client object containing all public methods.\n    options: options, // The validated configuration object, including all defaults.\n    emitter: emitter, // The event emitter which can be used to log errors or trigger events.\n    ident: ident, // The Identity object that manages the current context.\n    logger: logger, // The logging abstraction.\n    requestor: requestor, // The Requestor object.\n    start: start, // Starts the client once the environment is ready.\n    enqueueEvent: enqueueEvent, // Puts an analytics event in the queue, if event sending is enabled.\n    getFlagsInternal: getFlagsInternal, // Returns flag data structure with all details.\n    getEnvironmentId: () => environment, // Gets the environment ID (this may have changed since initialization, if we have a state provider)\n    internalChangeEventName: internalChangeEvent, // This event is triggered whenever we have new flag state.\n  };\n}\n\nmodule.exports = {\n  initialize,\n  commonBasicLogger,\n  errors,\n  messages,\n  utils,\n  getContextKeys,\n};\n", "const { commonBasicLogger } = require('launchdarkly-js-sdk-common');\n\nfunction basicLogger(options) {\n  return commonBasicLogger({ destination: console.log, ...options });\n}\n\nmodule.exports = {\n  basicLogger,\n};\n", "function isSyncXhrSupported() {\n  // This is temporary logic to disable synchronous XHR in Chrome 73 and above. In all other browsers,\n  // we will assume it is supported. See https://github.com/launchdarkly/js-client-sdk/issues/147\n  const userAgent = window.navigator && window.navigator.userAgent;\n  if (userAgent) {\n    const chromeMatch = userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n    if (chromeMatch) {\n      const version = parseInt(chromeMatch[2], 10);\n      return version < 73;\n    }\n  }\n  return true;\n}\n\nconst emptyResult = { promise: Promise.resolve({ status: 200, header: () => null, body: null }) };\n\nexport default function newHttpRequest(method, url, headers, body, pageIsClosing) {\n  if (pageIsClosing) {\n    // When the page is about to close, we have to use synchronous XHR (until we migrate to sendBeacon).\n    // But not all browsers support this.\n    if (!isSyncXhrSupported()) {\n      return emptyResult;\n      // Note that we return a fake success response, because we don't want the request to be retried in this case.\n    }\n  }\n\n  const xhr = new window.XMLHttpRequest();\n  xhr.open(method, url, !pageIsClosing);\n  for (const key in headers || {}) {\n    if (Object.prototype.hasOwnProperty.call(headers, key)) {\n      xhr.setRequestHeader(key, headers[key]);\n    }\n  }\n  if (pageIsClosing) {\n    try {\n      xhr.send(body); // We specified synchronous mode when we called xhr.open\n    } catch (e) {\n      // do nothing intentionally to suppress noise for now\n    }\n    return emptyResult; // Again, we never want a request to be retried in this case, so we must say it succeeded.\n  } else {\n    let cancelled;\n    const p = new Promise((resolve, reject) => {\n      xhr.addEventListener('load', () => {\n        if (cancelled) {\n          return;\n        }\n        resolve({\n          status: xhr.status,\n          header: (key) => xhr.getResponseHeader(key),\n          body: xhr.responseText,\n        });\n      });\n      xhr.addEventListener('error', () => {\n        if (cancelled) {\n          return;\n        }\n        reject(new Error());\n      });\n      xhr.send(body);\n    });\n    const cancel = () => {\n      cancelled = true;\n      xhr.abort();\n    };\n    return { promise: p, cancel: cancel };\n  }\n}\n", "'use strict';\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a \\unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n};\n", "import escapeStringRegexp from 'escape-string-regexp';\n\nexport function doesUrlMatch(matcher, href, search, hash) {\n  const keepHash = (matcher.kind === 'substring' || matcher.kind === 'regex') && hash.includes('/');\n  const canonicalUrl = (keepHash ? href : href.replace(hash, '')).replace(search, '');\n\n  let regex;\n  let testUrl;\n\n  switch (matcher.kind) {\n    case 'exact':\n      testUrl = href;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'canonical':\n      testUrl = canonicalUrl;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'substring':\n      testUrl = canonicalUrl;\n      regex = new RegExp('.*' + escapeStringRegexp(matcher.substring) + '.*$');\n      break;\n    case 'regex':\n      testUrl = canonicalUrl;\n      regex = new RegExp(matcher.pattern);\n      break;\n    default:\n      return false;\n  }\n  return regex.test(testUrl);\n}\n\nfunction findGoalsForClick(event, clickGoals) {\n  const matches = [];\n\n  for (let i = 0; i < clickGoals.length; i++) {\n    let target = event.target;\n    const goal = clickGoals[i];\n    const selector = goal.selector;\n    const elements = document.querySelectorAll(selector);\n    while (target && elements.length > 0) {\n      for (let j = 0; j < elements.length; j++) {\n        if (target === elements[j]) {\n          matches.push(goal);\n        }\n      }\n      target = target.parentNode;\n    }\n  }\n\n  return matches;\n}\n\nexport default function GoalTracker(goals, onEvent) {\n  const tracker = {};\n  let listenerFn = null;\n\n  const clickGoals = [];\n\n  for (let i = 0; i < goals.length; i++) {\n    const goal = goals[i];\n    const urls = goal.urls || [];\n\n    for (let j = 0; j < urls.length; j++) {\n      if (doesUrlMatch(urls[j], window.location.href, window.location.search, window.location.hash)) {\n        if (goal.kind === 'pageview') {\n          onEvent('pageview', goal);\n        } else {\n          clickGoals.push(goal);\n          onEvent('click_pageview', goal);\n        }\n        break;\n      }\n    }\n  }\n\n  if (clickGoals.length > 0) {\n    listenerFn = function (event) {\n      const goals = findGoalsForClick(event, clickGoals);\n      for (let i = 0; i < goals.length; i++) {\n        onEvent('click', goals[i]);\n      }\n    };\n\n    document.addEventListener('click', listenerFn);\n  }\n\n  tracker.dispose = function () {\n    document.removeEventListener('click', listenerFn);\n  };\n\n  return tracker;\n}\n", "import * as common from 'launchdarkly-js-sdk-common';\nimport GoalTracker from './GoalTracker';\n\nconst locationWatcherInterval = 300;\n\nexport default function GoalManager(clientVars, readyCallback) {\n  let goals;\n  let goalTracker;\n\n  const ret = {};\n\n  function getGoalsPath() {\n    return '/sdk/goals/' + clientVars.getEnvironmentId();\n  }\n\n  function refreshGoalTracker() {\n    if (goalTracker) {\n      goalTracker.dispose();\n    }\n    if (goals && goals.length) {\n      goalTracker = GoalTracker(goals, sendGoalEvent);\n    }\n  }\n\n  function sendGoalEvent(kind, goal) {\n    const context = clientVars.ident.getContext();\n    const event = {\n      kind: kind,\n      key: goal.key,\n      data: null,\n      url: window.location.href,\n      creationDate: new Date().getTime(),\n      context: context,\n    };\n\n    if (kind === 'click') {\n      event.selector = goal.selector;\n    }\n\n    return clientVars.enqueueEvent(event);\n  }\n\n  function watchLocation(interval, callback) {\n    let previousUrl = window.location.href;\n    let currentUrl;\n\n    function checkUrl() {\n      currentUrl = window.location.href;\n\n      if (currentUrl !== previousUrl) {\n        previousUrl = currentUrl;\n        callback();\n      }\n    }\n\n    function poll(fn, interval) {\n      fn();\n      setTimeout(() => {\n        poll(fn, interval);\n      }, interval);\n    }\n\n    poll(checkUrl, interval);\n\n    if (window.history && window.history.pushState) {\n      window.addEventListener('popstate', checkUrl);\n    } else {\n      window.addEventListener('hashchange', checkUrl);\n    }\n  }\n\n  clientVars.requestor\n    .fetchJSON(getGoalsPath())\n    .then((g) => {\n      if (g && g.length > 0) {\n        goals = g;\n        goalTracker = GoalTracker(goals, sendGoalEvent);\n        watchLocation(locationWatcherInterval, refreshGoalTracker);\n      }\n      readyCallback();\n    })\n    .catch((err) => {\n      clientVars.emitter.maybeReportError(\n        new common.errors.LDUnexpectedResponseError('Error fetching goals: ' + (err && err.message) ? err.message : err)\n      );\n      readyCallback();\n    });\n\n  return ret;\n}\n", "import * as common from 'launchdarkly-js-sdk-common';\nimport * as importBasicLogger from './basicLogger';\nimport browserPlatform from './browserPlatform';\nimport GoalManager from './GoalManager';\n\nconst goalsEvent = 'goalsReady';\nconst extraOptionDefs = {\n  fetchGoals: { default: true },\n  hash: { type: 'string' },\n  eventProcessor: { type: 'object' }, // used only in tests\n  eventUrlTransformer: { type: 'function' },\n  disableSyncEventPost: { default: false },\n};\n\n// Pass our platform object to the common code to create the browser version of the client\nexport function initialize(env, user, options = {}) {\n  const platform = browserPlatform(options);\n  const clientVars = common.initialize(env, user, options, platform, extraOptionDefs);\n\n  const client = clientVars.client;\n  const validatedOptions = clientVars.options;\n  const emitter = clientVars.emitter;\n\n  const goalsPromise = new Promise((resolve) => {\n    const onGoals = emitter.on(goalsEvent, () => {\n      emitter.off(goalsEvent, onGoals);\n      resolve();\n    });\n  });\n  client.waitUntilGoalsReady = () => goalsPromise;\n\n  if (validatedOptions.fetchGoals) {\n    GoalManager(clientVars, () => emitter.emit(goalsEvent));\n    // Don't need to save a reference to the GoalManager - its constructor takes care of setting\n    // up the necessary event wiring\n  } else {\n    emitter.emit(goalsEvent);\n  }\n\n  if (document.readyState !== 'complete') {\n    window.addEventListener('load', clientVars.start);\n  } else {\n    clientVars.start();\n  }\n\n  const syncFlush = () => {\n    // Synchronous events are not available in all browsers, but where they\n    // are we should attempt to use them. This increases the chance of the events\n    // being delivered.\n    platform.synchronousFlush = true;\n    client.flush().catch(() => {});\n    platform.synchronousFlush = false;\n  };\n\n  // When the visibility of the page changes to hidden we want to flush any pending events.\n  //\n  // This is handled with visibility, instead of beforeunload/unload\n  // because those events are not compatible with the bfcache and are unlikely\n  // to be called in many situations. For more information see: https://developer.chrome.com/blog/page-lifecycle-api/\n  //\n  // Redundancy is included by using both the visibilitychange handler as well as\n  // pagehide, because different browsers, and versions have different bugs with each.\n  // This also may provide more opportunity for the events to get flushed.\n  //\n  const handleVisibilityChange = () => {\n    if (document.visibilityState === 'hidden') {\n      syncFlush();\n    }\n  };\n\n  document.addEventListener('visibilitychange', handleVisibilityChange);\n  window.addEventListener('pagehide', syncFlush);\n\n  return client;\n}\n\nexport const basicLogger = importBasicLogger.basicLogger;\n\nexport const createConsoleLogger = common.createConsoleLogger;\n\nexport const version = VERSION;\n\nfunction deprecatedInitialize(env, user, options = {}) {\n  console && console.warn && console.warn(common.messages.deprecated('default export', 'named LDClient export')); // eslint-disable-line no-console\n  return initialize(env, user, options);\n}\n\nexport default { initialize: deprecatedInitialize, version };\n", "import newHttpRequest from './httpRequest';\n\nexport default function makeBrowserPlatform(options) {\n  const ret = {\n    userAgentHeaderName: 'X-LaunchDarkly-User-Agent',\n  };\n\n  ret.synchronousFlush = false; // this will be set to true by index.js if the page is hidden\n\n  // XMLHttpRequest may not exist if we're running in a server-side rendering context\n  if (window.XMLHttpRequest) {\n    const disableSyncFlush = options && options.disableSyncEventPost;\n    ret.httpRequest = (method, url, headers, body) => {\n      const syncFlush = ret.synchronousFlush & !disableSyncFlush;\n      ret.synchronousFlush = false;\n      return newHttpRequest(method, url, headers, body, syncFlush);\n    };\n  }\n\n  let hasCors;\n  ret.httpAllowsPost = () => {\n    // We compute this lazily because calling XMLHttpRequest() at initialization time can disrupt tests\n    if (hasCors === undefined) {\n      hasCors = window.XMLHttpRequest ? 'withCredentials' in new window.XMLHttpRequest() : false;\n    }\n    return hasCors;\n  };\n\n  // Image-based mechanism for sending events if POST isn't available\n  ret.httpFallbackPing = (url) => {\n    const img = new window.Image();\n    img.src = url;\n  };\n\n  const eventUrlTransformer = options && options.eventUrlTransformer;\n  ret.getCurrentUrl = () => (eventUrlTransformer ? eventUrlTransformer(window.location.href) : window.location.href);\n\n  ret.isDoNotTrack = () => {\n    let flag;\n    if (window.navigator && window.navigator.doNotTrack !== undefined) {\n      flag = window.navigator.doNotTrack; // FF, Chrome\n    } else if (window.navigator && window.navigator.msDoNotTrack !== undefined) {\n      flag = window.navigator.msDoNotTrack; // IE 9/10\n    } else {\n      flag = window.doNotTrack; // IE 11+, Safari\n    }\n    return flag === 1 || flag === true || flag === '1' || flag === 'yes';\n  };\n\n  try {\n    if (window.localStorage) {\n      ret.localStorage = {\n        get: (key) =>\n          new Promise((resolve) => {\n            resolve(window.localStorage.getItem(key));\n          }),\n        set: (key, value) =>\n          new Promise((resolve) => {\n            window.localStorage.setItem(key, value);\n            resolve();\n          }),\n        clear: (key) =>\n          new Promise((resolve) => {\n            window.localStorage.removeItem(key);\n            resolve();\n          }),\n      };\n    }\n  } catch (e) {\n    // In some browsers (such as Chrome), even looking at window.localStorage at all will cause a\n    // security error if the feature is disabled.\n    ret.localStorage = null;\n  }\n\n  // The browser built-in EventSource implementations do not support setting the method used for\n  // the request. When useReport is true, we ensure sending the user in the body of a REPORT request\n  // rather than in the URL path. If a polyfill for EventSource that supports setting the request\n  // method is provided (currently, launchdarkly-eventsource is the only polyfill that both supports\n  // it and gives us a way to *know* that it supports it), we use the polyfill to connect to a flag\n  // stream that will provide evaluated flags for the specific user. Otherwise, when useReport is\n  // true, we fall back to a generic  'ping' stream that informs the SDK to make a separate REPORT\n  // request for the user's flag evaluations whenever the flag definitions have been updated.\n  let eventSourceConstructor;\n  const useReport = options && options.useReport;\n  if (\n    useReport &&\n    typeof window.EventSourcePolyfill === 'function' &&\n    window.EventSourcePolyfill.supportedOptions &&\n    window.EventSourcePolyfill.supportedOptions.method\n  ) {\n    ret.eventSourceAllowsReport = true;\n    eventSourceConstructor = window.EventSourcePolyfill;\n  } else {\n    ret.eventSourceAllowsReport = false;\n    eventSourceConstructor = window.EventSource;\n  }\n\n  // If EventSource does not exist, the absence of eventSourceFactory will make us not try to open streams\n  if (window.EventSource) {\n    const timeoutMillis = 300000; // this is only used by polyfills - see below\n\n    ret.eventSourceFactory = (url, options) => {\n      // The standard EventSource constructor doesn't take any options, just a URL. However, some\n      // EventSource polyfills allow us to specify a timeout interval, and in some cases they will\n      // default to a too-short timeout if we don't specify one. So, here, we are setting the\n      // timeout properties that are used by several popular polyfills.\n      // Also, the skipDefaultHeaders property (if supported) tells the polyfill not to add the\n      // Cache-Control header that can cause CORS problems in browsers.\n      // See: https://github.com/launchdarkly/js-eventsource\n      const defaultOptions = {\n        heartbeatTimeout: timeoutMillis,\n        silentTimeout: timeoutMillis,\n        skipDefaultHeaders: true,\n      };\n\n      const esOptions = { ...defaultOptions, ...options };\n\n      return new eventSourceConstructor(url, esOptions);\n    };\n\n    ret.eventSourceIsActive = (es) =>\n      es.readyState === window.EventSource.OPEN || es.readyState === window.EventSource.CONNECTING;\n  }\n\n  ret.userAgent = 'JSClient';\n  ret.version = VERSION;\n\n  ret.diagnosticSdkData = {\n    name: 'js-client-sdk',\n    version: VERSION,\n  };\n\n  ret.diagnosticPlatformData = {\n    name: 'JS',\n  };\n\n  ret.diagnosticUseCombinedEvent = true; // the browser SDK uses the \"diagnostic-combined\" event format\n\n  return ret;\n}\n"],
  "mappings": "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",
  "names": ["createCustomError", "name", "CustomError", "message", "code", "Error", "captureStackTrace", "this", "constructor", "prototype", "LDUnexpectedResponseError", "LDInvalidEnvironmentIdError", "LDInvalidUserError", "LDInvalidEventKeyError", "LDInvalidArgumentError", "LDFlagFetchError", "errors", "LDInvalidDataError", "LDTimeoutError", "isHttpErrorRecoverable", "status", "byteLength_1", "b64", "lens", "getLens", "validLen", "placeHoldersLen", "toByteArray_1", "tmp", "i", "arr", "Arr", "curByte", "len", "revLookup", "charCodeAt", "fromByteArray_1", "uint8", "length", "extraBytes", "parts", "maxChunkLength", "len2", "push", "encodeChunk", "lookup", "join", "Uint8Array", "Array", "indexOf", "tripletToBase64", "num", "start", "end", "output", "isArray", "keyList", "Object", "keys", "hasProp", "hasOwnProperty", "fastDeepEqual", "equal", "a", "b", "key", "arrA", "arrB", "dateA", "Date", "dateB", "getTime", "regexpA", "RegExp", "regexpB", "toString", "call", "userAttrsToStringify", "btoa", "s", "escaped", "unescape", "encodeURIComponent", "base64", "fromByteArray", "objectHasOwnProperty", "object", "getRandomValues", "utils", "appendUrlPath", "baseUrl", "path", "endsWith", "substring", "startsWith", "base64URLEncode", "replace", "clone", "obj", "JSON", "parse", "stringify", "deepEquals", "extend", "objects", "reduce", "acc", "getLDUserAgentString", "platform", "version", "userAgent", "onNextTick", "cb", "setTimeout", "sanitizeContext", "context", "newContext", "kind", "forEach", "attr", "value", "String", "transformValuesToVersionedValues", "flags", "ret", "transformVersionedValuesToValues", "flagsState", "wrapPromiseCallback", "promise", "callback", "then", "error", "Promise", "reject", "once", "func", "result", "called", "args", "apply", "rnds8", "rng", "crypto", "bind", "msCrypto", "REGEX", "validate", "uuid", "test", "byteToHex", "substr", "_nodeId", "_clockseq", "offset", "arguments", "toLowerCase", "TypeError", "_lastMSecs", "_lastNSecs", "v", "parseInt", "slice", "v35", "hashfunc", "generateUUID", "namespace", "buf", "str", "bytes", "set", "err", "DNS", "URL", "getOutputLength", "inputLength8", "safeAdd", "x", "y", "lsw", "md5cmn", "q", "t", "cnt", "md5ff", "c", "d", "md5gg", "md5hh", "md5ii", "v3", "msg", "input", "length32", "hexTab", "hex", "charAt", "olda", "oldb", "oldc", "oldd", "length8", "Uint32Array", "v3$1", "f", "z", "ROTL", "n", "v5", "K", "H", "l", "N", "Math", "ceil", "M", "_i", "j", "pow", "floor", "_i2", "W", "_t", "e", "_t2", "T", "v5$1", "options", "node", "clockseq", "seedBytes", "random", "msecs", "now", "nsecs", "dt", "tl", "tmh", "rnds", "logLevels", "loggers", "commonBasicLogger", "formatFn", "destination", "toConsole", "methodName", "line", "console", "destinations", "prependLevelToMessage", "prefix", "minLevel", "level", "write", "levelIndex", "levelName", "fullPrefix", "tempArgs", "log", "logger", "validateLogger", "errorString", "docLink", "messages", "bootstrapInvalid", "bootstrapOldFormat", "clientInitialized", "clientNotReady", "debugEnqueueingEvent", "debugPostingDiagnosticEvent", "event", "debugPostingEvents", "count", "debugStreamDelete", "debugStreamDeleteIgnored", "debugStreamPatch", "debugStreamPatchIgnored", "debugStreamPing", "debugPolling", "url", "debugStreamPut", "deprecated", "oldName", "newName", "environmentNotFound", "environmentNotSpecified", "errorFetchingFlags", "eventCapacityExceeded", "eventWithoutContext", "httpErrorMessage", "retryMessage", "httpUnavailable", "identifyDisabled", "inspectorMethodError", "type", "invalidContentType", "contentType", "invalidData", "invalidInspector", "invalidKey", "invalidMetricValue", "badType", "invalidContext", "invalidTagValue", "localStorageUnavailable", "networkError", "optionBelowMinimum", "minimum", "streamClosing", "streamConnecting", "streamError", "streamReconnectDelay", "tagValueTooLong", "unknownCustomEventKey", "unknownOption", "contextNotSpecified", "unrecoverableStreamError", "wrongOptionType", "expectedType", "actualType", "wrongOptionTypeBoolean", "require$$0", "baseOptionDefs", "default", "streamUrl", "eventsUrl", "sendEvents", "streaming", "sendLDHeaders", "requestHeaderTransform", "sendEventsOnlyForVariation", "useReport", "evaluationReasons", "eventCapacity", "flushInterval", "samplingInterval", "allAttributesPrivate", "privateAttributes", "bootstrap", "diagnosticRecordingInterval", "diagnosticOptOut", "wrapperName", "wrapperVersion", "stateProvider", "application", "validator", "validated", "id", "validateTagValue", "inspectors", "hooks", "plugins", "allowedTagCharacters", "canonicalizeUrl", "tagValue", "match", "warn", "configuration", "emitter", "extraOptionDefs", "optionDefs", "deprecatedOptions", "reportArgumentError", "maybeReportError", "config", "opts", "typeDescForValue", "optionDef", "allowedTypes", "split", "getTags", "tags", "headers", "getLDHeaders", "h", "userAgentHeaderName", "tagKeys", "sort", "map", "flattened", "item", "concat", "transformHeaders", "v1", "uuidv1", "require$$1", "EventSender_1", "environmentId", "baseHeaders", "sender", "events", "isDiagnostic", "httpRequest", "resolve", "jsonBody", "payloadId", "doPostRequest", "canRetry", "dateStr", "header", "time", "serverTime", "catch", "canonicalize_1", "canonicalize", "visited", "includes", "filter", "validKind", "encodeKey", "checkContext", "allowLegacyKey", "kindValid", "keyValid", "kinds", "every", "contextKey", "getContextKeys", "user", "entries", "getContextKinds", "getCanonicalKey", "EventSummarizer_1", "es", "startDate", "endDate", "counters", "contextKinds", "summarizeEvent", "counterKey", "variation", "counterVal", "Set", "contextKeys", "add", "creationDate", "getSummary", "flagsOut", "empty", "values", "flag", "counterOut", "unknown", "features", "clearSummary", "MultiEventSummarizer_1", "contextFilter", "summarizers", "contexts", "summarizer", "EventSummarizer", "getSummaries", "summarizersToFlush", "contextsForSummaries", "summary", "processEscapeCharacters", "getComponents", "reference", "component", "isLiteral", "compare", "aIsLiteral", "bIsLiteral", "bComponents", "aComponents", "literalToReference", "literal", "attributeReference", "cloneExcluding", "target", "references", "stack", "cloned", "excluded", "ptr", "source", "parent", "pop", "some", "ContextFilter_1", "protectedAttributes", "legacyTopLevelCopyAttributes", "filterSingleKind", "redactAnonymous", "AttributeReference", "anonymous", "_meta", "protectedAttr", "redactedAttributes", "filtered", "custom", "privateAttributeNames", "filteredContext", "EventProcessor_1", "diagnosticsAccumulator", "processor", "eventSender", "EventSender", "mainEventsUrl", "ContextFilter", "MultiEventSummarizer", "flushTimer", "queue", "lastKnownPastTime", "disabled", "exceededCapacity", "shouldSampleEvent", "makeOutputEvent", "addToOutbox", "incrementDroppedEvents", "enqueue", "addFullEvent", "addDebugEvent", "trackEvents", "debugEventsUntilDate", "debugEvent", "flush", "async", "eventsToSend", "setEventsInLastBatch", "debug", "responseInfo", "flushTick", "stop", "clearTimeout", "EventEmitter_1", "on", "handler", "off", "emit", "copiedHandlers", "getEvents", "getEventListenerCount", "readyEvent", "successEvent", "failureEvent", "InitializationState", "eventEmitter", "succeeded", "failed", "failureValue", "initializationPromise", "readyPromise", "onReady", "getInitializationPromise", "onSuccess", "onFailure", "getReadyPromise", "signalSuccess", "signalFailure", "PersistentFlagStore_1", "storage", "environment", "hash", "ident", "store", "getFlagsKey", "getContext", "loadFlags", "get", "dataStr", "data", "schema", "$schema", "ex", "clearFlags", "saveFlags", "clear", "PersistentStorage_1", "localStorageProvider", "loggedError", "logError", "isEnabled", "undefined", "require$$2", "Stream_1", "stream", "evalUrlPrefix", "withReasons", "baseReconnectDelay", "connectionAttemptStartTime", "firstConnectionErrorLogged", "reconnectTimeoutReference", "handlers", "retryCount", "getNextRetryDelay", "delay", "computedDelayMillis", "backoff", "trunc", "handleError", "closeConnection", "logConnectionResult", "tryConnect", "openConnection", "query", "readTimeoutMillis", "eventSourceFactory", "eventSourceAllowsReport", "method", "body", "info", "addEventListener", "onerror", "onopen", "close", "success", "recordStreamInit", "connect", "newHash", "newHandlers", "disconnect", "isConnected", "eventSourceIsActive", "promiseCoalescer_1", "finallyFn", "currentPromise", "currentCancelFn", "finalResolve", "finalReject", "coalescer", "p", "cancelFn", "resultPromise", "jsonContentType", "Requestor_1", "requestor", "activeRequests", "fetchJSON", "endpoint", "promiseCoalescer", "req", "statusText", "addPromise", "cancel", "fetchFlagSettings", "Identity_1", "initialContext", "onChange", "setContext", "AnonymousContextProcessor_1", "persistentStorage", "getContextKeyIdString", "processSingleKindContext", "cachedId", "processContext", "processedContext", "all", "diagnosticEvents", "DiagnosticId", "sdkKey", "diagnosticId", "sdkKeySuffix", "DiagnosticsAccumulator", "startTime", "dataSinceDate", "droppedEvents", "eventsInLastBatch", "streamInits", "reset", "getProps", "setProps", "props", "timestamp", "durationMillis", "DiagnosticsManager", "accumulator", "combinedMode", "diagnosticUseCombinedEvent", "localStorageKey", "diagnosticEventsUrl", "periodicInterval", "eventSentTime", "periodicTimer", "streamingEnabled", "manager", "makeInitProperties", "sdk", "makeSdkData", "makeConfigData", "diagnosticPlatformData", "sendDiagnosticEvent", "sendPeriodicEvent", "currentTime", "createPeriodicEventAndReset", "saveProperties", "sdkData", "diagnosticSdkData", "customBaseURI", "customStreamURI", "customEventsURI", "eventsCapacity", "eventsFlushIntervalMillis", "reconnectTimeMillis", "streamingDisabled", "diagnosticRecordingIntervalMillis", "usingSecureMode", "bootstrapMode", "fetchGoalsDisabled", "fetchGoals", "localStorageAvailable", "nextEventTime", "timeNow", "setStreaming", "enabled", "SafeInspector_1", "inspector", "errorLogged", "wrapper", "synchronous", "InspectorTypes", "flagUsed", "flagDetailsChanged", "flagDetailChanged", "clientIdentityChanged", "freeze", "InspectorManager_1", "InspectorManager", "inspectorsByType", "synchronousInspectorsByType", "safeInspectors", "SafeInspector", "safeInspector", "hasListeners", "onFlagUsed", "flagKey", "detail", "onFlags", "onFlagChanged", "onIdentityChanged", "timedPromise_1", "taskName", "_res", "UNKNOWN_HOOK_NAME", "tryExecuteStage", "hookName", "stage", "def", "getHookName", "hook", "getMetadata", "HookRunner", "initialHooks", "hooksInternal", "withEvaluation", "defaultValue", "hookContext", "hookData", "beforeEvaluation", "updatedData", "hookIndex", "afterEvaluation", "identify", "timeout", "beforeIdentify", "afterIdentify", "addHook", "afterTrack", "FlagStore_1", "flagOverrides", "deleted", "clearAllOverrides", "clearedOverrides", "getFlagOverrides", "getFlags", "getFlagsWithOverrides", "override", "removeOverride", "setFlags", "newFlags", "setOverride", "UNKNOWN_PLUGIN_NAME", "getPluginName", "plugin", "getPluginHooks", "environmentMetadata", "pluginHooks", "getHooks", "registerPlugins", "client", "register", "registerPluginsForDebugOverride", "debugOverride", "registerDebug", "createPluginEnvironment", "env", "pluginSdkMetadata", "pluginApplicationMetadata", "pluginEnvironment", "clientSideId", "require$$3", "changeEvent", "internalChangeEvent", "src", "initialize", "specifiedOptions", "createLogger", "EventEmitter", "initializationStateTracker", "InitializationStateTracker", "inspectorManager", "hookRunner", "createHookRunner", "PersistentStorage", "localStorage", "diagnosticsEnabled", "diagnostics", "diagnosticsManager", "Stream", "eventProcessor", "EventProcessor", "Requestor", "flagStore", "FlagStore", "useLocalStorage", "streamActive", "subscribedToChangeEvents", "streamForcedState", "inited", "closed", "firstEvent", "Identity", "enqueueEvent", "anonymousContextProcessor", "AnonymousContextProcessor", "persistentFlagStore", "PersistentFlagStore", "isDoNotTrack", "notifyInspectionFlagChanged", "newFlag", "getFlagDetail", "notifyInspectionFlagsChanged", "cur", "sendFlagEvent", "includeReason", "variationIndex", "flagVersion", "trackReason", "reason", "verifyContext", "variationDetailInternal", "sendEvent", "includeReasonInEvent", "isAllFlags", "notifyInspection", "errorKind", "prerequisites", "connectStream", "tryParseData", "jsonData", "ping", "contextAtTimeOfPingEvent", "requestedFlags", "replaceAllFlags", "put", "patch", "oldFlag", "mods", "newDetail", "previous", "current", "handleFlagChanges", "delete", "disconnectStream", "changes", "changeEventParams", "updateStreamingState", "shouldBeStreaming", "isChangeEventKey", "toUpperCase", "metadataKey", "validKey", "metadata", "state", "getInitialState", "initFromStateProvider", "validatedContext", "signalSuccessfulInit", "storedFlags", "signalFailedInit", "finishInit", "waitForInitialization", "initPromise", "timeoutPromise", "timedPromise", "race", "waitUntilReady", "onDone", "clearFirst", "flagValueMap", "variationDetail", "track", "metricValue", "customEventFilter", "getCurrentUrl", "contextKind", "haveListeners", "newState", "allFlags", "results", "finishClose", "currentFlag", "currentValue", "oldOverride", "realFlag", "getAllOverrides", "getFlagsInternal", "getEnvironmentId", "internalChangeEventName", "_objectSpread", "emptyResult", "newHttpRequest", "pageIsClosing", "window", "navigator", "chromeMatch", "isSyncXhrSupported", "xhr", "XMLHttpRequest", "open", "setRequestHeader", "send", "cancelled", "getResponseHeader", "responseText", "abort", "escapeStringRegexp", "string", "doesUrlMatch", "matcher", "href", "search", "regex", "testUrl", "canonicalUrl", "pattern", "GoalTracker", "goals", "onEvent", "tracker", "listenerFn", "clickGoals", "goal", "urls", "location", "matches", "selector", "elements", "document", "querySelectorAll", "parentNode", "dispose", "removeEventListener", "GoalManager", "clientVars", "readyCallback", "goalTracker", "refreshGoalTracker", "sendGoalEvent", "g", "interval", "currentUrl", "previousUrl", "checkUrl", "poll", "fn", "history", "pushState", "common", "goalsEvent", "eventUrlTransformer", "disableSyncEventPost", "hasCors", "disableSyncFlush", "syncFlush", "synchronousFlush", "httpAllowsPost", "httpFallbackPing", "Image", "eventSourceConstructor", "doNotTrack", "msDoNotTrack", "getItem", "setItem", "removeItem", "EventSourcePolyfill", "supportedOptions", "EventSource", "timeoutMillis", "esOptions", "defaultOptions", "heartbeatTimeout", "silentTimeout", "skipDefaultHeaders", "readyState", "OPEN", "CONNECTING", "validatedOptions", "goalsPromise", "onGoals", "waitUntilGoalsReady", "visibilityState", "basicLogger", "importBasicLogger", "createConsoleLogger", "index"]
}
