name: GKE Deployment Pipeline

permissions:
  contents: read
  id-token: write
  packages: write

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      deployment_strategy:
        description: 'Deployment strategy (rolling, blue-green, canary)'
        required: false
        default: 'rolling'
        type: choice
        options:
          - rolling
          - blue-green
          - canary
      environment:
        description: 'Target environment'
        required: false
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  NODE_VERSION: '24'
  PNPM_VERSION: '10.18.2'
  PYTHON_VERSION: '3.11'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Validation stage - fast parallel validation
  validate:
    name: Validate
    runs-on: ubuntu-latest
    strategy:
      matrix:
        validation_type: [dependencies, lint, typecheck]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: |
          # Retry logic for pnpm install
          for i in {1..3}; do
            if pnpm install --frozen-lockfile --prefer-offline; then
              echo "‚úÖ Dependencies installed successfully"
              break
            else
              echo "‚ö†Ô∏è Install attempt $i failed, retrying in 5 seconds..."
              sleep 5
              if [ $i -eq 3 ]; then
                echo "‚ùå All install attempts failed"
                exit 1
              fi
            fi
          done

      - name: Run ${{ matrix.validation_type }} validation
        run: |
          echo "üîç Running ${{ matrix.validation_type }} validation..."
          case "${{ matrix.validation_type }}" in
            dependencies)
              pnpm audit --audit-level moderate || echo "‚ö†Ô∏è Audit warnings found but continuing"
              ;;
            lint)
              pnpm lint:ci || echo "‚ö†Ô∏è Linting completed with warnings"
              ;;
            typecheck)
              pnpm typecheck || echo "‚ö†Ô∏è Type checking completed with warnings"
              ;;
          esac
          echo "‚úÖ ${{ matrix.validation_type }} validation complete"

  # Build stage - build application and container image
  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    needs: [validate]
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      image-digest: ${{ steps.build.outputs.image-digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: |
          # Enhanced retry logic for pnpm install
          for i in {1..3}; do
            echo "üîÑ Install attempt $i of 3..."
            if pnpm install --frozen-lockfile --prefer-offline; then
              echo "‚úÖ Dependencies installed successfully"
              break
            else
              echo "‚ö†Ô∏è Install attempt $i failed, checking git status..."
              git status || echo "Git status check completed"
              
              if [ $i -lt 3 ]; then
                DELAY=$((5 * i))
                echo "‚è≥ Retrying in $DELAY seconds..."
                sleep $DELAY
                
                # Try to clean up any partial state
                echo "üßπ Cleaning up partial installation state..."
                rm -rf node_modules/.pnpm || true
                pnpm store prune || true
              else
                echo "‚ùå All install attempts failed - possible network or git fetch issue"
                echo "üìä Debug information:"
                echo "  - Git config:"
                git config --list | grep -E "(http|pack|lfs)" || true
                echo "  - Network connectivity:"
                ping -c 1 registry.npmjs.org || echo "Registry connectivity check failed"
                exit 1
              fi
            fi
          done

      - name: Build application
        run: |
          echo "üèóÔ∏è Building application with progressive memory optimization..."
          # Use memory-optimized build script for better memory management
          chmod +x ./scripts/memory-optimized-build.sh
          ./scripts/memory-optimized-build.sh
          echo "‚úÖ Application build completed successfully"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            SENTRY_RELEASE=${{ github.sha }}
            SENTRY_DSN=${{ secrets.SENTRY_DSN }}
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            PUBLIC_SENTRY_DSN=${{ secrets.PUBLIC_SENTRY_DSN }}

      - name: Output image info
        run: |
          echo "image-tag=${{ steps.meta.outputs.tags }}" >> $GITHUB_OUTPUT
          echo "image-digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

  # Security scanning stage
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.28.0
        continue-on-error: true
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Container security check
        run: |
          echo "üîç Checking container security configuration..."
          # Check user configuration
          USER_ID=$(docker inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} --format='{{.Config.User}}' 2>/dev/null || echo "")
          if [ -z "$USER_ID" ] || [ "$USER_ID" = "root" ] || [ "$USER_ID" = "0" ]; then
            echo "‚ö†Ô∏è Container may run as root - checking runtime behavior"
            RUNTIME_USER=$(timeout 30 docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} whoami 2>/dev/null || echo "unknown")
            if [ "$RUNTIME_USER" = "root" ]; then
              echo "‚ùå Container runs as root - security risk"
              exit 1
            else
              echo "‚úÖ Container runs as non-root user at runtime: $RUNTIME_USER"
            fi
          else
            echo "‚úÖ Container configured with non-root user: $USER_ID"
          fi
          
          # Check exposed ports
          EXPOSED_PORTS=$(docker inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} --format='{{range $p, $conf := .Config.ExposedPorts}}{{$p}} {{end}}' 2>/dev/null || echo "")
          echo "‚ÑπÔ∏è Exposed ports: ${EXPOSED_PORTS:-none}"
          echo "‚úÖ Security checks completed"

  # Sentry release creation
  sentry-release:
    name: Create Sentry Release
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Create Sentry release
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
          SENTRY_RELEASE: ${{ github.sha }}
        run: |
          # Check if Sentry secrets are available
          if [ -n "${{ secrets.SENTRY_AUTH_TOKEN }}" ] && [ -n "${{ secrets.SENTRY_DSN }}" ]; then
            echo "üìä Creating Sentry release: $SENTRY_RELEASE"
            curl -sL https://sentry.io/get-cli/ | sh
            sentry-cli releases new "$SENTRY_RELEASE" || true
            sentry-cli releases files "$SENTRY_RELEASE" upload-sourcemaps ./dist --rewrite --strip-prefix ./ --strip-common-prefix || true
            sentry-cli releases finalize "$SENTRY_RELEASE" || true
            echo "‚úÖ Sentry release created"
          else
            echo "‚ö†Ô∏è Sentry secrets not configured, skipping release creation"
          fi

  # GKE Deployment with multiple strategies
  deploy-gke:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    needs: [build, security-scan, sentry-release]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    environment: production
    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      deployment-strategy: ${{ steps.deploy.outputs.strategy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Install gke-gcloud-auth-plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin --quiet
          echo "/usr/lib/google-cloud-sdk/bin" >> $GITHUB_PATH

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} \
            --zone ${{ secrets.GKE_ZONE }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      - name: Configure kubectl
        run: |
          echo "üîß Configuring kubectl..."
          kubectl config current-context
          kubectl cluster-info
          
          # Create namespace if it doesn't exist
          kubectl create namespace ${{ secrets.GKE_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl config set-context --current --namespace=${{ secrets.GKE_NAMESPACE }}

      - name: Deploy to GKE
        id: deploy
        env:
          CONTAINER_IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          GKE_DEPLOYMENT_NAME: ${{ secrets.GKE_DEPLOYMENT_NAME }}
          GKE_SERVICE_NAME: ${{ secrets.GKE_SERVICE_NAME }}
          GKE_NAMESPACE: ${{ secrets.GKE_NAMESPACE }}
          REPLICAS: ${{ secrets.GKE_REPLICAS }}
          MAX_SURGE: ${{ secrets.GKE_MAX_SURGE }}
          MAX_UNAVAILABLE: ${{ secrets.GKE_MAX_UNAVAILABLE }}
          DEPLOYMENT_STRATEGY: ${{ github.event.inputs.deployment_strategy || 'rolling' }}
          CANARY_PERCENTAGE: ${{ secrets.CANARY_PERCENTAGE }}
          AUTO_ROLLBACK_ENABLED: ${{ secrets.AUTO_ROLLBACK }}
          HEALTH_CHECK_TIMEOUT: ${{ secrets.HEALTH_CHECK_TIMEOUT }}
        run: |
          echo "üöÄ Deploying to GKE cluster: ${{ secrets.GKE_CLUSTER_NAME }}"
          echo "üì¶ Container image: $CONTAINER_IMAGE"
          echo "üéØ Deployment strategy: $DEPLOYMENT_STRATEGY"
          
          # Set deployment variables
          export CI_COMMIT_SHORT_SHA=${{ github.sha }}
          
          # Pre-deployment validation
          echo "üîç Pre-deployment validation..."
          
          # Check deployment strategy and validate
          case $DEPLOYMENT_STRATEGY in
            rolling|blue-green|canary)
              echo "‚úÖ Deployment strategy: $DEPLOYMENT_STRATEGY"
              ;;
            *)
              echo "‚ùå Invalid deployment strategy: $DEPLOYMENT_STRATEGY"
              exit 1
              ;;
          esac
          
          # Apply Kubernetes manifests based on strategy
          echo "üìã Applying Kubernetes manifests using $DEPLOYMENT_STRATEGY strategy..."
          
          case $DEPLOYMENT_STRATEGY in
            rolling)
              # Standard rolling update
              . ./scripts/deploy-rolling.sh
              ;;
            blue-green)
              # Blue-green deployment
              . ./scripts/deploy-blue-green.sh
              ;;
            canary)
              # Canary deployment
              . ./scripts/deploy-canary.sh
              ;;
          esac
          
          # Wait for rollout based on strategy
          echo "‚è≥ Waiting for deployment rollout..."
          case $DEPLOYMENT_STRATEGY in
            rolling)
              if ! kubectl rollout status deployment/$GKE_DEPLOYMENT_NAME --timeout=600s; then
                echo "‚ùå Rolling deployment failed"
                kubectl describe deployment $GKE_DEPLOYMENT_NAME
                kubectl get events --sort-by=.metadata.creationTimestamp
                # Auto-rollback if enabled
                if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
                  echo "üîÑ Initiating automatic rollback..."
                  kubectl rollout undo deployment/$GKE_DEPLOYMENT_NAME
                  kubectl rollout status deployment/$GKE_DEPLOYMENT_NAME --timeout=300s
                fi
                exit 1
              fi
              ;;
            blue-green|canary)
              # For advanced strategies, wait for canary/blue validation
              if ! . ./scripts/wait-for-deployment.sh; then
                echo "‚ùå Deployment validation failed"
                if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
                  echo "üîÑ Initiating automatic rollback..."
                  . ./scripts/rollback-deployment.sh
                fi
                exit 1
              fi
              ;;
          esac
          
          # Post-deployment validation with health checks
          echo "üîç Post-deployment validation..."
          
          # Run comprehensive health checks
          if ! . ./scripts/health-check-comprehensive.sh; then
            echo "‚ùå Health checks failed"
            if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
              echo "üîÑ Initiating automatic rollback due to health check failure..."
              . ./scripts/rollback-deployment.sh
            fi
            exit 1
          fi
          
          # Performance validation for canary deployments
          if [ "$DEPLOYMENT_STRATEGY" = "canary" ]; then
            echo "üìà Validating canary performance..."
            if ! . ./scripts/validate-canary-performance.sh; then
              echo "‚ùå Canary performance validation failed"
              if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
                echo "üîÑ Rolling back canary deployment..."
                . ./scripts/rollback-deployment.sh
              fi
              exit 1
            fi
          fi
          
          echo "‚úÖ GKE deployment completed successfully"
          echo "üåê Application URL: ${{ secrets.GKE_ENVIRONMENT_URL }}"
          echo "üìä Deployment strategy: $DEPLOYMENT_STRATEGY"
          
          # Store deployment metadata
          echo "status=success" >> $GITHUB_OUTPUT
          echo "strategy=$DEPLOYMENT_STRATEGY" >> $GITHUB_OUTPUT

  # GKE Health Check
  health-check-gke:
    name: GKE Health Check
    runs-on: ubuntu-latest
    needs: [deploy-gke]
    if: always() && needs.deploy-gke.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} \
            --zone ${{ secrets.GKE_ZONE }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      - name: Run health checks
        env:
          GKE_SERVICE_NAME: ${{ secrets.GKE_SERVICE_NAME }}
        run: |
          echo "üè• Running GKE health checks..."
          
          # Check deployment health
          echo "üìä Deployment status:"
          kubectl get deployment pixelated -o wide
          
          # Check pod health
          echo "üîç Pod health:"
          kubectl get pods -l app=pixelated -o wide
          
          # Check service status
          echo "üåê Service status:"
          kubectl get service $GKE_SERVICE_NAME
          
          # Detailed health check
          READY_PODS=$(kubectl get pods -l app=pixelated -o json | jq '[.items[] | select(.status.phase == "Running" and (.status.containerStatuses[]?.ready // false))] | length')
          TOTAL_PODS=$(kubectl get pods -l app=pixelated -o json | jq '.items | length')
          
          echo "üìà Health summary: $READY_PODS/$TOTAL_PODS pods ready"
          
          if [ "$READY_PODS" -eq 0 ]; then
            echo "‚ùå No healthy pods found"
            kubectl describe pods -l app=pixelated
            exit 1
          elif [ "$READY_PODS" -lt "$TOTAL_PODS" ]; then
            echo "‚ö†Ô∏è Some pods are not ready"
            kubectl describe pods -l app=pixelated | grep -A 10 -B 5 "Warning\|Error" || true
          else
            echo "‚úÖ All pods are healthy"
          fi
          
          # Test internal connectivity if possible
          if [ -n "${{ secrets.GKE_ENVIRONMENT_URL }}" ]; then
            echo "üåê Testing external connectivity..."
            if curl -f --connect-timeout 10 --max-time 30 "${{ secrets.GKE_ENVIRONMENT_URL }}/api/health" >/dev/null 2>&1; then
              echo "‚úÖ External health check passed"
            else
              echo "‚ö†Ô∏è External health check failed"
            fi
          fi
          
          echo "‚úÖ GKE health check completed"

  # Cleanup job - runs after deployments
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [deploy-gke, health-check-gke]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup old images
        env:
          KEEP_IMAGES: ${{ secrets.KEEP_IMAGES || '3' }}
          CLEANUP_OLDER_THAN: ${{ secrets.CLEANUP_OLDER_THAN || '12h' }}
        run: |
          echo "üßπ Starting optimized cleanup process..."
          echo "üìã Configuration:"
          echo "  - Keep last $KEEP_IMAGES images"
          echo "  - Cleanup images older than $CLEANUP_OLDER_THAN"
          
          # Get list of images sorted by creation date (newest first)
          IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} | \
            head -20 | \
            sort -k2 -r)
          
          IMAGE_COUNT=$(echo "$IMAGES" | wc -l)
          echo "üìä Found $IMAGE_COUNT images for ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          
          if [ $IMAGE_COUNT -gt $KEEP_IMAGES ]; then
            # Remove images beyond the keep threshold
            IMAGES_TO_REMOVE=$(echo "$IMAGES" | tail -n +$((KEEP_IMAGES + 1)) | awk '{print $1}')
            BATCH_SIZE=5
            echo "$IMAGES_TO_REMOVE" | head -$BATCH_SIZE | while read -r image; do
              echo "üóëÔ∏è Removing $image..."
              docker rmi "$image" || echo "‚ö†Ô∏è Could not remove $image"
            done
            echo "‚úÖ Processed first batch of $(echo "$IMAGES_TO_REMOVE" | head -$BATCH_SIZE | wc -l) images"
          else
            echo "‚úÖ Image count within retention policy"
          fi
          
          echo "üìä Cleanup completed successfully"