name: GKE Deployment Pipeline

permissions:
  contents: read
  id-token: write
  packages: write

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      deployment_strategy:
        description: "Deployment strategy (rolling, blue-green, canary)"
        required: false
        default: "rolling"
        type: choice
        options:
          - rolling
          - blue-green
          - canary
      environment:
        description: "Target environment"
        required: false
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  NODE_VERSION: "24"
  PNPM_VERSION: "10.19.0"
  PYTHON_VERSION: "3.11"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Validation stage - fast parallel validation
  validate:
    name: Validate
    runs-on: ubuntu-latest
    strategy:
      matrix:
        validation_type: [dependencies, lint, typecheck]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Load environment from .env
        run: |
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading environment variables from .env file"
            # Export variables that might be in .env
            while IFS= read -r line; do
              if [[ $line =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                export "$line"
              fi
            done < .env
          fi

      - name: Install dependencies
        run: |
          # Retry logic for pnpm install
          for i in {1..3}; do
            if pnpm install --frozen-lockfile --prefer-offline; then
              echo "‚úÖ Dependencies installed successfully"
              break
            else
              echo "‚ö†Ô∏è Install attempt $i failed, retrying in 5 seconds..."
              sleep 5
              if [ $i -eq 3 ]; then
                echo "‚ùå All install attempts failed"
                exit 1
              fi
            fi
          done

      - name: Run ${{ matrix.validation_type }} validation
        run: |
          echo "üîç Running ${{ matrix.validation_type }} validation..."
          case "${{ matrix.validation_type }}" in
            dependencies)
              pnpm audit --audit-level moderate || echo "‚ö†Ô∏è Audit warnings found but continuing"
              ;;
            lint)
              pnpm lint:ci || echo "‚ö†Ô∏è Linting completed with warnings"
              ;;
            typecheck)
              pnpm typecheck || echo "‚ö†Ô∏è Type checking completed with warnings"
              ;;
          esac
          echo "‚úÖ ${{ matrix.validation_type }} validation complete"

  # Build stage - build application and container image
  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    needs: [validate]
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      image-digest: ${{ steps.build.outputs.image-digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Load environment from .env
        run: |
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading environment variables from .env file"
            # Export variables that might be in .env
            while IFS= read -r line; do
              if [[ $line =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                export "$line"
              fi
            done < .env
          fi

      - name: Install dependencies
        run: |
          # Enhanced retry logic for pnpm install
          for i in {1..3}; do
            echo "üîÑ Install attempt $i of 3..."
            if pnpm install --frozen-lockfile --prefer-offline; then
              echo "‚úÖ Dependencies installed successfully"
              break
            else
              echo "‚ö†Ô∏è Install attempt $i failed, checking git status..."
              git status || echo "Git status check completed"
              
              if [ $i -lt 3 ]; then
                DELAY=$((5 * i))
                echo "‚è≥ Retrying in $DELAY seconds..."
                sleep $DELAY
                
                # Try to clean up any partial state
                echo "üßπ Cleaning up partial installation state..."
                rm -rf node_modules/.pnpm || true
                pnpm store prune || true
              else
                echo "‚ùå All install attempts failed - possible network or git fetch issue"
                echo "üìä Debug information:"
                echo "  - Git config:"
                git config --list | grep -E "(http|pack|lfs)" || true
                echo "  - Network connectivity:"
                ping -c 1 registry.npmjs.org || echo "Registry connectivity check failed"
                exit 1
              fi
            fi
          done

      - name: Build application
        run: |
          echo "üèóÔ∏è Building application with progressive memory optimization..."
          # Use memory-optimized build script for better memory management
          chmod +x ./scripts/memory-optimized-build.sh
          ./scripts/memory-optimized-build.sh
          echo "‚úÖ Application build completed successfully"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Load Sentry environment
        run: |
          # Load Sentry variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading Sentry configuration from .env"
            SENTRY_DSN=$(grep "^SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            PUBLIC_SENTRY_DSN=$(grep "^PUBLIC_SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            SENTRY_AUTH_TOKEN=$(grep "^SENTRY_AUTH_TOKEN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            
            if [[ -n "$SENTRY_DSN" ]]; then
              echo "SENTRY_DSN=${SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$PUBLIC_SENTRY_DSN" ]]; then
              echo "PUBLIC_SENTRY_DSN=${PUBLIC_SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$SENTRY_AUTH_TOKEN" ]]; then
              echo "SENTRY_AUTH_TOKEN=${SENTRY_AUTH_TOKEN}" >> $GITHUB_ENV
            fi
          fi

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            SENTRY_RELEASE=${{ github.sha }}
            SENTRY_DSN=${{ env.SENTRY_DSN || secrets.SENTRY_DSN }}
            SENTRY_AUTH_TOKEN=${{ env.SENTRY_AUTH_TOKEN || secrets.SENTRY_AUTH_TOKEN }}
            PUBLIC_SENTRY_DSN=${{ env.PUBLIC_SENTRY_DSN || secrets.PUBLIC_SENTRY_DSN }}

      - name: Output image info
        run: |
          echo "image-tag=${{ steps.meta.outputs.tags }}" >> $GITHUB_OUTPUT
          echo "image-digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

  # Security scanning stage
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.28.0
        continue-on-error: true
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        continue-on-error: true
        with:
          sarif_file: "trivy-results.sarif"

      - name: Container security check
        run: |
          echo "üîç Checking container security configuration..."
          # Check user configuration
          USER_ID=$(docker inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} --format='{{.Config.User}}' 2>/dev/null || echo "")
          if [ -z "$USER_ID" ] || [ "$USER_ID" = "root" ] || [ "$USER_ID" = "0" ]; then
            echo "‚ö†Ô∏è Container may run as root - checking runtime behavior"
            RUNTIME_USER=$(timeout 30 docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} whoami 2>/dev/null || echo "unknown")
            if [ "$RUNTIME_USER" = "root" ]; then
              echo "‚ùå Container runs as root - security risk"
              exit 1
            else
              echo "‚úÖ Container runs as non-root user at runtime: $RUNTIME_USER"
            fi
          else
            echo "‚úÖ Container configured with non-root user: $USER_ID"
          fi

          # Check exposed ports
          EXPOSED_PORTS=$(docker inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} --format='{{range $p, $conf := .Config.ExposedPorts}}{{$p}} {{end}}' 2>/dev/null || echo "")
          echo "‚ÑπÔ∏è Exposed ports: ${EXPOSED_PORTS:-none}"
          echo "‚úÖ Security checks completed"

  # Sentry release creation
  sentry-release:
    name: Create Sentry Release
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Load Sentry environment
        run: |
          # Load Sentry variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading Sentry configuration from .env"
            SENTRY_DSN=$(grep "^SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            PUBLIC_SENTRY_DSN=$(grep "^PUBLIC_SENTRY_DSN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            SENTRY_AUTH_TOKEN=$(grep "^SENTRY_AUTH_TOKEN=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            SENTRY_ORG=$(grep "^SENTRY_ORG=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            SENTRY_PROJECT=$(grep "^SENTRY_PROJECT=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            
            if [[ -n "$SENTRY_DSN" ]]; then
              echo "SENTRY_DSN=${SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$PUBLIC_SENTRY_DSN" ]]; then
              echo "PUBLIC_SENTRY_DSN=${PUBLIC_SENTRY_DSN}" >> $GITHUB_ENV
            fi
            if [[ -n "$SENTRY_AUTH_TOKEN" ]]; then
              echo "SENTRY_AUTH_TOKEN=${SENTRY_AUTH_TOKEN}" >> $GITHUB_ENV
            fi
            if [[ -n "$SENTRY_ORG" ]]; then
              echo "SENTRY_ORG=${SENTRY_ORG}" >> $GITHUB_ENV
            fi
            if [[ -n "$SENTRY_PROJECT" ]]; then
              echo "SENTRY_PROJECT=${SENTRY_PROJECT}" >> $GITHUB_ENV
            fi
          fi

      - name: Create Sentry release
        if: ${{ env.SENTRY_AUTH_TOKEN != '' && env.SENTRY_DSN != '' }}
        env:
          SENTRY_AUTH_TOKEN: ${{ env.SENTRY_AUTH_TOKEN || secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ env.SENTRY_ORG || secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ env.SENTRY_PROJECT || secrets.SENTRY_PROJECT }}
          SENTRY_RELEASE: ${{ github.sha }}
        run: |
          echo "üìä Creating Sentry release: $SENTRY_RELEASE"
          curl -sL https://sentry.io/get-cli/ | sh
          sentry-cli releases new "$SENTRY_RELEASE" || true
          sentry-cli releases files "$SENTRY_RELEASE" upload-sourcemaps ./dist --rewrite --strip-prefix ./ --strip-common-prefix || true
          sentry-cli releases finalize "$SENTRY_RELEASE" || true
          echo "‚úÖ Sentry release created"

  # GKE Deployment with multiple strategies
  deploy-gke:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    needs: [build, security-scan, sentry-release]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    environment: production
    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      deployment-strategy: ${{ steps.deploy.outputs.strategy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load GCP environment
        run: |
          # Load GCP variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading GCP configuration from .env"
            GCP_PROJECT_ID=$(grep "^GCP_PROJECT_ID=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_CLUSTER_NAME=$(grep "^GKE_CLUSTER_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_ZONE=$(grep "^GKE_ZONE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_NAMESPACE=$(grep "^GKE_NAMESPACE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_DEPLOYMENT_NAME=$(grep "^GKE_DEPLOYMENT_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_SERVICE_NAME=$(grep "^GKE_SERVICE_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_ENVIRONMENT_URL=$(grep "^GKE_ENVIRONMENT_URL=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GCP_SERVICE_ACCOUNT_KEY=$(grep "^GCP_SERVICE_ACCOUNT_KEY=" .env | cut -d'=' -f2- | sed 's/^'\''//;s/'\''$//' || echo "")
            
            if [[ -n "$GCP_PROJECT_ID" ]]; then
              echo "GCP_PROJECT_ID=${GCP_PROJECT_ID}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_CLUSTER_NAME" ]]; then
              echo "GKE_CLUSTER_NAME=${GKE_CLUSTER_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_ZONE" ]]; then
              echo "GKE_ZONE=${GKE_ZONE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_NAMESPACE" ]]; then
              echo "GKE_NAMESPACE=${GKE_NAMESPACE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_DEPLOYMENT_NAME" ]]; then
              echo "GKE_DEPLOYMENT_NAME=${GKE_DEPLOYMENT_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_SERVICE_NAME" ]]; then
              echo "GKE_SERVICE_NAME=${GKE_SERVICE_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_ENVIRONMENT_URL" ]]; then
              echo "GKE_ENVIRONMENT_URL=${GKE_ENVIRONMENT_URL}" >> $GITHUB_ENV
            fi
            if [[ -n "$GCP_SERVICE_ACCOUNT_KEY" ]]; then
              echo "GCP_SERVICE_ACCOUNT_KEY=${GCP_SERVICE_ACCOUNT_KEY}" >> $GITHUB_ENV
            fi
          fi

      - name: Verify Workload Identity Configuration
        run: |
          echo "üîç Verifying workload identity configuration..."
          echo "GCP_PROJECT_ID: ${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}"
          echo "Workload Identity Provider: projects/751556915102/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
          echo "Service Account: action@pixelatedempathy.com"
      - name: Verify Workload Identity Configuration
        run: |
          echo "üîç Verifying workload identity configuration..."
          echo "GCP_PROJECT_ID: ${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}"
          echo "Workload Identity Provider: projects/${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
          echo "Service Account: action@pixelatedempathy.com"
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER || format('projects/{0}/locations/global/workloadIdentityPools/github-pool/providers/github-provider', secrets.GCP_PROJECT_ID) }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL || 'action@pixelatedempathy.com' }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER_NAME || secrets.GKE_CLUSTER_NAME }} \
            --zone ${{ env.GKE_ZONE || secrets.GKE_ZONE }} \
            --project ${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}

      - name: Configure kubectl
        run: |
          echo "üîß Configuring kubectl..."
          kubectl config current-context
          kubectl cluster-info

          # Create namespace if it doesn't exist
          kubectl create namespace ${{ env.GKE_NAMESPACE || secrets.GKE_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl config set-context --current --namespace=${{ env.GKE_NAMESPACE || secrets.GKE_NAMESPACE }}

      - name: Deploy to GKE
        id: deploy
        env:
          CONTAINER_IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          GKE_DEPLOYMENT_NAME: ${{ env.GKE_DEPLOYMENT_NAME || secrets.GKE_DEPLOYMENT_NAME }}
          GKE_SERVICE_NAME: ${{ env.GKE_SERVICE_NAME || secrets.GKE_SERVICE_NAME }}
          GKE_NAMESPACE: ${{ env.GKE_NAMESPACE || secrets.GKE_NAMESPACE }}
          REPLICAS: ${{ env.GKE_REPLICAS || secrets.GKE_REPLICAS || '3' }}
          MAX_SURGE: ${{ env.GKE_MAX_SURGE || secrets.GKE_MAX_SURGE || '1' }}
          MAX_UNAVAILABLE: ${{ env.GKE_MAX_UNAVAILABLE || secrets.GKE_MAX_UNAVAILABLE || '0' }}
          DEPLOYMENT_STRATEGY: ${{ github.event.inputs.deployment_strategy || 'rolling' }}
          CANARY_PERCENTAGE: ${{ env.CANARY_PERCENTAGE || secrets.CANARY_PERCENTAGE || '25' }}
          AUTO_ROLLBACK_ENABLED: ${{ env.AUTO_ROLLBACK || secrets.AUTO_ROLLBACK || 'true' }}
          HEALTH_CHECK_TIMEOUT: ${{ env.HEALTH_CHECK_TIMEOUT || secrets.HEALTH_CHECK_TIMEOUT || '300' }}
        run: |
          echo "üöÄ Deploying to GKE cluster: ${{ env.GKE_CLUSTER_NAME || secrets.GKE_CLUSTER_NAME }}"
          echo "üì¶ Container image: $CONTAINER_IMAGE"
          echo "üéØ Deployment strategy: $DEPLOYMENT_STRATEGY"

          # Set deployment variables
          export CI_COMMIT_SHORT_SHA=${{ github.sha }}

          # Pre-deployment validation
          echo "üîç Pre-deployment validation..."

          # Check deployment strategy and validate
          case $DEPLOYMENT_STRATEGY in
            rolling|blue-green|canary)
              echo "‚úÖ Deployment strategy: $DEPLOYMENT_STRATEGY"
              ;;
            *)
              echo "‚ùå Invalid deployment strategy: $DEPLOYMENT_STRATEGY"
              exit 1
              ;;
          esac

          # Apply Kubernetes manifests based on strategy
          echo "üìã Applying Kubernetes manifests using $DEPLOYMENT_STRATEGY strategy..."

          case $DEPLOYMENT_STRATEGY in
            rolling)
              # Standard rolling update
              . ./scripts/deploy-rolling.sh
              ;;
            blue-green)
              # Blue-green deployment
              . ./scripts/deploy-blue-green.sh
              ;;
            canary)
              # Canary deployment
              . ./scripts/deploy-canary.sh
              ;;
          esac

          # Wait for rollout based on strategy
          echo "‚è≥ Waiting for deployment rollout..."
          case $DEPLOYMENT_STRATEGY in
            rolling)
              if ! kubectl rollout status deployment/$GKE_DEPLOYMENT_NAME --timeout=600s; then
                echo "‚ùå Rolling deployment failed"
                kubectl describe deployment $GKE_DEPLOYMENT_NAME
                kubectl get events --sort-by=.metadata.creationTimestamp
                # Auto-rollback if enabled
                if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
                  echo "üîÑ Initiating automatic rollback..."
                  kubectl rollout undo deployment/$GKE_DEPLOYMENT_NAME
                  kubectl rollout status deployment/$GKE_DEPLOYMENT_NAME --timeout=300s
                fi
                exit 1
              fi
              ;;
            blue-green|canary)
              # For advanced strategies, wait for canary/blue validation
              if ! . ./scripts/wait-for-deployment.sh; then
                echo "‚ùå Deployment validation failed"
                if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
                  echo "üîÑ Initiating automatic rollback..."
                  . ./scripts/rollback-deployment.sh
                fi
                exit 1
              fi
              ;;
          esac

          # Post-deployment validation with health checks
          echo "üîç Post-deployment validation..."

          # Run comprehensive health checks
          if ! . ./scripts/health-check-comprehensive.sh; then
            echo "‚ùå Health checks failed"
            if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
              echo "üîÑ Initiating automatic rollback due to health check failure..."
              . ./scripts/rollback-deployment.sh
            fi
            exit 1
          fi

          # Performance validation for canary deployments
          if [ "$DEPLOYMENT_STRATEGY" = "canary" ]; then
            echo "üìà Validating canary performance..."
            if ! . ./scripts/validate-canary-performance.sh; then
              echo "‚ùå Canary performance validation failed"
              if [ "$AUTO_ROLLBACK_ENABLED" = "true" ]; then
                echo "üîÑ Rolling back canary deployment..."
                . ./scripts/rollback-deployment.sh
              fi
              exit 1
            fi
          fi

          echo "‚úÖ GKE deployment completed successfully"
          echo "üåê Application URL: ${{ env.GKE_ENVIRONMENT_URL || secrets.GKE_ENVIRONMENT_URL }}"
          echo "üìä Deployment strategy: $DEPLOYMENT_STRATEGY"

          # Store deployment metadata
          echo "status=success" >> $GITHUB_OUTPUT
          echo "strategy=$DEPLOYMENT_STRATEGY" >> $GITHUB_OUTPUT

  # GKE Health Check
  health-check-gke:
    name: GKE Health Check
    runs-on: ubuntu-latest
    needs: [deploy-gke]
    if: always() && needs.deploy-gke.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load GCP environment
        run: |
          # Load GCP variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading GCP configuration from .env"
            GCP_PROJECT_ID=$(grep "^GCP_PROJECT_ID=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_CLUSTER_NAME=$(grep "^GKE_CLUSTER_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_ZONE=$(grep "^GKE_ZONE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_NAMESPACE=$(grep "^GKE_NAMESPACE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_SERVICE_NAME=$(grep "^GKE_SERVICE_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GCP_SERVICE_ACCOUNT_KEY=$(grep "^GCP_SERVICE_ACCOUNT_KEY=" .env | cut -d'=' -f2- | sed 's/^'\''//;s/'\''$//' || echo "")
            
            if [[ -n "$GCP_PROJECT_ID" ]]; then
              echo "GCP_PROJECT_ID=${GCP_PROJECT_ID}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_CLUSTER_NAME" ]]; then
              echo "GKE_CLUSTER_NAME=${GKE_CLUSTER_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_ZONE" ]]; then
              echo "GKE_ZONE=${GKE_ZONE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_NAMESPACE" ]]; then
              echo "GKE_NAMESPACE=${GKE_NAMESPACE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_SERVICE_NAME" ]]; then
              echo "GKE_SERVICE_NAME=${GKE_SERVICE_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GCP_SERVICE_ACCOUNT_KEY" ]]; then
              echo "GCP_SERVICE_ACCOUNT_KEY=${GCP_SERVICE_ACCOUNT_KEY}" >> $GITHUB_ENV
            fi
          fi

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER || format('projects/{0}/locations/global/workloadIdentityPools/github-pool/providers/github-provider', secrets.GCP_PROJECT_ID) }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL || 'action@pixelatedempathy.com' }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER_NAME || secrets.GKE_CLUSTER_NAME }} \
            --zone ${{ env.GKE_ZONE || secrets.GKE_ZONE }} \
            --project ${{ env.GCP_PROJECT_ID || secrets.GCP_PROJECT_ID }}

      - name: Run health checks
        env:
          GKE_SERVICE_NAME: ${{ env.GKE_SERVICE_NAME || secrets.GKE_SERVICE_NAME }}
          GKE_ENVIRONMENT_URL: ${{ env.GKE_ENVIRONMENT_URL || secrets.GKE_ENVIRONMENT_URL }}
        run: |
          echo "üè• Running GKE health checks..."

          # Check deployment health
          echo "üìä Deployment status:"
          kubectl get deployment pixelated -o wide

          # Check pod health
          echo "üîç Pod health:"
          kubectl get pods -l app=pixelated -o wide

          # Check service status
          echo "üåê Service status:"
          kubectl get service $GKE_SERVICE_NAME

          # Detailed health check
          READY_PODS=$(kubectl get pods -l app=pixelated -o json | jq '[.items[] | select(.status.phase == "Running" and (.status.containerStatuses[]?.ready // false))] | length')
          TOTAL_PODS=$(kubectl get pods -l app=pixelated -o json | jq '.items | length')

          echo "üìà Health summary: $READY_PODS/$TOTAL_PODS pods ready"

          if [ "$READY_PODS" -eq 0 ]; then
            echo "‚ùå No healthy pods found"
            kubectl describe pods -l app=pixelated
            exit 1
          elif [ "$READY_PODS" -lt "$TOTAL_PODS" ]; then
            echo "‚ö†Ô∏è Some pods are not ready"
            kubectl describe pods -l app=pixelated | grep -A 10 -B 5 "Warning\|Error" || true
          else
            echo "‚úÖ All pods are healthy"
          fi

          # Test internal connectivity if possible
          if [ -n "$GKE_ENVIRONMENT_URL" ]; then
            echo "üåê Testing external connectivity..."
            if curl -f --connect-timeout 10 --max-time 30 "$GKE_ENVIRONMENT_URL/api/health" >/dev/null 2>&1; then
              echo "‚úÖ External health check passed"
            else
              echo "‚ö†Ô∏è External health check failed"
            fi
          fi

          echo "‚úÖ GKE health check completed"

  # Cleanup job - runs after deployments
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [deploy-gke, health-check-gke]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load GCP environment
        run: |
          # Load GCP variables from .env if available
          if [[ -f ".env" ]]; then
            echo "‚ÑπÔ∏è Loading GCP configuration from .env"
            GCP_PROJECT_ID=$(grep "^GCP_PROJECT_ID=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_CLUSTER_NAME=$(grep "^GKE_CLUSTER_NAME=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GKE_ZONE=$(grep "^GKE_ZONE=" .env | cut -d'=' -f2- | tr -d "'\"" || echo "")
            GCP_SERVICE_ACCOUNT_KEY=$(grep "^GCP_SERVICE_ACCOUNT_KEY=" .env | cut -d'=' -f2- | sed 's/^'\''//;s/'\''$//' || echo "")
            
            if [[ -n "$GCP_PROJECT_ID" ]]; then
              echo "GCP_PROJECT_ID=${GCP_PROJECT_ID}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_CLUSTER_NAME" ]]; then
              echo "GKE_CLUSTER_NAME=${GKE_CLUSTER_NAME}" >> $GITHUB_ENV
            fi
            if [[ -n "$GKE_ZONE" ]]; then
              echo "GKE_ZONE=${GKE_ZONE}" >> $GITHUB_ENV
            fi
            if [[ -n "$GCP_SERVICE_ACCOUNT_KEY" ]]; then
              echo "GCP_SERVICE_ACCOUNT_KEY=${GCP_SERVICE_ACCOUNT_KEY}" >> $GITHUB_ENV
            fi
          fi

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER || format('projects/{0}/locations/global/workloadIdentityPools/github-pool/providers/github-provider', secrets.GCP_PROJECT_ID) }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL || 'action@pixelatedempathy.com' }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup old images
        env:
          KEEP_IMAGES: ${{ env.KEEP_IMAGES || secrets.KEEP_IMAGES || '3' }}
          CLEANUP_OLDER_THAN: ${{ env.CLEANUP_OLDER_THAN || secrets.CLEANUP_OLDER_THAN || '12h' }}
        run: |
          echo "üßπ Starting optimized cleanup process..."
          echo "üìã Configuration:"
          echo "  - Keep last $KEEP_IMAGES images"
          echo "  - Cleanup images older than $CLEANUP_OLDER_THAN"

          # Get list of images sorted by creation date (newest first)
          IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} | \
            head -20 | \
            sort -k2 -r)

          IMAGE_COUNT=$(echo "$IMAGES" | wc -l)
          echo "üìä Found $IMAGE_COUNT images for ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"

          if [ $IMAGE_COUNT -gt $KEEP_IMAGES ]; then
            # Remove images beyond the keep threshold
            IMAGES_TO_REMOVE=$(echo "$IMAGES" | tail -n +$((KEEP_IMAGES + 1)) | awk '{print $1}')
            BATCH_SIZE=5
            echo "$IMAGES_TO_REMOVE" | head -$BATCH_SIZE | while read -r image; do
              echo "üóëÔ∏è Removing $image..."
              docker rmi "$image" || echo "‚ö†Ô∏è Could not remove $image"
            done
            echo "‚úÖ Processed first batch of $(echo "$IMAGES_TO_REMOVE" | head -$BATCH_SIZE | wc -l) images"
          else
            echo "‚úÖ Image count within retention policy"
          fi

          echo "üìä Cleanup completed successfully"
